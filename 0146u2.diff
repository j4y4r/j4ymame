--- makefile-old	2012-05-28 20:16:17.000000000 +0200
+++ makefile	2012-06-11 20:55:35.000000000 +0200
@@ -758,10 +758,10 @@
 
 ifndef EXECUTABLE_DEFINED
 
-$(EMULATOR): $(VERSIONOBJ) $(EMUINFOOBJ) $(DRIVLISTOBJ) $(DRVLIBS) $(LIBOSD) $(LIBCPU) $(LIBEMU) $(LIBDASM) $(LIBSOUND) $(LIBUTIL) $(EXPAT) $(SOFTFLOAT) $(JPEG_LIB) $(FLAC_LIB) $(7Z_LIB) $(FORMATS_LIB) $(ZLIB) $(LIBOCORE) $(RESFILE)
+$(EMULATOR): $(EMUINFOOBJ) $(DRIVLISTOBJ) $(DRVLIBS) $(LIBOSD) $(LIBCPU) $(LIBEMU) $(LIBDASM) $(LIBSOUND) $(LIBUTIL) $(EXPAT) $(SOFTFLOAT) $(JPEG_LIB) $(FLAC_LIB) $(7Z_LIB) $(FORMATS_LIB) $(ZLIB) $(LIBOCORE) $(RESFILE)
 	$(CC) $(CDEFS) $(CFLAGS) -c $(SRC)/version.c -o $(VERSIONOBJ)
 	@echo Linking $@...
-	$(LD) $(LDFLAGS) $(LDFLAGSEMULATOR) $^ $(LIBS) -o $@
+	$(LD) $(LDFLAGS) $(LDFLAGSEMULATOR) $(VERSIONOBJ) $^ $(LIBS) -o $@
 ifeq ($(TARGETOS),win32)
 ifdef SYMBOLS
 ifndef MSVC_BUILD
diff -Nru src-old/emu/cpu/cpu.mak src/emu/cpu/cpu.mak
--- src-old/emu/cpu/cpu.mak	2012-06-07 22:14:04.000000000 +0200
+++ src/emu/cpu/cpu.mak	2012-06-14 17:52:32.000000000 +0200
@@ -1608,6 +1608,7 @@
 OBJDIRS += $(CPUOBJ)/tms9900
 CPUOBJS += $(CPUOBJ)/tms9900/tms9900.o
 CPUOBJS += $(CPUOBJ)/tms9900/tms9900l.o
+CPUOBJS += $(CPUOBJ)/tms9900/tms9980a.o
 CPUOBJS += $(CPUOBJ)/tms9900/tms9980al.o
 CPUOBJS += $(CPUOBJ)/tms9900/tms9995.o
 CPUOBJS += $(CPUOBJ)/tms9900/tms9995l.o
@@ -1623,13 +1624,18 @@
 								$(CPUSRC)/tms9900/99xxcore.h \
 								$(CPUSRC)/tms9900/99xxstat.h
 
+$(CPUOBJ)/tms9900/tms9980a.o:	$(CPUSRC)/tms9900/tms9980a.c \
+								$(CPUSRC)/tms9900/tms9980a.h \
+								$(CPUSRC)/tms9900/tms9900.c \
+								$(CPUSRC)/tms9900/tms9900.h
+
 $(CPUOBJ)/tms9900/tms9980al.o:	$(CPUSRC)/tms9900/tms9980al.c \
 								$(CPUSRC)/tms9900/tms9900l.h \
 								$(CPUSRC)/tms9900/99xxcore.h \
 								$(CPUSRC)/tms9900/99xxstat.h
 
 $(CPUOBJ)/tms9900/tms9995.o:	$(CPUSRC)/tms9900/tms9995.c \
-								$(CPUSRC)/tms9900/tms9900.h
+								$(CPUSRC)/tms9900/tms9995.h
 
 $(CPUOBJ)/tms9900/tms9995l.o:	$(CPUSRC)/tms9900/tms9995l.c \
 								$(CPUSRC)/tms9900/tms9900l.h \
diff -Nru src-old/emu/cpu/mcs51/mcs51.c src/emu/cpu/mcs51/mcs51.c
--- src-old/emu/cpu/mcs51/mcs51.c	2012-05-29 08:44:54.000000000 +0200
+++ src/emu/cpu/mcs51/mcs51.c	2012-06-23 21:41:04.000000000 +0200
@@ -1203,13 +1203,15 @@
 
 INLINE void update_timers(mcs51_state_t *mcs51_state, int cycles)
 {
-	/* Update Timer 0 */
-	update_timer_t0(mcs51_state, cycles);
-	update_timer_t1(mcs51_state, cycles);
-
-	if (mcs51_state->features & FEATURE_I8052)
+	while (cycles--)
 	{
-		update_timer_t2(mcs51_state, cycles);
+		update_timer_t0(mcs51_state, 1);
+		update_timer_t1(mcs51_state, 1);
+
+		if (mcs51_state->features & FEATURE_I8052)
+		{
+			update_timer_t2(mcs51_state, 1);
+		}
 	}
 }
 
diff -Nru src-old/emu/cpu/tms32031/32031ops.c src/emu/cpu/tms32031/32031ops.c
--- src-old/emu/cpu/tms32031/32031ops.c	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/cpu/tms32031/32031ops.c	2012-06-17 00:56:46.000000000 +0200
@@ -743,9 +743,11 @@
 	// check for underflow
 	if (exp <= -128)
 	{
+		// make sure a 0 result doesn't set underflow
+		if (man != 0 || exp < -128)
+			IREG(TMR_ST) |= UFFLAG | LUFFLAG;
 		man = 0x80000000;
 		exp = -128;
-		IREG(TMR_ST) |= UFFLAG | LUFFLAG;
 	}
 
 	// check for overflow
@@ -1895,31 +1897,35 @@
 void tms3203x_device::fix_reg(UINT32 op)
 {
 	int dreg = (op >> 16) & 31;
-	m_r[dreg] = m_r[op & 7];
-	float2int(m_r[dreg], dreg < 8);
+	m_r[TMR_TEMP1] = m_r[op & 7];
+	float2int(m_r[TMR_TEMP1], dreg < 8);
+	m_r[dreg].set_mantissa(m_r[TMR_TEMP1].mantissa());
 }
 
 void tms3203x_device::fix_dir(UINT32 op)
 {
 	UINT32 res = RMEM(DIRECT(op));
 	int dreg = (op >> 16) & 31;
-	LONG2FP(dreg, res);
-	float2int(m_r[dreg], dreg < 8);
+	LONG2FP(TMR_TEMP1, res);
+	float2int(m_r[TMR_TEMP1], dreg < 8);
+	m_r[dreg].set_mantissa(m_r[TMR_TEMP1].mantissa());
 }
 
 void tms3203x_device::fix_ind(UINT32 op)
 {
 	UINT32 res = RMEM(INDIRECT_D(op, op >> 8));
 	int dreg = (op >> 16) & 31;
-	LONG2FP(dreg, res);
-	float2int(m_r[dreg], dreg < 8);
+	LONG2FP(TMR_TEMP1, res);
+	float2int(m_r[TMR_TEMP1], dreg < 8);
+	m_r[dreg].set_mantissa(m_r[TMR_TEMP1].mantissa());
 }
 
 void tms3203x_device::fix_imm(UINT32 op)
 {
 	int dreg = (op >> 16) & 31;
-	SHORT2FP(dreg, op);
-	float2int(m_r[dreg], dreg < 8);
+	SHORT2FP(TMR_TEMP1, op);
+	float2int(m_r[TMR_TEMP1], dreg < 8);
+	m_r[dreg].set_mantissa(m_r[TMR_TEMP1].mantissa());
 }
 
 /*-----------------------------------------------------*/
diff -Nru src-old/emu/cpu/tms9900/tms9900.c src/emu/cpu/tms9900/tms9900.c
--- src-old/emu/cpu/tms9900/tms9900.c	2012-06-08 19:28:13.000000000 +0200
+++ src/emu/cpu/tms9900/tms9900.c	2012-06-28 19:29:44.000000000 +0200
@@ -117,25 +117,36 @@
 	ST_IM = 0x000f		// Interrupt mask
 };
 
-enum
-{
-	LOAD_INT = -1,
-	RESET_INT = -2
-};
-
 #define LOG logerror
 #define VERBOSE 1
 
 /****************************************************************************
-    Constructor
+    Common constructor for TMS9900 and TMS9980A
+    The CRU mask is related to the bits, not to their addresses which are
+    twice their number. Accordingly, the TMS9900 has a CRU bitmask 0x0fff.
 ****************************************************************************/
 
-tms9900_device::tms9900_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
-	: cpu_device(mconfig, TMS9900, "TMS9900", tag, owner, clock),
-	  m_program_config("program", ENDIANNESS_BIG, 16, 16),
-	  m_io_config("cru", ENDIANNESS_BIG, 8, 16),
+tms99xx_device::tms99xx_device(const machine_config &mconfig, device_type type,  const char *name, const char *tag, int databus_width, int prg_addr_bits, int cru_addr_bits, device_t *owner, UINT32 clock)
+	: cpu_device(mconfig, type, name, tag, owner, clock),
+	  m_program_config("program", ENDIANNESS_BIG, databus_width, prg_addr_bits),
+	  m_io_config("cru", ENDIANNESS_BIG, 8, cru_addr_bits),
 	  m_prgspace(NULL),
-	  m_cru(NULL)
+	  m_cru(NULL),
+	  m_prgaddr_mask((1<<prg_addr_bits)-1),
+	  m_cruaddr_mask((1<<cru_addr_bits)-1)
+{
+}
+
+tms99xx_device::~tms99xx_device()
+{
+}
+
+/****************************************************************************
+    Constructor for TMS9900
+****************************************************************************/
+
+tms9900_device::tms9900_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: tms99xx_device(mconfig, TMS9900, "TMS9900", tag, 16, 16, 12, owner, clock)
 {
 }
 
@@ -148,9 +159,9 @@
 	TMS9900_R12, TMS9900_R13, TMS9900_R14, TMS9900_R15
 };
 
-void tms9900_device::device_start()
+void tms99xx_device::device_start()
 {
-	const tms9900_config *conf = reinterpret_cast<const tms9900_config *>(static_config());
+	const tms99xx_config *conf = reinterpret_cast<const tms99xx_config *>(static_config());
 
 	assert (conf != NULL);
 
@@ -161,7 +172,7 @@
 
 	// Resolve our external connections
 	m_external_operation.resolve(conf->external_callback, *this);
-	m_get_ic0123.resolve(conf->irq_level, *this);
+	m_get_intlevel.resolve(conf->irq_level, *this);
 	m_iaq_line.resolve(conf->instruction_acquisition, *this);
 	m_clock_out_line.resolve(conf->clock_out, *this);
 	m_wait_line.resolve(conf->wait_line, *this);
@@ -181,12 +192,14 @@
 	state_add(STATE_GENFLAGS, "status", m_state_any).callimport().callexport().formatstr("%16s").noshow();
 
 	build_command_lookup_table();
+
+	m_program = NULL;
 }
 
-void tms9900_device::device_stop()
+void tms99xx_device::device_stop()
 {
 	int k = 0;
-	if (VERBOSE>8) LOG("tms9900: Deleting lookup tables\n");
+	if (VERBOSE>8) LOG("tms99xx: Deleting lookup tables\n");
 	while (m_lotables[k]!=NULL) delete[] m_lotables[k++];
 }
 
@@ -195,12 +208,13 @@
     The device reset is just the emulator's trigger for the reset procedure
     which is invoked via the main loop.
 */
-void tms9900_device::device_reset()
+void tms99xx_device::device_reset()
 {
+	if (VERBOSE>3) LOG("tms99xx: Device reset\n");
 	m_reset = true;
 }
 
-const char* tms9900_device::s_statename[20] =
+const char* tms99xx_device::s_statename[20] =
 {
 	"PC ", "WP ", "ST ", "IR ",
 	"R0 ", "R1 ", "R2 ", "R3 ",
@@ -212,7 +226,7 @@
 /*
     Write the contents of a register by external input (debugger)
 */
-void tms9900_device::state_import(const device_state_entry &entry)
+void tms99xx_device::state_import(const device_state_entry &entry)
 {
 	int index = entry.index();
 	switch (entry.index())
@@ -222,10 +236,10 @@
 			// bits of the STATUS register
 			break;
 		case TMS9900_PC:
-			PC = (UINT16)m_state_any;
+			PC = (UINT16)(m_state_any & m_prgaddr_mask);
 			break;
 		case TMS9900_WP:
-			WP = (UINT16)m_state_any;
+			WP = (UINT16)(m_state_any & m_prgaddr_mask);
 			break;
 		case TMS9900_STATUS:
 			ST = (UINT16)m_state_any;
@@ -244,7 +258,7 @@
 /*
     Reads the contents of a register for display in the debugger.
 */
-void tms9900_device::state_export(const device_state_entry &entry)
+void tms99xx_device::state_export(const device_state_entry &entry)
 {
 	int index = entry.index();
 	switch (entry.index())
@@ -275,7 +289,7 @@
 /*
     state_string_export - export state as a string for the debugger
 */
-void tms9900_device::state_string_export(const device_state_entry &entry, astring &string)
+void tms99xx_device::state_string_export(const device_state_entry &entry, astring &string)
 {
 	static const char *statestr = "LAECOPX-----IIII";
 	char *flags = string.stringbuffer(16);
@@ -292,22 +306,22 @@
 
 /**************************************************************************/
 
-UINT16 tms9900_device::read_workspace_register_debug(int reg)
+UINT16 tms99xx_device::read_workspace_register_debug(int reg)
 {
 	int temp = m_icount;
-	UINT16 value = m_prgspace->read_word((WP+(reg<<1)) & 0xfffe);
+	UINT16 value = m_prgspace->read_word((WP+(reg<<1)) & m_prgaddr_mask & 0xfffe);
 	m_icount = temp;
 	return value;
 }
 
-void tms9900_device::write_workspace_register_debug(int reg, UINT16 data)
+void tms99xx_device::write_workspace_register_debug(int reg, UINT16 data)
 {
 	int temp = m_icount;
-	m_prgspace->write_word((WP+(reg<<1)) & 0xfffe, data);
+	m_prgspace->write_word((WP+(reg<<1)) & m_prgaddr_mask & 0xfffe, data);
 	m_icount = temp;
 }
 
-const address_space_config *tms9900_device::memory_space_config(address_spacenum spacenum) const
+const address_space_config *tms99xx_device::memory_space_config(address_spacenum spacenum) const
 {
 	switch (spacenum)
 	{
@@ -342,47 +356,49 @@
 	MEMORY_WRITE,
 	REG_READ,
 	REG_WRITE,
-	CRU,				// 5
+	CRU_INPUT,
+	CRU_OUTPUT,
 	DATA_DERIVE,
 	RET,
+	ABORT,
 	END,
+
 	ALU_NOP,
-	ALU_CLR,			// 10
+	ALU_CLR,
 	ALU_SETADDR,
 	ALU_ADDONE,
 	ALU_SETADDR_ADDONE,
 	ALU_PCADDR_ADVANCE,
-	ALU_SOURCE,			// 15
+	ALU_SOURCE,
 	ALU_ADDREG,
 	ALU_IMM,
 	ALU_REG,
 	ALU_F1,
-	ALU_COMP,			// 20
+	ALU_COMP,
 	ALU_F3,
 	ALU_MPY,
 	ALU_DIV,
 	ALU_XOP,
-	ALU_CLR_SWPB,		// 25
+	ALU_CLR_SWPB,
 	ALU_ABS,
 	ALU_X,
 	ALU_B,
-	ALU_BL,
-	ALU_BLWP,			// 30
+	ALU_BLWP,
 	ALU_LDCR,
 	ALU_STCR,
 	ALU_SBZ_SBO,
 	ALU_TB,
-	ALU_JMP,			// 35
+	ALU_JMP,
 	ALU_SHIFT,
 	ALU_AI_ORI,
 	ALU_CI,
 	ALU_LI,
-	ALU_LWPI,			// 40
+	ALU_LWPI,
 	ALU_LIMI,
 	ALU_STWP_STST,
 	ALU_EXT,
 	ALU_RTWP,
-	ALU_INT				// 45
+	ALU_INT
 };
 
 
@@ -436,7 +452,7 @@
 	ALU_NOP,
 	DATA_DERIVE,
 	ALU_F3,
-	REG_READ,		// We have to distinguish this from the C/CB microprogram above
+	MEMORY_READ,	// We have to distinguish this from the C/CB microprogram above
 	ALU_F3,
 	ALU_NOP,		// Compare operations do not write back any data
 	END
@@ -447,9 +463,9 @@
 	ALU_NOP,
 	DATA_DERIVE,
 	ALU_F3,
-	REG_READ,
+	MEMORY_READ,
 	ALU_F3,
-	MEMORY_WRITE,	// XOR again must write back data
+	MEMORY_WRITE,	// XOR again must write back data, cannot reuse f3_mp
 	END
 };
 
@@ -458,9 +474,9 @@
 	ALU_NOP,
 	DATA_DERIVE,
 	ALU_MPY,		// Save the value; put register number in m_regnumber
-	REG_READ,
+	MEMORY_READ,
 	ALU_MPY,		// 18 cycles for multiplication
-	REG_WRITE,		// Write the high word
+	MEMORY_WRITE,		// Write the high word
 	ALU_MPY,		// Get low word, increase m_address
 	MEMORY_WRITE,
 	END
@@ -471,11 +487,12 @@
 	ALU_NOP,
 	DATA_DERIVE,	// Get divisor
 	ALU_DIV,		// 0 Store divisor and get register number
-	REG_READ,		// Read register
+	MEMORY_READ,	// Read register
 	ALU_DIV,		// 1 Check overflow, increase address (or abort here)
+	ABORT,
 	MEMORY_READ,	// Read subsequent word (if reg=15 this is behind the workspace)
 	ALU_DIV,		// 2 Calculate quotient (takes variable amount of cycles; at least 32 machine cycles), set register number
-	REG_WRITE,		// Write quotient into register
+	MEMORY_WRITE,	// Write quotient into register
 	ALU_DIV,		// 3 Get remainder
 	MEMORY_WRITE,	// Write remainder
 	END
@@ -488,13 +505,13 @@
 	ALU_XOP,		// 0 Save the address of the source operand, set address = 0x0040 + xopNr*4
 	MEMORY_READ,	// Read the new WP
 	ALU_XOP,		// 1 Save old WP, set new WP, get the source operand address
-	REG_WRITE,		// Write the address of the source operand into the new R11
+	MEMORY_WRITE,	// Write the address of the source operand into the new R11
 	ALU_XOP,		// 2
-	REG_WRITE,		// Write the ST into the new R15
+	MEMORY_WRITE,	// Write the ST into the new R15
 	ALU_XOP,		// 3
-	REG_WRITE,		// Write the PC into the new R14
+	MEMORY_WRITE,	// Write the PC into the new R14
 	ALU_XOP,		// 4
-	REG_WRITE,		// Write the WP into the new R13
+	MEMORY_WRITE,	// Write the WP into the new R13
 	ALU_XOP,		// 5 Set the X bit in the ST
 	MEMORY_READ,	// Read the new PC
 	ALU_XOP,		// 6 Set the new PC
@@ -541,8 +558,9 @@
 {
 	ALU_NOP,
 	DATA_DERIVE,
-	ALU_BL,				// two cycles
-	REG_WRITE,
+	ALU_B,
+	MEMORY_WRITE,
+	ALU_NOP,
 	END
 };
 
@@ -551,11 +569,11 @@
 	ALU_NOP,
 	DATA_DERIVE,			// Get argument
 	ALU_BLWP,				// 0 Save old WP, set new WP, save position
-	REG_WRITE,				// write ST to R15
+	MEMORY_WRITE,			// write ST to R15
 	ALU_BLWP,				// 1
-	REG_WRITE,				// write PC to R14
+	MEMORY_WRITE,			// write PC to R14
 	ALU_BLWP,				// 2
-	REG_WRITE,				// write WP to R13
+	MEMORY_WRITE,			// write WP to R13
 	ALU_BLWP,				// 3 Get saved position
 	MEMORY_READ,			// Read new PC
 	ALU_BLWP,				// 4 Set new PC
@@ -569,9 +587,9 @@
 	ALU_SOURCE,
 	ALU_NOP,
 	ALU_LDCR,
-	REG_READ,
+	MEMORY_READ,
 	ALU_LDCR,
-	CRU,
+	CRU_OUTPUT,
 	ALU_NOP,
 	END
 };
@@ -582,9 +600,9 @@
 	DATA_DERIVE,
 	ALU_SOURCE,			// Store address and value
 	ALU_STCR,			// 0 Set register_number = 12
-	REG_READ,
+	MEMORY_READ,
 	ALU_STCR,			// 1 Prepare CRU access
-	CRU,
+	CRU_INPUT,
 	ALU_STCR,			// 2 Create result; Cycles = 5 + (8-#C-1) or + (16-#C)
 	MEMORY_WRITE,
 	END
@@ -593,18 +611,18 @@
 MICROPROGRAM(sbz_sbo_mp)
 {
 	ALU_SBZ_SBO,
-	REG_READ,
+	MEMORY_READ,
 	ALU_SBZ_SBO,
-	CRU,
+	CRU_OUTPUT,
 	END
 };
 
 MICROPROGRAM(tb_mp)
 {
 	ALU_TB,
-	REG_READ,
+	MEMORY_READ,
 	ALU_TB,
-	CRU,
+	CRU_INPUT,
 	ALU_TB,
 	END
 };
@@ -621,29 +639,29 @@
 MICROPROGRAM(shift_mp)
 {
 	ALU_SHIFT,
-	REG_READ,
+	MEMORY_READ,
 	ALU_SHIFT,
-	REG_READ,
+	MEMORY_READ,
 	ALU_SHIFT,
-	REG_WRITE,
+	MEMORY_WRITE,
 	END
 };
 
 MICROPROGRAM(ai_ori_mp)
 {
 	ALU_REG,
-	REG_READ,
+	MEMORY_READ,
 	ALU_IMM,
 	MEMORY_READ,
 	ALU_AI_ORI,
-	REG_WRITE,
+	MEMORY_WRITE,
 	END
 };
 
 MICROPROGRAM(ci_mp)
 {
 	ALU_REG,
-	REG_READ,
+	MEMORY_READ,
 	ALU_IMM,
 	MEMORY_READ,
 	ALU_CI,
@@ -657,7 +675,7 @@
 	MEMORY_READ,
 	ALU_LI,				// sets status bits
 	ALU_REG,			// set register number
-	REG_WRITE,
+	MEMORY_WRITE,
 	END
 };
 
@@ -685,7 +703,7 @@
 {
 	ALU_STWP_STST,
 	ALU_REG,
-	REG_WRITE,
+	MEMORY_WRITE,
 	END
 };
 
@@ -698,11 +716,11 @@
 MICROPROGRAM(rtwp_mp)		// Problem: This makes RTWP use 8 instead of 7 machine cycles.
 {
 	ALU_RTWP,
-	REG_READ,
+	MEMORY_READ,
 	ALU_RTWP,
-	REG_READ,
+	MEMORY_READ,
 	ALU_RTWP,
-	REG_READ,
+	MEMORY_READ,
 	ALU_RTWP,
 	END
 };
@@ -713,67 +731,68 @@
 	ALU_INT,				// 0 Set address = 0
 	MEMORY_READ,
 	ALU_INT,				// 1 Save old WP, set new WP, save position
-	REG_WRITE,				// write ST to R15
+	MEMORY_WRITE,			// write ST to R15
 	ALU_INT,				// 2
-	REG_WRITE,				// write PC to R14
+	MEMORY_WRITE,			// write PC to R14
 	ALU_INT,				// 3
-	REG_WRITE,				// write WP to R13
+	MEMORY_WRITE,			// write WP to R13
 	ALU_INT,				// 4 Get saved position
 	MEMORY_READ,			// Read new PC
 	ALU_INT,				// 5 Set new PC
 	END
 };
 
-const tms9900_device::ophandler tms9900_device::s_microoperation[] =
+const tms99xx_device::ophandler tms99xx_device::s_microoperation[] =
 {
-	&tms9900_device::acquire_instruction,
-	&tms9900_device::mem_read,
-	&tms9900_device::mem_write,
-	&tms9900_device::register_read,
-	&tms9900_device::register_write,
-	&tms9900_device::cru_operation,
-	&tms9900_device::data_derivation_subprogram,
-	&tms9900_device::return_from_subprogram,
-	&tms9900_device::command_completed,
-
-	&tms9900_device::alu_nop,
-	&tms9900_device::alu_clear,
-	&tms9900_device::alu_setaddr,
-	&tms9900_device::alu_addone,
-	&tms9900_device::alu_setaddr_addone,
-	&tms9900_device::alu_pcaddr_advance,
-	&tms9900_device::alu_source,
-	&tms9900_device::alu_add_register,
-	&tms9900_device::alu_imm,
-	&tms9900_device::alu_reg,
-
-	&tms9900_device::alu_f1,
-	&tms9900_device::alu_comp,
-	&tms9900_device::alu_f3,
-	&tms9900_device::alu_multiply,
-	&tms9900_device::alu_divide,
-	&tms9900_device::alu_xop,
-	&tms9900_device::alu_clr_swpb,
-	&tms9900_device::alu_abs,
-	&tms9900_device::alu_x,
-	&tms9900_device::alu_b,
-	&tms9900_device::alu_bl,
-	&tms9900_device::alu_blwp,
-	&tms9900_device::alu_ldcr,
-	&tms9900_device::alu_stcr,
-	&tms9900_device::alu_sbz_sbo,
-	&tms9900_device::alu_tb,
-	&tms9900_device::alu_jmp,
-	&tms9900_device::alu_shift,
-	&tms9900_device::alu_ai_ori,
-	&tms9900_device::alu_ci,
-	&tms9900_device::alu_li,
-	&tms9900_device::alu_lwpi,
-	&tms9900_device::alu_limi,
-	&tms9900_device::alu_stwp_stst,
-	&tms9900_device::alu_external,
-	&tms9900_device::alu_rtwp,
-	&tms9900_device::alu_int
+	&tms99xx_device::acquire_instruction,
+	&tms99xx_device::mem_read,
+	&tms99xx_device::mem_write,
+	&tms99xx_device::register_read,
+	&tms99xx_device::register_write,
+	&tms99xx_device::cru_input_operation,
+	&tms99xx_device::cru_output_operation,
+	&tms99xx_device::data_derivation_subprogram,
+	&tms99xx_device::return_from_subprogram,
+	&tms99xx_device::abort_operation,
+	&tms99xx_device::command_completed,
+
+	&tms99xx_device::alu_nop,
+	&tms99xx_device::alu_clear,
+	&tms99xx_device::alu_setaddr,
+	&tms99xx_device::alu_addone,
+	&tms99xx_device::alu_setaddr_addone,
+	&tms99xx_device::alu_pcaddr_advance,
+	&tms99xx_device::alu_source,
+	&tms99xx_device::alu_add_register,
+	&tms99xx_device::alu_imm,
+	&tms99xx_device::alu_reg,
+
+	&tms99xx_device::alu_f1,
+	&tms99xx_device::alu_comp,
+	&tms99xx_device::alu_f3,
+	&tms99xx_device::alu_multiply,
+	&tms99xx_device::alu_divide,
+	&tms99xx_device::alu_xop,
+	&tms99xx_device::alu_clr_swpb,
+	&tms99xx_device::alu_abs,
+	&tms99xx_device::alu_x,
+	&tms99xx_device::alu_b,
+	&tms99xx_device::alu_blwp,
+	&tms99xx_device::alu_ldcr,
+	&tms99xx_device::alu_stcr,
+	&tms99xx_device::alu_sbz_sbo,
+	&tms99xx_device::alu_tb,
+	&tms99xx_device::alu_jmp,
+	&tms99xx_device::alu_shift,
+	&tms99xx_device::alu_ai_ori,
+	&tms99xx_device::alu_ci,
+	&tms99xx_device::alu_li,
+	&tms99xx_device::alu_lwpi,
+	&tms99xx_device::alu_limi,
+	&tms99xx_device::alu_stwp_stst,
+	&tms99xx_device::alu_external,
+	&tms99xx_device::alu_rtwp,
+	&tms99xx_device::alu_int
 };
 
 /*****************************************************************************
@@ -791,17 +810,8 @@
 	JLT, JMP, JNC, JNE, JNO, JOC, JOP, LDCR, LI, LIMI,
 	LREX, LWPI, MOV, MOVB, MPY, NEG, ORI, RSET, RTWP, S,
 	SB, SBO, SBZ, SETO, SLA, SOC, SOCB, SRA, SRC, SRL,
-	STCR, STST, STWP, SWPB, SZC, SZCB, TB, X, XOP, XOR
-};
-
-static const char opname[][5] =
-{   "ILL ", "A   ", "AB  ", "ABS ", "AI  ", "ANDI", "B   ", "BL  ", "BLWP", "C   ",
-	"CI  ", "CB  ", "CKOF", "CKON", "CLR ", "COC ", "CZC ", "DEC ", "DECT", "DIV ",
-	"IDLE", "INC ", "INCT", "INV ", "JEQ ", "JGT ", "JH  ", "JHE ", "JL  ", "JLE ",
-	"JLT ", "JMP ", "JNC ", "JNE ", "JNO ", "JOC ", "JOP ", "LDCR", "LI  ", "LIMI",
-	"LREX", "LWPI", "MOV ", "MOVB", "MPY ", "NEG ", "ORI ", "RSET",	"RTWP", "S   ",
-	"SB  ", "SBO ", "SBZ ", "SETO", "SLA ", "SOC ", "SOCB", "SRA ", "SRC ", "SRL ",
-	"STCR", "STST", "STWP", "SWPB", "SZC ", "SZCB", "TB  ", "X   ", "XOP ", "XOR "
+	STCR, STST, STWP, SWPB, SZC, SZCB, TB, X, XOP, XOR,
+	INTR
 };
 
 /*
@@ -838,7 +848,7 @@
 	0, 4, 8, 6, 6, 8, 10, 16, 12, 6
 };
 
-const tms9900_device::tms_instruction tms9900_device::s_command[] =
+const tms99xx_device::tms_instruction tms99xx_device::s_command[] =
 {
 	// Opcode, ID, format, microprg
 	{ 0x0200, LI, 8, li_mp },
@@ -947,7 +957,7 @@
     list at runtime, and many positions are empty. But we do not need more
     than 20 tables for the TMS command set.
 */
-void tms9900_device::build_command_lookup_table()
+void tms99xx_device::build_command_lookup_table()
 {
 	int i = 0;
 	int cmdindex = 0;
@@ -972,7 +982,7 @@
 	{
 		inst = &s_command[i];
 		table = m_command_lookup_table;
-		if (VERBOSE>8) LOG("tms9900: === opcode=%04x, len=%d\n", inst->opcode, format_mask_len[inst->format]);
+		if (VERBOSE>8) LOG("tms99xx: === opcode=%04x, len=%d\n", inst->opcode, format_mask_len[inst->format]);
 		bitcount = 4;
 		opcode = inst->opcode;
 		cmdindex = (opcode>>12) & 0x000f;
@@ -982,7 +992,7 @@
 			// Descend
 			if (table[cmdindex].next_digit == NULL)
 			{
-				if (VERBOSE>8) LOG("tms9900: create new table at bitcount=%d for index=%d\n", bitcount, cmdindex);
+				if (VERBOSE>8) LOG("tms99xx: create new table at bitcount=%d for index=%d\n", bitcount, cmdindex);
 				table[cmdindex].next_digit = new lookup_entry[16];
 				m_lotables[k++] = table[cmdindex].next_digit;
 				for (int j=0; j < 16; j++)
@@ -993,7 +1003,7 @@
 			}
 			else
 			{
-				if (VERBOSE>8) LOG("tms9900: found a table at bitcount=%d\n", bitcount);
+				if (VERBOSE>8) LOG("tms99xx: found a table at bitcount=%d\n", bitcount);
 			}
 
 			table = table[cmdindex].next_digit;
@@ -1001,17 +1011,17 @@
 			bitcount = bitcount+4;
 			opcode <<= 4;
 			cmdindex = (opcode>>12) & 0x000f;
-			if (VERBOSE>8) LOG("tms9900: next index=%x\n", cmdindex);
+			if (VERBOSE>8) LOG("tms99xx: next index=%x\n", cmdindex);
 		}
 
-		if (VERBOSE>8) LOG("tms9900: bitcount=%d\n", bitcount);
+		if (VERBOSE>8) LOG("tms99xx: bitcount=%d\n", bitcount);
 		// We are at the target level
 		// Need to fill in the same entry for all values in the bitcount
 		// (if a command needs 10 bits we have to copy it four
 		// times for all combinations with 12 bits)
 		for (int j=0; j < (1<<(bitcount-format_mask_len[inst->format])); j++)
 		{
-			if (VERBOSE>8) LOG("tms9900: opcode=%04x at position %d\n", inst->opcode, cmdindex+j);
+			if (VERBOSE>8) LOG("tms99xx: opcode=%04x at position %d\n", inst->opcode, cmdindex+j);
 			table[cmdindex+j].entry = inst;
 		}
 
@@ -1019,7 +1029,7 @@
 	} while (inst->opcode != 0xf000);
 
 	m_lotables[k++] = NULL;
-	if (VERBOSE>8) LOG("tms9900: Allocated %d tables\n", k);
+	if (VERBOSE>8) LOG("tms99xx: Allocated %d tables\n", k);
 }
 
 /*
@@ -1058,11 +1068,11 @@
     the CPU checks the READY line and waits until it is high. When READY
     is high at a clock tick, the operation is complete on the next clock tick.
 */
-void tms9900_device::execute_run()
+void tms99xx_device::execute_run()
 {
 	if (m_reset) service_interrupt();
 
-	if (VERBOSE>6) LOG("tms9900: calling execute_run for %d cycles\n", m_icount);
+	if (VERBOSE>6) LOG("tms99xx: calling execute_run for %d cycles\n", m_icount);
 	do
 	{
 		// Only when last instruction has completed
@@ -1070,7 +1080,9 @@
 		{
 			if (m_load_state)
 			{
-				if (VERBOSE>4) LOG("tms9900: load interrupt\n");
+				if (VERBOSE>4) LOG("tms99xx: LOAD interrupt\n");
+				m_irq_level = LOAD_INT;
+				m_irq_state = false;
 				service_interrupt();
 			}
 			else
@@ -1086,8 +1098,10 @@
 
 		if (m_program == NULL && m_idle_state)
 		{
-			if (VERBOSE>5) LOG("tms9900: idle state\n");
+			if (VERBOSE>5) LOG("tms99xx: idle state\n");
 			pulse_clock(1);
+			m_external_operation(IDLE_OP, 0);
+			m_external_operation(IDLE_OP, 1);
 		}
 		else
 		{
@@ -1100,7 +1114,7 @@
 				m_program[MPC] != MEMORY_READ && m_program[MPC] != MEMORY_WRITE &&
 				m_program[MPC] != REG_READ && m_program[MPC] != REG_WRITE)))
 			{
-				if (VERBOSE>5) LOG("tms9900: hold state\n");
+				if (VERBOSE>5) LOG("tms99xx: hold state\n");
 				if (!m_hold_acknowledged) acknowledge_hold();
 				pulse_clock(1);
 			}
@@ -1111,7 +1125,7 @@
 				{
 					// We are in a wait state
 					set_wait_state(true);
-					if (VERBOSE>5) LOG("tms9900: wait state\n");
+					if (VERBOSE>5) LOG("tms99xx: wait state\n");
 					// The clock output should be used to change the state of an outer
 					// device which operates the READY line
 					pulse_clock(1);
@@ -1125,17 +1139,23 @@
 					else
 					{
 						m_op = m_program[MPC];
-						m_iaq_line(CLEAR_LINE);
 					}
-					if (VERBOSE>8) LOG("tms9900: MPC = %d, m_op = %d\n", MPC, m_op);
+					if (VERBOSE>8) LOG("tms99xx: MPC = %d, m_op = %d\n", MPC, m_op);
 					// Call the operation of the microprogram
 					(this->*s_microoperation[m_op])();
-					MPC++;
+					// If we have multiple passes (as in the TMS9980)
+					m_pass--;
+					if (m_pass<=0)
+					{
+						m_pass = 1;
+						MPC++;
+						m_iaq_line(CLEAR_LINE);
+					}
 				}
 			}
 		}
 	} while (m_icount>0);
-	if (VERBOSE>6) LOG("tms9900: cycles expired; will return soon.\n");
+	if (VERBOSE>6) LOG("tms99xx: cycles expired; will return soon.\n");
 }
 
 /**************************************************************************/
@@ -1143,7 +1163,7 @@
 /*
     Interrupt input
 */
-void tms9900_device::execute_set_input(int irqline, int state)
+void tms99xx_device::execute_set_input(int irqline, int state)
 {
 	if (irqline == INPUT_LINE_NMI)
 	{
@@ -1155,25 +1175,43 @@
 		m_irq_state = (state==ASSERT_LINE);
 		if (state==ASSERT_LINE)
 		{
-			m_irq_level = m_get_ic0123(0);
-			if (VERBOSE>6) LOG("tms9900: interrupt line %d = %d, level=%d, ST=%04x\n", irqline, state, m_irq_level, ST);
+			m_irq_level = get_intlevel(state);
+			if (VERBOSE>6) LOG("tms99xx: interrupt line %d = %d, level=%d, ST=%04x\n", irqline, state, m_irq_level, ST);
 		}
 		else
 		{
-			if (VERBOSE>6) LOG("tms9900: cleared interrupt line %d\n", irqline);
+			if (VERBOSE>6) LOG("tms99xx: cleared interrupt line %d\n", irqline);
 		}
 	}
 }
 
-void tms9900_device::service_interrupt()
+/*
+    This can be overloaded by variants of TMS99xx.
+*/
+int tms99xx_device::get_intlevel(int state)
+{
+	return m_get_intlevel(0);
+}
+
+void tms99xx_device::service_interrupt()
 {
 	m_program = int_mp;
-	MPC = 0;
+	m_command = INTR;
 	m_idle_state = false;
-	m_first_cycle = m_icount;
+	m_external_operation(IDLE_OP, 0);
+	m_lowbyte = false;
+
 	m_state = 0;
+
+	// If reset, we just start with execution, otherwise we put the MPC
+	// on the first microinstruction, which also means that the main loop shall
+	// leave it where it is. So we pretend we have another pass to do.
+	m_pass = m_reset? 1 : 2;
+
 	if (m_reset)
 	{
+		m_irq_level = RESET_INT;
+
 		m_ready_state = true;
 		m_load_state = false;
 		m_hold_state = false;
@@ -1183,29 +1221,31 @@
 		ST = 0;
 
 		m_reset = false;
-		m_irq_level = RESET_INT;
 	}
-	if (VERBOSE>6) LOG("tms9900: ********* triggered an interrupt on level %d\n", m_irq_level);
+	if (VERBOSE>6) LOG("tms99xx: ********* triggered an interrupt on level %d\n", m_irq_level);
+
+	MPC = 0;
+	m_first_cycle = m_icount;
 }
 
 /*
     Issue a pulse on the clock line.
 */
-inline void tms9900_device::pulse_clock(int count)
+void tms99xx_device::pulse_clock(int count)
 {
 	for (int i=0; i < count; i++)
 	{
 		m_clock_out_line(ASSERT_LINE);
 		m_clock_out_line(CLEAR_LINE);
 		m_icount--;							// This is the only location where we count down the cycles.
-		if (VERBOSE>7) LOG("tms9900: pulse_clock\n");
+		if (VERBOSE>7) LOG("tms99xx: pulse_clock\n");
 	}
 }
 
 /*
     Enter the hold state.
 */
-void tms9900_device::set_hold(int state)
+void tms99xx_device::set_hold(int state)
 {
 	m_hold_state = (state==ASSERT_LINE);
 	if (!m_hold_state)
@@ -1218,7 +1258,7 @@
 /*
     Acknowledge the HOLD request.
 */
-inline void tms9900_device::acknowledge_hold()
+inline void tms99xx_device::acknowledge_hold()
 {
 	m_hold_acknowledged = true;
 	m_holda_line(ASSERT_LINE);
@@ -1227,12 +1267,12 @@
 /*
     Signal READY to the CPU. When cleared, the CPU enters wait states.
 */
-void tms9900_device::set_ready(int state)
+void tms99xx_device::set_ready(int state)
 {
 	m_ready_state = (state==ASSERT_LINE);
 }
 
-void tms9900_device::abort_operation()
+void tms99xx_device::abort_operation()
 {
 	command_completed();
 }
@@ -1240,52 +1280,17 @@
 /*
     Enter or leave the wait state. We only operate the WAIT line when there is a change.
 */
-inline void tms9900_device::set_wait_state(bool state)
+inline void tms99xx_device::set_wait_state(bool state)
 {
 	if (m_wait_state != state) m_wait_line(state? ASSERT_LINE : CLEAR_LINE);
 	m_wait_state = state;
 }
 
 /*
-    Memory read:
-    1) Pulse clock (done above)
-    2) Set address (we also get the value right here)
-    3) Pulse clock
-    4) If READY=L (WAIT=H, GOTO 3) else (WAIT=L, STOP)
-
-    Clock cycles: 2 + W, W = number of wait states
-*/
-UINT16 tms9900_device::pulse_and_read_memory(UINT16 address)
-{
-	UINT16 value;
-	value = m_prgspace->read_word(address & 0xfffe);
-	pulse_clock(2);
-	m_check_ready = true;
-	return value;
-}
-
-/*
-    Memory write:
-    1) Pulse clock
-    2) Set address and write (as in the real system)
-    3) Pulse clock
-    4) If READY=L (WAIT=H, GOTO 3) else (WAIT=L, STOP)
-
-    Clock cycles: 2 + W, W = number of wait states
-*/
-void tms9900_device::pulse_and_write_memory(UINT16 address, UINT16 data)
-{
-	m_prgspace->write_word(address & 0xfffe, data);
-	pulse_clock(2);
-	m_check_ready = true;
-}
-
-
-/*
     Acquire the next word as an instruction. The program counter advances by
     one word.
 */
-void tms9900_device::decode(UINT16 inst)
+void tms99xx_device::decode(UINT16 inst)
 {
 	int index = 0;
 	lookup_entry* table = m_command_lookup_table;
@@ -1300,7 +1305,7 @@
 	while (!complete)
 	{
 		index = (opcode >> 12) & 0x000f;
-		if (VERBOSE>8) LOG("tms9900: Check next hex digit of instruction %x\n", index);
+		if (VERBOSE>8) LOG("tms99xx: Check next hex digit of instruction %x\n", index);
 		if (table[index].next_digit != NULL)
 		{
 			table = table[index].next_digit;
@@ -1312,10 +1317,10 @@
 	if (decoded == NULL)
 	{
 		// not found
-		if (VERBOSE>0) LOG("tms9900: Illegal opcode %04x\n", inst);
+		if (VERBOSE>0) LOG("tms99xx: Illegal opcode %04x\n", inst);
 		IR = 0;
 		// This will cause another instruction acquisition in the next machine cycle
-		// with an asserted IAQ line (can be used to detect this illegal opcode detection).
+		// with an asserted IAQ line (can be used to indicate this illegal opcode detection).
 		m_program = NULL;
 	}
 	else
@@ -1323,52 +1328,79 @@
 		m_program = decoded->prog;
 		MPC = -1;
 		m_command = decoded->id;
-		if (VERBOSE>7) LOG("tms9900: Command decoded as id %d, %s, base opcode %04x\n", m_command, opname[m_command], decoded->opcode);
+		if (VERBOSE>7) LOG("tms99xx: Command decoded as id %d, %s, base opcode %04x\n", m_command, opname[m_command], decoded->opcode);
 	}
+	m_pass = 1;
 }
 
-inline bool tms9900_device::byte_operation()
+inline bool tms99xx_device::byte_operation()
 {
 	return (IR & 0x1000)!=0;
 }
 
-void tms9900_device::acquire_instruction()
+void tms99xx_device::acquire_instruction()
 {
 	m_iaq_line(ASSERT_LINE);
 	m_address = PC;
 	m_first_cycle = m_icount;
 	mem_read();
 	decode(m_current_value);
-	if (VERBOSE>3) LOG("tms9900: ===== Next operation %04x (%s) at %04x =====\n", IR, opname[m_command], PC);
+	if (VERBOSE>3) LOG("tms99xx: ===== Next operation %04x (%s) at %04x =====\n", IR, opname[m_command], PC);
 	debugger_instruction_hook(this, PC);
-	PC = (PC + 2) & 0xfffe;
+	PC = (PC + 2) & 0xfffe & m_prgaddr_mask;
 	// IAQ will be cleared in the main loop
 }
 
-void tms9900_device::mem_read()
+/*
+    Memory read:
+    1) Pulse clock (done above)
+    2) Set address (we also get the value right here)
+    3) Pulse clock
+    4) If READY=L (WAIT=H, GOTO 3) else (WAIT=L, STOP)
+
+    Clock cycles: 2 + W, W = number of wait states
+*/
+void tms99xx_device::mem_read()
 {
-	m_current_value = pulse_and_read_memory(m_address);
-	if (VERBOSE>7) LOG("tms9900: memory read %04x -> %04x\n", m_address, m_current_value);
+	m_current_value = m_prgspace->read_word(m_address & m_prgaddr_mask & 0xfffe);
+	pulse_clock(2);
+	m_check_ready = true;
+	if (VERBOSE>7) LOG("tms99xx: memory read %04x -> %04x\n", m_address, m_current_value);
 }
 
-void tms9900_device::mem_write()
+void tms99xx_device::mem_write()
 {
-	pulse_and_write_memory(m_address, m_current_value);
-	if (VERBOSE>7) LOG("tms9900: memory write %04x <- %04x\n", m_address, m_current_value);
+	m_prgspace->write_word(m_address & m_prgaddr_mask & 0xfffe, m_current_value);
+	pulse_clock(2);
+	m_check_ready = true;
+	if (VERBOSE>7) LOG("tms99xx: memory write %04x <- %04x\n", m_address, m_current_value);
 }
 
-void tms9900_device::register_read()
+void tms99xx_device::register_read()
 {
 	// Need to set m_address for F1/F3 (we don't know what the data_derive did)
 	m_address = WP + (m_regnumber<<1);
-	m_register_contents = m_current_value = pulse_and_read_memory(m_address);
-	if (VERBOSE>7) LOG("tms9900: register %d read (mem %04x) -> %04x\n", m_regnumber, m_address, m_current_value);
+	mem_read();
+	m_check_ready = true;
+	m_register_contents = m_current_value;
 }
 
-void tms9900_device::register_write()
+/*
+    Memory write:
+    1) Pulse clock
+    2) Set address and write (as in the real system)
+    3) Pulse clock
+    4) If READY=L (WAIT=H, GOTO 3) else (WAIT=L, STOP)
+
+    Clock cycles: 2 + W, W = number of wait states
+*/
+void tms99xx_device::register_write()
 {
-	pulse_and_write_memory(WP + (m_regnumber<<1), m_current_value);
-	if (VERBOSE>7) LOG("tms9900: register %d write (mem %04x) <- %04x\n", m_regnumber, WP + (m_regnumber<<1), m_current_value);
+	UINT16 addr_save = m_address;
+	m_address = (WP + (m_regnumber<<1)) & m_prgaddr_mask & 0xfffe;
+	mem_write();
+	m_check_ready = true;
+	m_address = addr_save;
 }
 
 /*
@@ -1398,65 +1430,62 @@
        CRU write: First bit is at rightmost position of m_value.
 */
 
-
-#define CRUREADMASK 0x01ff
-#define CRUWRITEMASK 0x0fff
-
-void tms9900_device::cru_operation()
+void tms99xx_device::cru_input_operation()
 {
 	int value, value1;
 	int offset, location;
 
-	if (m_cru_output)
-	{
-		location = (m_cru_address >> 1)& CRUWRITEMASK;
-		value = m_value;
+	location = (m_cru_address >> 4) & (m_cruaddr_mask>>3);
+	offset   = (m_cru_address>>1) & 0x07;
 
-		// Write m_count bits from cru_address
-		for (int i=0; i < m_count; i++)
-		{
-			m_cru->write_byte(location, (value & 0x01));
-			value >>= 1;
-			location = (location + 1) & CRUWRITEMASK;
-			pulse_clock(2);
-		}
-	}
-	else
-	{
-		location = (m_cru_address >> 4)  & CRUREADMASK;
-		offset   = (m_cru_address>>1) & 0x07;
+	// Read 8 bits (containing the desired bits)
+	value = m_cru->read_byte(location);
 
-		// Read 8 bits (containing the desired bits)
-		value = m_cru->read_byte(location);
+	if ((offset + m_count) > 8)	// spans two 8 bit cluster
+	{
+		// Read next 8 bits
+		location = (location + 1) & (m_cruaddr_mask>>3);
+		value1 = m_cru->read_byte(location);
+		value |= (value1 << 8);
 
-		if ((offset + m_count) > 8)	// spans two 8 bit cluster
+		if ((offset + m_count) > 16)	// spans three 8 bit cluster
 		{
 			// Read next 8 bits
-			location = (location + 1) & CRUREADMASK;
+			location = (location + 1) & (m_cruaddr_mask>>3);
 			value1 = m_cru->read_byte(location);
-			value |= (value1 << 8);
-
-			if ((offset + m_count) > 16)	// spans three 8 bit cluster
-			{
-				// Read next 8 bits
-				location = (location + 1) & CRUREADMASK;
-				value1 = m_cru->read_byte(location);
-				value |= (value1 << 16);
-			}
+			value |= (value1 << 16);
 		}
+	}
+
+	// On each machine cycle (2 clocks) only one CRU bit is transmitted
+	pulse_clock(m_count<<1);
 
-		// On each machine cycle (2 clocks) only one CRU bit is transmitted
-		pulse_clock(m_count<<1);
+	// Shift back the bits so that the first bit is at the rightmost place
+	m_value = (value >> offset);
 
-		// Shift back the bits so that the first bit is at the rightmost place
-		m_value = (value >> offset);
+	// Mask out what we want
+	m_value &= (0x0000ffff >> (16-m_count));
+}
+
+void tms99xx_device::cru_output_operation()
+{
+	int value;
+	int location;
+	location = (m_cru_address >> 1) & m_cruaddr_mask;
+	value = m_value;
 
-		// Mask out what we want
-		m_value &= (0x0000ffff >> (16-m_count));
+	// Write m_count bits from cru_address
+	for (int i=0; i < m_count; i++)
+	{
+		if (VERBOSE>5) LOG("tms99xx: CRU output operation, address %04x, value %d\n", location<<1, value & 0x01);
+		m_cru->write_byte(location, (value & 0x01));
+		value >>= 1;
+		location = (location + 1) & m_cruaddr_mask;
+		pulse_clock(2);
 	}
 }
 
-void tms9900_device::return_from_subprogram()
+void tms99xx_device::return_from_subprogram()
 {
 	// Return from data derivation
 	// The result should be in m_current_value
@@ -1465,16 +1494,18 @@
 	MPC = m_caller_MPC; // will be increased on return
 }
 
-void tms9900_device::command_completed()
+void tms99xx_device::command_completed()
 {
 	// Pseudo state at the end of the current instruction cycle sequence
-	if (VERBOSE>7)
+	if (VERBOSE>4)
 	{
+		LOG("tms99xx: +++++ Instruction %04x (%s) completed +++++\n", IR, opname[m_command]);
 		int cycles =  m_first_cycle - m_icount;
 		// Avoid nonsense values due to expired and resumed main loop
-		if (cycles > 0 && cycles < 10000) LOG("tms9900: Instruction %04x (%s) consumed %d cycles\n", IR, opname[m_command], cycles);
+		if (cycles > 0 && cycles < 10000) LOG("tms99xx: Consumed %d cycles\n", cycles);
 	}
 	m_program = NULL;
+	m_lowbyte = false;
 }
 
 /*
@@ -1482,7 +1513,7 @@
     derivation. In terms of cycles, it does not take any time; execution
     continues with the first instruction of the subprogram.
 */
-void tms9900_device::data_derivation_subprogram()
+void tms99xx_device::data_derivation_subprogram()
 {
 	UINT16 ircopy = IR;
 
@@ -1504,7 +1535,7 @@
 		MPC += 8;	// the second option
 	}
 	m_get_destination = true;	// when we call this the second time before END it's the destination
-	MPC--;  // will be increased on return
+	m_pass = 2;
 }
 
 
@@ -1512,13 +1543,13 @@
     Status bit operations
 **************************************************************************/
 
-inline void tms9900_device::set_status_bit(int bit, bool state)
+inline void tms99xx_device::set_status_bit(int bit, bool state)
 {
 	if (state) ST |= bit;
 	else ST &= ~bit;
 }
 
-void tms9900_device::set_status_parity(UINT8 value)
+void tms99xx_device::set_status_parity(UINT8 value)
 {
 	int count = 0;
 	for (int i=0; i < 8; i++)
@@ -1529,26 +1560,26 @@
 	set_status_bit(ST_OP, (count & 1)!=0);
 }
 
-inline void tms9900_device::compare_and_set_lae(UINT16 value1, UINT16 value2)
+inline void tms99xx_device::compare_and_set_lae(UINT16 value1, UINT16 value2)
 {
 	set_status_bit(ST_EQ, value1 == value2);
 	set_status_bit(ST_LH, value1 > value2);
 	set_status_bit(ST_AGT, (INT16)value1 > (INT16)value2);
-	if (VERBOSE>7) LOG("tms9900: ST = %04x (val1=%04x, val2=%04x)\n", ST, value1, value2);
+	if (VERBOSE>7) LOG("tms99xx: ST = %04x (val1=%04x, val2=%04x)\n", ST, value1, value2);
 }
 
 /**************************************************************************
     ALU operations
 **************************************************************************/
 
-void tms9900_device::alu_nop()
+void tms99xx_device::alu_nop()
 {
 	// Do nothing (or nothing that is externally visible)
 	pulse_clock(2);
 	return;
 }
 
-void tms9900_device::alu_source()
+void tms99xx_device::alu_source()
 {
 	// Copy the current value into the source data register
 	m_source_even = ((m_address & 1)==0);
@@ -1557,27 +1588,27 @@
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_clear()
+void tms99xx_device::alu_clear()
 {
 	// Clears the register contents
 	m_register_contents = 0;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_setaddr()
+void tms99xx_device::alu_setaddr()
 {
 	// Load the current value into the address register
 	m_address = m_current_value;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_addone()
+void tms99xx_device::alu_addone()
 {
 	m_current_value++;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_setaddr_addone()
+void tms99xx_device::alu_setaddr_addone()
 {
 	// Set the address register and increase the recent value
 	m_address = m_current_value;
@@ -1585,36 +1616,38 @@
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_pcaddr_advance()
+void tms99xx_device::alu_pcaddr_advance()
 {
 	// Set PC as new read address, increase by 2
 	m_address = PC;
-	PC = (PC+2)&0xfffe;
+	PC = (PC + 2) & 0xfffe & m_prgaddr_mask;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_add_register()
+void tms99xx_device::alu_add_register()
 {
 	// Add the register contents to the current value and set as address
 	m_address = m_current_value + m_register_contents;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_imm()
+void tms99xx_device::alu_imm()
 {
-	if (VERBOSE>7) LOG("tms9900: Immediate operand, reading from position %04x\n", PC);
+	if (VERBOSE>7) LOG("tms99xx: Immediate operand, reading from position %04x\n", PC);
+	m_value_copy = m_current_value;
+	m_address_copy = m_address;
 	m_address = PC;
-	PC = (PC + 2) & 0xfffe;
+	PC = (PC + 2) & 0xfffe & m_prgaddr_mask;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_reg()
+void tms99xx_device::alu_reg()
 {
-	m_regnumber = IR & 0x000f;
+	m_address = (WP + ((IR & 0x000f)<<1)) & m_prgaddr_mask;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_f1()
+void tms99xx_device::alu_f1()
 {
 	UINT32 dest_new = 0;
 
@@ -1726,7 +1759,7 @@
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_comp()
+void tms99xx_device::alu_comp()
 {
 	m_destination_even = ((m_address & 1)==0);	// this is the destination address; the source address has already been saved
 	if (byte_operation())
@@ -1742,95 +1775,109 @@
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_f3()
+void tms99xx_device::alu_f3()
 {
-	if (m_state==0)
+	switch (m_state)
 	{
-		m_regnumber = (IR >> 6) & 0x000f;
+	case 0:
+		// Get register address
+		m_address = WP + ((IR >> 5) & 0x001e);
 		m_source_value = m_current_value;
-	}
-	else
-	{
-		if (VERBOSE>7) LOG("tms9900: coc/czc/xor %04x with %04x\n", m_source_value, m_register_contents);
-		switch (m_command)
+		break;
+	case 1:
+		if (m_command == COC)
 		{
-		case COC:
-			set_status_bit(ST_EQ, (m_register_contents & m_source_value) == m_source_value);
-			break;
-		case CZC:
-			set_status_bit(ST_EQ, (~m_register_contents & m_source_value) == m_source_value);
-			break;
-		case XOR:
-			m_current_value = (m_register_contents ^ m_source_value);
-			compare_and_set_lae(m_current_value, 0);
-			break;
+			set_status_bit(ST_EQ, (m_current_value & m_source_value) == m_source_value);
 		}
+		else
+		{
+			if (m_command == CZC)
+			{
+				set_status_bit(ST_EQ, (~m_current_value & m_source_value) == m_source_value);
+			}
+			else
+			{
+				// XOR
+				// The workspace register address is still in m_address
+				m_current_value = (m_current_value ^ m_source_value);
+				compare_and_set_lae(m_current_value, 0);
+			}
+		}
+		if (VERBOSE>7) LOG("tms99xx: ST = %04x\n", ST);
+		break;
 	}
-	if (VERBOSE>7) LOG("tms9900: ST = %04x (log comp)\n", ST);
 
 	m_state++;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_multiply()
+void tms99xx_device::alu_multiply()
 {
+	UINT32 result = 0;
+
 	switch (m_state)
 	{
 	case 0: // After data derivation
 		m_source_value = m_current_value;
-		m_regnumber = (IR >> 6)&0x000f;
+		m_address = ((IR >> 5) & 0x001e) + WP;
 		break;
 	case 1: // After reading the register (multiplier)
-		if (VERBOSE>7) LOG("tms9900: Multiply %04x by %04x\n", m_register_contents, m_source_value);
-		m_value = m_register_contents * m_source_value;
-		m_current_value = (m_value >> 16) & 0xffff;
-		m_value = m_value & 0xffff;						// Save low word in m_value
+		if (VERBOSE>7) LOG("tms99xx: Multiply %04x by %04x\n", m_current_value, m_source_value);
+		result = (m_source_value & 0x0000ffff) * (m_current_value & 0x0000ffff);
+		m_current_value = (result >> 16) & 0xffff;
+		m_value_copy = result & 0xffff;
 		pulse_clock(34);								// add 36 clock cycles (18 machine cycles); last one in main loop
 		break;
 	case 2: // After writing the high word to the destination register
-		m_current_value = m_value;						// Prepare to save low word
-		m_address = (m_address + 2) & 0xffff;
+		m_current_value = m_value_copy;						// Prepare to save low word
+		m_address = (m_address + 2) & m_prgaddr_mask;
 		break;
 	}
 	pulse_clock(2);
 	m_state++;
 }
 
-void tms9900_device::alu_divide()
+void tms99xx_device::alu_divide()
 {
 	// Format is DIV Divisor,REG(dividend)
-	UINT32 value1;
+	UINT32 uval32;
+	bool overflow = true;
+	UINT16 value1;
 
 	switch (m_state)
 	{
 	case 0:
-		m_source_value = m_current_value;		// store divisor
-		m_regnumber = (IR >> 6) & 0x000f;
+		m_source_value = m_current_value;	// store divisor
+		// Set address of register
+		m_address = WP + ((IR >> 5) & 0x001e);
+		m_address_copy = m_address;
 		break;
 	case 1:
 		// We have an overflow when the quotient cannot be stored in 16 bits
 		// This is the case when the dividend / divisor >= 0x10000,
 		// or equivalently, dividend / 0x10000 >= divisor
-		if (m_register_contents >= m_source_value)
-		{
-			ST |= ST_OV;
-			if (VERBOSE>7) LOG("tms9900: Aborting division because the dividend %08x is too big for the divisor %04x\n", (m_register_contents<<16), m_source_value);
-			abort_operation();  // behaves as if the end of the operation sequence has been reached
-		}
-		else
+
+		if (m_current_value < m_source_value)	// also if source=0
 		{
-			ST &= ~ST_OV;
-			// m_address is the address of the high word of the dividend (from the previous register read)
-			m_address = (m_address + 2) & 0xffff;
+			MPC++;	// skip the abort
+			overflow = false;
 		}
+		set_status_bit(ST_OV, overflow);
+		m_value_copy = m_current_value;			// Save the high word
+		m_address = (m_address + 2) & m_prgaddr_mask;		// Read next word
 		break;
 	case 2:
+		// W2 is in m_current_value
 		// Create full word and perform division
-		value1 = (m_register_contents << 16) | m_current_value;
-		if (VERBOSE>7) LOG("tms9900: Dividing %08x by %04x\n", value1, m_source_value);
-		m_current_value = (value1 / m_source_value) & 0xffff;
-		m_value = (value1 % m_source_value) & 0xffff;
-		if (VERBOSE>7) LOG("tms9900: Quotient %04x, remainder %04x\n", m_current_value, m_value);
+		uval32 = (m_value_copy << 16) | m_current_value;
+
+		if (VERBOSE>7) LOG("tms99xx: Dividing %08x by %04x\n", uval32, m_source_value);
+		m_current_value = uval32 / m_source_value;
+		m_value_copy = uval32 % m_source_value;
+
+		if (VERBOSE>7) LOG("tms99xx: Quotient %04x, remainder %04x\n", m_current_value, m_value_copy);
+
+		m_address = m_address_copy;
 
 		// The number of ALU cycles depends on the number of steps in
 		// the division algorithm. The number of cycles is between 32 and
@@ -1839,8 +1886,10 @@
 		// the following heuristic: We use 32 ALU cycles in general, then
 		// we need as many cycles as it takes to
 		// shift away the dividend. Thus, bigger dividends need more cycles.
+
 		pulse_clock(62);	// one pulse is at the start, one at the end
-		value1 = m_register_contents & 0xffff;
+		value1 = m_value_copy & 0xffff;
+
 		while (value1 != 0)
 		{
 			value1 = (value1 >> 1) & 0xffff;
@@ -1849,23 +1898,23 @@
 		// We still have m_regnumber; this is where m_current_value will go to
 		break;
 	case 3:
-		// Prepare to write the remainder; we have the address from above
-		// (m_address), did not change
-		m_current_value = m_value;
-		if (VERBOSE>7) LOG("tms9900: ST = %04x (div)\n", ST);
+		// Prepare to write the remainder
+		m_current_value = m_value_copy;
+		m_address = m_address + 2;
+		if (VERBOSE>7) LOG("tms99xx: ST = %04x (div)\n", ST);
 		break;
 	}
 	pulse_clock(2);
 	m_state++;
 }
 
-void tms9900_device::alu_xop()
+void tms99xx_device::alu_xop()
 {
 	switch (m_state)
 	{
 	case 0:
 		// We have the effective address of the source operand in m_address
-		m_source_address = m_address;
+		m_address_saved = m_address;
 		// Now we take the XOP number from the instruction register
 		// and calculate the vector location
 		// [0010 11xx xx tt SSSS]  shift 6 right, then *4 => shift 4 right
@@ -1873,35 +1922,35 @@
 		break;
 	case 1:
 		m_value = WP;							// save the old WP
-		WP = m_current_value;					// the new WP has been read in the previous microoperation
-		m_current_value = m_source_address;		// we saved the address of the source operand; retrieve it
-		m_regnumber = 11;						// Next register is R11
+		WP = m_current_value & m_prgaddr_mask;	// the new WP has been read in the previous microoperation
+		m_current_value = m_address_saved;		// we saved the address of the source operand; retrieve it
+		m_address = WP + 0x0016;				// Next register is R11
 		break;
 	case 2:
+		m_address = WP + 0x001e;
 		m_current_value = ST;
-		m_regnumber = 15;
 		break;
 	case 3:
+		m_address = WP + 0x001c;
 		m_current_value = PC;
-		m_regnumber = 14;
 		break;
 	case 4:
-		m_current_value = WP;
-		m_regnumber = 13;
+		m_address = WP + 0x001a;
+		m_current_value = m_value;						// old WP into new R13
 		break;
 	case 5:
 		m_address =  0x0042 + ((IR >> 4) & 0x003c);		// location of new PC
-		ST |= ST_X;
+		set_status_bit(ST_X, true);
 		break;
 	case 6:
-		PC = m_current_value;
+		PC = m_current_value & m_prgaddr_mask;
 		break;
 	}
 	pulse_clock(2);
 	m_state++;
 }
 
-void tms9900_device::alu_clr_swpb()
+void tms99xx_device::alu_clr_swpb()
 {
 	UINT32 dest_new = 0;
 	UINT32 src_val = m_current_value & 0x0000ffff;
@@ -1977,7 +2026,7 @@
 	// No states here
 }
 
-void tms9900_device::alu_abs()
+void tms99xx_device::alu_abs()
 {
 	// LAECO (from original word!)
 	// O if >8000
@@ -1998,9 +2047,9 @@
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_x()
+void tms99xx_device::alu_x()
 {
-	if (VERBOSE>7) LOG("tms9900: Substituting current command by %04x\n", m_current_value);
+	if (VERBOSE>7) LOG("tms99xx: Substituting current command by %04x\n", m_current_value);
 	decode(m_current_value);
 	pulse_clock(2);
 }
@@ -2008,7 +2057,7 @@
 /*
     Also used by other microprograms
 */
-void tms9900_device::alu_b()
+void tms99xx_device::alu_b()
 {
 	// no status bits
 	// Although we got the contents of the source data, we do not use them
@@ -2017,54 +2066,45 @@
 	// If we have a B *R5 and R5 contains the value 0xa000, the CPU actually
 	// retrieves the value at 0xa000, but in fact it will load the PC
 	// with the address 0xa000
-	PC = m_address;
-	if (VERBOSE>7) LOG("tms9900: Set new PC = %04x\n", PC);
-	pulse_clock(2);
-}
-
-void tms9900_device::alu_bl()
-{
-	// no status bits
-	// We have just retrieved the target address; save it in another location
-	m_source_value = m_current_value;
 	m_current_value = PC;
-	m_regnumber = 11;
-	pulse_clock(4);
-	PC = m_address;	// See B command: Forget about the value from the target location
-	if (VERBOSE>7) LOG("tms9900: Set new PC = %04x\n", PC);
+	PC = m_address & m_prgaddr_mask;
+	m_address = WP + 22;
+	if (VERBOSE>7) LOG("tms99xx: Set new PC = %04x\n", PC);
+	pulse_clock(2);
 }
 
-void tms9900_device::alu_blwp()
+void tms99xx_device::alu_blwp()
 {
 	switch (m_state)
 	{
 	case 0:
-		m_source_address = m_address;					// Save the location of the WP
-		m_value = WP;
-		WP = m_current_value;							// set new WP (*m_destination)
+		m_value_copy = WP;
+		WP = m_current_value & m_prgaddr_mask;				// set new WP (*m_destination)
+		m_address_saved = (m_address + 2) & m_prgaddr_mask;	// Save the location of the WP
+		m_address = WP + 30;
 		m_current_value = ST;							// get status register
-		m_regnumber = 15;
 		break;
 	case 1:
 		m_current_value = PC;							// get program counter
-		m_regnumber = 14;
+		m_address = m_address - 2;
 		break;
 	case 2:
-		m_current_value = m_value;					// retrieve the old WP
-		m_regnumber = 13;
+		m_current_value = m_value_copy;					// retrieve the old WP
+		m_address = m_address - 2;
 		break;
 	case 3:
-		m_address = (m_source_address + 2)&0xffff;	// point to PC component of branch vector
+		m_address = m_address_saved;					// point to PC component of branch vector
 		break;
 	case 4:
-		PC = m_current_value;
+		PC = m_current_value & m_prgaddr_mask;
+		if (VERBOSE>5) LOG("tms9900: Context switch complete; WP=%04x, PC=%04x, ST=%04x\n", WP, PC, ST);
 		break;
 	}
 	pulse_clock(2);
 	m_state++;
 }
 
-void tms9900_device::alu_ldcr()
+void tms99xx_device::alu_ldcr()
 {
 	UINT16 value;
 
@@ -2080,7 +2120,7 @@
 
 	if (m_state == 0)
 	{
-		m_regnumber = 12;
+		m_address = WP + 24;
 	}
 	else
 	{
@@ -2097,16 +2137,15 @@
 		{
 			compare_and_set_lae(value, 0);
 		}
-		m_cru_output = true;
-		m_cru_address = m_register_contents;
+		m_cru_address = m_current_value;
 		m_value = value;
-		if (VERBOSE>6) LOG("tms9900: Load CRU address %04x (%d bits), value = %04x\n", m_cru_address, m_count, m_value);
+		if (VERBOSE>6) LOG("tms99xx: Load CRU address %04x (%d bits), value = %04x\n", m_cru_address, m_count, m_value);
 	}
 	m_state++;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_stcr()
+void tms99xx_device::alu_stcr()
 {
 	UINT16 value;
 
@@ -2120,11 +2159,10 @@
 	switch (m_state)
 	{
 	case 0: // After getting the destination operand and saving the address/value
-		m_regnumber = 12;
+		m_address = WP + 24;
 		break;
 	case 1: // After getting R12
-		m_cru_output = false;
-		m_cru_address = m_register_contents;
+		m_cru_address = m_current_value;
 		m_count = (IR >> 6) & 0x000f;
 		if (m_count == 0) m_count = 16;
 		break;
@@ -2132,7 +2170,7 @@
 		value = m_value & 0xffff;
 		if (m_count < 9)
 		{
-			if (VERBOSE>6) LOG("tms9900: Store CRU at %04x (%d bits) in %04x, result = %02x\n", m_cru_address, m_count, m_source_address, value);
+			if (VERBOSE>6) LOG("tms99xx: Store CRU at %04x (%d bits) in %04x, result = %02x\n", m_cru_address, m_count, m_source_address, value);
 			set_status_parity((UINT8)(value & 0xff));
 			compare_and_set_lae(value<<8, 0);
 			if (m_source_even)
@@ -2144,7 +2182,7 @@
 		}
 		else
 		{
-			if (VERBOSE>6) LOG("tms9900: Store CRU at %04x (%d bits) in %04x, result = %04x\n", m_cru_address, m_count, m_source_address, value);
+			if (VERBOSE>6) LOG("tms99xx: Store CRU at %04x (%d bits) in %04x, result = %04x\n", m_cru_address, m_count, m_source_address, value);
 			m_current_value = value;
 			compare_and_set_lae(value, 0);
 			pulse_clock(2*(5 + (16-m_count)));
@@ -2157,50 +2195,47 @@
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_sbz_sbo()
+void tms99xx_device::alu_sbz_sbo()
 {
 	INT8 displacement;
 	if (m_state==0)
 	{
-		m_regnumber = 12;
+		m_address = WP + 24;
 	}
 	else
 	{
-		m_cru_output = true;
-		displacement = (IR & 0xff);
-		m_cru_address = m_register_contents + (displacement<<1);
+		m_value = (m_command==SBO)? 1 : 0;
+		displacement = (INT8)(IR & 0xff);
+		m_cru_address = m_current_value + (displacement<<1);
 		m_count = 1;
-		m_value = (m_command == SBO)? 1 : 0;
-		pulse_clock(2);
 	}
 	m_state++;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_tb()
+void tms99xx_device::alu_tb()
 {
 	INT8 displacement;
 	switch (m_state)
 	{
 	case 0:
-		m_regnumber = 12;
+		m_address = WP + 24;
 		break;
 	case 1:
-		m_cru_output = false;
-		displacement = (IR & 0xff);
-		m_cru_address = m_register_contents + (displacement<<1);
+		displacement = (INT8)(IR & 0xff);
+		m_cru_address = m_current_value + (displacement<<1);
 		m_count = 1;
 		break;
 	case 2:
 		set_status_bit(ST_EQ, m_value!=0);
-		if (VERBOSE>7) LOG("tms9900: ST = %04x\n", ST);
+		if (VERBOSE>7) LOG("tms99xx: ST = %04x\n", ST);
 		break;
 	}
 	m_state++;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_jmp()
+void tms99xx_device::alu_jmp()
 {
 	INT8 displacement;
 	bool cond = false;
@@ -2252,44 +2287,57 @@
 		pulse_clock(2);
 		if (!cond)
 		{
-			if (VERBOSE>7) LOG("tms9900: Jump condition false\n");
+			if (VERBOSE>7) LOG("tms99xx: Jump condition false\n");
 			MPC+=1;	// skip next ALU call
 		}
 		else
-			if (VERBOSE>7) LOG("tms9900: Jump condition true\n");
+			if (VERBOSE>7) LOG("tms99xx: Jump condition true\n");
 	}
 	else
 	{
 		displacement = (IR & 0xff);
-		PC = PC + (displacement<<1);
+		PC = (PC + (displacement<<1)) & m_prgaddr_mask;
 		pulse_clock(2);
 	}
 	m_state++;
 }
 
-void tms9900_device::alu_shift()
+void tms99xx_device::alu_shift()
 {
 	bool carry = false;
 	bool overflow = false;
 	UINT16 sign = 0;
 	UINT32 value;
+	int count;
 
 	switch (m_state)
 	{
 	case 0:
-		m_regnumber = (IR & 0x000f);
+		m_address = WP + ((IR & 0x000f)<<1);
 		break;
 	case 1:
-		m_source_value = m_current_value;			// save it
-		m_count = (IR >> 4) & 0x000f;
-		if (m_count != 0) MPC++;
-		else m_regnumber = 0;
+		// we have the value of the register in m_current_value
+		// Save it (we may have to read R0)
+		m_value_copy = m_current_value;
+		m_address_saved = m_address;
+		m_address = WP;
+		m_current_value = (IR >> 4) & 0x000f;
+
+		if (m_current_value != 0)
+		{
+			// skip the next read operation
+			MPC++;
+		}
+		else
+		{
+			if (VERBOSE>8) LOG("tms99xx: Shift operation gets count from R0\n");
+		}
 		break;
 	case 2:
-		value = m_source_value & 0xffff;
+		count = m_current_value & 0x000f; // from the instruction or from R0
+		if (count==0) count = 16;
 
-		if (m_count==0) m_count = m_register_contents & 0x000f;
-		if (m_count==0) m_count = 16;
+		value = m_value_copy;
 
 		// we are re-implementing the shift operations because we have to pulse
 		// the clock at each single shift anyway.
@@ -2297,7 +2345,7 @@
 		// Note that count is never 0
 		if (m_command == SRA) sign = value & 0x8000;
 
-		for (int i=0; i < m_count; i++)
+		for (int i=0; i < count; i++)
 		{
 			switch (m_command)
 			{
@@ -2323,70 +2371,71 @@
 		set_status_bit(ST_C, carry);
 		set_status_bit(ST_OV, overflow);
 		compare_and_set_lae(m_current_value, 0);
-
-		m_regnumber = (IR & 0x000f);
+		m_address = m_address_saved;		// Register address
+		if (VERBOSE>7) LOG("tms99xx: ST = %04x (val=%04x)\n", ST, m_current_value);
 		break;
 	}
 	m_state++;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_ai_ori()
+void tms99xx_device::alu_ai_ori()
 {
 	UINT32 dest_new = 0;
 	switch (m_command)
 	{
 	case AI:
-		dest_new = m_current_value + m_register_contents;
+		dest_new = m_current_value + m_value_copy;
 		// See status bit handling for Add
 		set_status_bit(ST_C, (dest_new & 0x10000) != 0);
-		set_status_bit(ST_OV, ((dest_new ^ m_current_value) & (dest_new ^ m_register_contents) & 0x8000)!=0);
+		set_status_bit(ST_OV, ((dest_new ^ m_current_value) & (dest_new ^ m_value_copy) & 0x8000)!=0);
 		break;
 	case ANDI:
-		dest_new = m_current_value & m_register_contents;
+		dest_new = m_current_value & m_value_copy;
 		break;
 	case ORI:
-		dest_new = m_current_value | m_register_contents;
+		dest_new = m_current_value | m_value_copy;
 		break;
 	}
 	m_current_value = dest_new & 0xffff;
+	m_address = m_address_copy;
 	compare_and_set_lae(m_current_value, 0);
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_ci()
+void tms99xx_device::alu_ci()
 {
-	compare_and_set_lae(m_register_contents, m_current_value);
+	compare_and_set_lae(m_value_copy, m_current_value);
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_li()
+void tms99xx_device::alu_li()
 {
 	compare_and_set_lae(m_current_value, 0);
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_lwpi()
+void tms99xx_device::alu_lwpi()
 {
-	WP = m_current_value;
+	WP = m_current_value & m_prgaddr_mask;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_limi()
+void tms99xx_device::alu_limi()
 {
 	ST = (ST & 0xfff0) | (m_current_value & 0x000f);
-	if (VERBOSE>7) LOG("tms9900: ST = %04x\n", ST);
+	if (VERBOSE>7) LOG("tms99xx: ST = %04x\n", ST);
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_stwp_stst()
+void tms99xx_device::alu_stwp_stst()
 {
 	if (m_command==STST) m_current_value = ST;
 	else m_current_value = WP;
 	pulse_clock(2);
 }
 
-void tms9900_device::alu_external()
+void tms99xx_device::alu_external()
 {
 	pulse_clock(10);
 
@@ -2405,23 +2454,23 @@
 	m_external_operation((IR >> 5) & 0x07, 1);
 }
 
-void tms9900_device::alu_rtwp()
+void tms99xx_device::alu_rtwp()
 {
 	switch (m_state)
 	{
 	case 0:
-		m_regnumber = 15;
+		m_address = WP + 30;		// R15
 		break;
 	case 1:
-		ST = m_register_contents;
-		m_regnumber = 14;
+		ST = m_current_value;
+		m_address -= 2;				// R14
 		break;
 	case 2:
-		PC = m_register_contents;
-		m_regnumber = 13;
+		PC = m_current_value & m_prgaddr_mask;
+		m_address -= 2;				// R13
 		break;
 	case 3:
-		WP = m_register_contents;
+		WP = m_current_value & m_prgaddr_mask;
 		break;
 	}
 	m_state++;
@@ -2429,9 +2478,9 @@
 }
 
 
-void tms9900_device::alu_int()
+void tms99xx_device::alu_int()
 {
-	if (VERBOSE>7) LOG("tms9900: INT state %d; irq_level %d\n", m_state, m_irq_level);
+	if (VERBOSE>7) LOG("tms99xx: INT state %d; irq_level %d\n", m_state, m_irq_level);
 	switch (m_state)
 	{
 	case 0:
@@ -2442,7 +2491,7 @@
 		}
 		else
 		{
-			if (m_irq_level == LOAD_INT) m_address = 0xfffc;
+			if (m_irq_level == LOAD_INT) m_address = 0xfffc; // will be truncated for TMS9980
 			else
 			{
 				m_address = (m_irq_level << 2);
@@ -2450,25 +2499,26 @@
 		}
 		break;
 	case 1:
-		m_value = WP;				// old WP
-		WP = m_current_value;		// new WP
+		m_address_copy = m_address;
+		m_value_copy = WP;							// old WP
+		WP = m_current_value & m_prgaddr_mask;		// new WP
 		m_current_value = ST;
-		m_regnumber = 15;
+		m_address = (WP + 30) & m_prgaddr_mask;
 		break;
 	case 2:
 		m_current_value = PC;
-		m_regnumber = 14;
+		m_address = (WP + 28) & m_prgaddr_mask;
 		break;
 	case 3:
-		m_current_value = m_value;	// old WP
-		m_regnumber = 13;
+		m_current_value = m_value_copy;	// old WP
+		m_address = (WP + 26) & m_prgaddr_mask;
 		break;
 	case 4:
-		m_address = (m_address + 2) & 0xfffe;
-		if (VERBOSE>7) LOG("tms9900: read from %04x\n", m_address);
+		m_address = (m_address_copy + 2) & 0xfffe & m_prgaddr_mask;
+		if (VERBOSE>7) LOG("tms99xx: read from %04x\n", m_address);
 		break;
 	case 5:
-		PC = m_current_value;
+		PC = m_current_value & m_prgaddr_mask;
 		if (m_irq_level > 0 )
 		{
 			ST = (ST & 0xfff0) | (m_irq_level - 1);
@@ -2480,18 +2530,18 @@
 }
 
 /**************************************************************************/
-UINT32 tms9900_device::execute_min_cycles() const
+UINT32 tms99xx_device::execute_min_cycles() const
 {
 	return 2;
 }
 
 // TODO: Compute this value, just a wild guess for the average
-UINT32 tms9900_device::execute_max_cycles() const
+UINT32 tms99xx_device::execute_max_cycles() const
 {
 	return 10;
 }
 
-UINT32 tms9900_device::execute_input_lines() const
+UINT32 tms99xx_device::execute_input_lines() const
 {
 	return 1;
 }
@@ -2501,17 +2551,17 @@
 // execute_burn = nop
 
 // device_disasm_interface overrides
-UINT32 tms9900_device::disasm_min_opcode_bytes() const
+UINT32 tms99xx_device::disasm_min_opcode_bytes() const
 {
 	return 2;
 }
 
-UINT32 tms9900_device::disasm_max_opcode_bytes() const
+UINT32 tms99xx_device::disasm_max_opcode_bytes() const
 {
 	return 6;
 }
 
-offs_t tms9900_device::disasm_disassemble(char *buffer, offs_t pc, const UINT8 *oprom, const UINT8 *opram, UINT32 options)
+offs_t tms99xx_device::disasm_disassemble(char *buffer, offs_t pc, const UINT8 *oprom, const UINT8 *opram, UINT32 options)
 {
 	return Dasm9900(buffer, pc, TMS9900_ID, oprom, opram);
 }
diff -Nru src-old/emu/cpu/tms9900/tms9900.h src/emu/cpu/tms9900/tms9900.h
--- src-old/emu/cpu/tms9900/tms9900.h	2012-06-07 22:14:04.000000000 +0200
+++ src/emu/cpu/tms9900/tms9900.h	2012-06-14 17:52:32.000000000 +0200
@@ -49,6 +49,12 @@
 
 enum
 {
+	LOAD_INT = -1,
+	RESET_INT = -2
+};
+
+enum
+{
 	TI990_10_ID = 1,
 	TMS9900_ID = 3,
 	TMS9940_ID = 4,
@@ -61,7 +67,7 @@
 	TMS99110A_ID = 12
 };
 
-#define MCFG_TMS9900_ADD(_tag, _device, _clock, _prgmap, _iomap, _config)		\
+#define MCFG_TMS99xx_ADD(_tag, _device, _clock, _prgmap, _iomap, _config)		\
 	MCFG_DEVICE_ADD(_tag, _device, _clock)		\
 	MCFG_DEVICE_PROGRAM_MAP(_prgmap)			\
 	MCFG_DEVICE_IO_MAP(_iomap)					\
@@ -76,7 +82,18 @@
 	LREX_OP = 7
 };
 
-typedef struct _tms9900_config
+static const char opname[][5] =
+{   "ILL ", "A   ", "AB  ", "ABS ", "AI  ", "ANDI", "B   ", "BL  ", "BLWP", "C   ",
+	"CI  ", "CB  ", "CKOF", "CKON", "CLR ", "COC ", "CZC ", "DEC ", "DECT", "DIV ",
+	"IDLE", "INC ", "INCT", "INV ", "JEQ ", "JGT ", "JH  ", "JHE ", "JL  ", "JLE ",
+	"JLT ", "JMP ", "JNC ", "JNE ", "JNO ", "JOC ", "JOP ", "LDCR", "LI  ", "LIMI",
+	"LREX", "LWPI", "MOV ", "MOVB", "MPY ", "NEG ", "ORI ", "RSET",	"RTWP", "S   ",
+	"SB  ", "SBO ", "SBZ ", "SETO", "SLA ", "SOC ", "SOCB", "SRA ", "SRC ", "SRL ",
+	"STCR", "STST", "STWP", "SWPB", "SZC ", "SZCB", "TB  ", "X   ", "XOP ", "XOR ",
+	"*int"
+};
+
+typedef struct _tms99xx_config
 {
 	devcb_write8		external_callback;
 	devcb_read8			irq_level;
@@ -84,15 +101,19 @@
 	devcb_write_line	clock_out;
 	devcb_write_line	wait_line;
 	devcb_write_line	holda_line;
-} tms9900_config;
+} tms99xx_config;
 
-#define TMS9900_CONFIG(name) \
-	const tms9900_config(name) =
+#define TMS99xx_CONFIG(name) \
+	const tms99xx_config(name) =
 
-class tms9900_device : public cpu_device
+class tms99xx_device : public cpu_device
 {
 public:
-	tms9900_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+	tms99xx_device(const machine_config &mconfig, device_type type,  const char *name,
+				const char *tag, int databus_width, int prg_addr_bits, int cru_addr_bits,
+				device_t *owner, UINT32 clock);
+
+	~tms99xx_device();
 
 	// READY input line. When asserted (high), the memory is ready for data exchange.
 	void set_ready(int state);
@@ -122,7 +143,23 @@
 
 	const address_space_config* memory_space_config(address_spacenum spacenum) const;
 
-private:
+	// Let these methods be overloaded by the TMS9980.
+	virtual void		mem_read(void);
+	virtual void		mem_write(void);
+	virtual void		acquire_instruction(void);
+	void				decode(UINT16 inst);
+
+	const address_space_config	m_program_config;
+	const address_space_config	m_io_config;
+	address_space*			m_prgspace;
+	address_space*			m_cru;
+
+	virtual UINT16	read_workspace_register_debug(int reg);
+	virtual void	write_workspace_register_debug(int reg, UINT16 data);
+
+	// Cycle counter
+	int 	m_icount;
+
 	// TMS9900 hardware registers
 	UINT16	WP; 	// Workspace pointer
 	UINT16	PC; 	// Program counter
@@ -131,38 +168,72 @@
 	// Internal register
 	UINT16	IR;		// Instruction register
 
+	// Stored address
+	UINT16	m_address;
+
+	// Stores the recently read word or the word to be written
+	UINT16	m_current_value;
+
 	// Decoded command
 	UINT16	m_command;
 
+	// Issue clock pulses. Note that each machine cycle has two clock cycles.
+	void pulse_clock(int count);
+
+	// For multi-pass operations. For instance, memory word accesses are
+	// executed as two consecutive byte accesses. CRU accesses are repeated
+	// single-bit accesses. (Needed for TMS9980)
+	int		m_pass;
+
+	// Data bus width. Needed for TMS9980.
+	int 	m_databus_width;
+
+	// Needed for TMS9980
+	bool	m_lowbyte;
+
+	// Check the READY line?
+	bool	m_check_ready;
+
+	// Max address
+	const UINT16  m_prgaddr_mask;
+	const UINT16  m_cruaddr_mask;
+
+	bool	m_load_state;
+	bool	m_irq_state;
+	bool	m_reset;
+
+	// Determine the interrupt level using the IC0-IC2/3 lines
+	virtual int get_intlevel(int state);
+
+	// Interrupt level as acquired from input lines (TMS9900: IC0-IC3, TMS9980: IC0-IC2)
+	// We assume all values right-justified, i.e. TMS9980 also counts up by one
+	int 	m_irq_level;
+
+	// Used to display the number of consumed cycles in the log.
+	int		m_first_cycle;
+
+	// Signal to the outside world that we are now getting an instruction
+	devcb_resolved_write_line	m_iaq_line;
+
+	// Get the value of the interrupt level lines
+	devcb_resolved_read8	m_get_intlevel;
+
+private:
 	// Indicates if this is a byte-oriented command
 	inline bool 	byte_operation();
 
-	const address_space_config		m_program_config;
-	const address_space_config		m_io_config;
-	address_space*					m_prgspace;
-	address_space*					m_cru;
-
 	// Processor states
 	bool	m_idle_state;
-	bool	m_load_state;
-	bool	m_irq_state;
 	bool	m_ready_state;
 	bool	m_wait_state;
 	bool	m_hold_state;
 
-	bool	m_reset;
-
-	int 	m_irq_level;	// Interrupt level as acquired from input lines IC0-IC3
-	int 	m_icount;		// Cycle counter
-
 	// State / debug management
 	UINT16	m_state_any;
 	static const char* s_statename[];
 	void	state_import(const device_state_entry &entry);
 	void	state_export(const device_state_entry &entry);
 	void	state_string_export(const device_state_entry &entry, astring &string);
-	UINT16	read_workspace_register_debug(int reg);
-	void	write_workspace_register_debug(int reg, UINT16 data);
 
 	// Interrupt handling
 	void service_interrupt();
@@ -176,7 +247,7 @@
 	typedef const UINT8* microprogram;
 
 	// Method pointer
-	typedef void (tms9900_device::*ophandler)(void);
+	typedef void (tms99xx_device::*ophandler)(void);
 
 	// Opcode list entry
 	typedef struct _tms_instruction
@@ -201,18 +272,16 @@
 	lookup_entry*	m_lotables[32];
 
 	// List of pointers for micro-operations
-	static const tms9900_device::ophandler s_microoperation[];
+	static const tms99xx_device::ophandler s_microoperation[];
 
 	// Opcode table
-	static const tms9900_device::tms_instruction s_command[];
+	static const tms99xx_device::tms_instruction s_command[];
 
 	// Micro-operation declarations
-	void	acquire_instruction(void);
-	void	mem_read(void);
-	void	mem_write(void);
 	void	register_read(void);
 	void	register_write(void);
-	void	cru_operation(void);
+	void	cru_input_operation(void);
+	void	cru_output_operation(void);
 	void	data_derivation_subprogram(void);
 	void	return_from_subprogram(void);
 	void	command_completed(void);
@@ -258,9 +327,6 @@
 	void	alu_int(void);
 
 	void	abort_operation(void);
-	UINT16	pulse_and_read_memory(UINT16 address);
-	void	pulse_and_write_memory(UINT16 address, UINT16 data);
-	void	decode(UINT16 inst);
 
 	// Micro-operation
 	UINT8	m_op;
@@ -278,27 +344,15 @@
 	// State of the micro-operation. Needed for repeated ALU calls.
 	int 	m_state;
 
-	// Check the READY line?
-	bool	m_check_ready;
-
 	// Has HOLD been acknowledged yet?
 	bool	m_hold_acknowledged;
 
-	// Issue clock pulses. Note that each machine cycle has two clock cycles.
-	inline void pulse_clock(int count);
-
 	// Signal the wait state via the external line
 	inline void set_wait_state(bool state);
 
 	// Used to acknowledge HOLD and enter the HOLD state
 	inline void acknowledge_hold();
 
-	// Stored address
-	UINT16	m_address;
-
-	// Stores the recently read word or the word to be written
-	UINT16	m_current_value;
-
 	// Was the source operand a byte from an even address?
 	bool m_source_even;
 
@@ -308,6 +362,10 @@
 	// Intermediate storage for the source operand
 	UINT16 m_source_address;
 	UINT16 m_source_value;
+	UINT16	m_address_saved;
+
+	// Another copy of the address
+	UINT16	m_address_copy;
 
 	// Stores the recently read register contents
 	UINT16	m_register_contents;
@@ -315,15 +373,15 @@
 	// Stores the register number for the next register access
 	int 	m_regnumber;
 
-	// CRU support: Indicates whether the CRU shall be configured to output mode
-	bool	m_cru_output;
-
 	// CRU support: Stores the CRU address
 	UINT16	m_cru_address;
 
 	// CRU support: Stores the number of bits to be transferred
 	int		m_count;
 
+	// Copy of the value
+	UINT16	m_value_copy;
+
 	// Another internal register, storing intermediate values
 	// Using 32 bits to support MPY
 	UINT32	m_value;
@@ -336,9 +394,6 @@
 	inline void compare_and_set_lae(UINT16 value1, UINT16 value2);
 	void set_status_parity(UINT8 value);
 
-	// Used to display the number of consumed cycles in the log.
-	int		m_first_cycle;
-
 	/************************************************************************/
 
 	// Trigger external operation. This is achieved by putting a special value in
@@ -363,12 +418,6 @@
 	// chip emulations we use a dedicated callback.
 	devcb_resolved_write8	m_external_operation;
 
-	// Get the value of the interrupt level lines
-	devcb_resolved_read8	m_get_ic0123;
-
-	// Signal to the outside world that we are now getting an instruction
-	devcb_resolved_write_line	m_iaq_line;
-
 	// Clock output. This is not a pin of the TMS9900 because the TMS9900
 	// needs an external clock, and usually one of those external lines is
 	// used for this purpose.
@@ -381,6 +430,15 @@
 	devcb_resolved_write_line	m_holda_line;
 };
 
+/*****************************************************************************/
+
+class tms9900_device : public tms99xx_device
+{
+public:
+	tms9900_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+};
+
+
 unsigned Dasm9900(char *buffer, unsigned pc, int model_id, const UINT8 *oprom, const UINT8 *opram);
 
 // device type definition
diff -Nru src-old/emu/cpu/tms9900/tms9980a.c src/emu/cpu/tms9900/tms9980a.c
--- src-old/emu/cpu/tms9900/tms9980a.c	2012-06-07 22:14:04.000000000 +0200
+++ src/emu/cpu/tms9900/tms9980a.c	2012-06-14 17:52:32.000000000 +0200
@@ -1,4 +1,245 @@
 /*
-    This file will contain the re-implementation of the tms9980a. The
-    previous implementation can be found as tms9980al.
+    Cycle-precise implementation of the TMS9980A.
+    Subclassed from tms99xx_device in tms9900.c.
+
+                    +----------------+
+              /HOLD | 1     \/     40| /MEMEN
+              HOLDA | 2            39| READY
+                IAQ | 3            38| /WE
+  LSB +- A13,CRUOUT | 4            37| CRUCLK
+      |         A12 | 5            36| Vdd
+      |         A11 | 6            35| Vss
+      |         A10 | 7            34| CKIN
+   Address       A9 | 8            33| D7      --+
+     bus         A8 | 9            32| D6        |
+      |          A7 |10            31| D5       Data
+    16KiB        A6 |11            30| D4       bus
+      |          A5 |12            29| D3        |
+      |          A4 |13            28| D2       2 * 8 bit
+      |          A3 |14            27| D1        |
+      |          A2 |15            26| D0      --+
+      |          A1 |16            25| INT0    --+
+  MSB +--        A0 |17            24| INT1      | Interrupt levels
+               DBIN |18            23| INT2    --+
+              CRUIN |19            22| /PHI3
+                Vcc |20            21| Vbb
+                    +----------------+
+
+  The TMS9980A is similar to the TMS9900, with the following differences:
+
+    - Address bus is only 14 bit wide (16 KiB)
+    - Data bus is 16 bit wide and multiplexed on 8 lines (2 bytes per access)
+    - CRU space is limited to 2048 bits (due to fewer address lines)
+    - Only three interrupt level lines, for a maximum of 8 levels.
+    - No INTREQ, RESET, and LOAD lines. All interrupts are signaled via INT0 -
+      INT2. Reset=00x, Load=010, Level1=011, Level2=100, Level3=101, Level4=110,
+      all interrupts cleared=111.
+    - Memory accesses are always 2 bytes (even address byte, odd address byte)
+      even for byte operations. Thus the 9980A, like the TMS9900, needs to
+      pre-fetch the word at the destination before overwriting it.
+    - On the cycle level both TMS9900 and TMS9980A are equal, except for the
+      additional cycles needed for memory read and write access. Accordingly,
+      the emulation shares the core and the microprograms and redefines the
+      memory access and the interrupt handling only.
+    - The 9980A has the same external instructions as the TMS9900, but it
+      indicates the command via A0, A1, and A13 (instead of A0-A2).
+
+    For pin definitions see tms9900.c
+
+   Michael Zapf, 2012
 */
+
+#include "tms9980a.h"
+
+#define LOG logerror
+#define VERBOSE 1
+
+/****************************************************************************
+    Constructor
+****************************************************************************/
+
+tms9980a_device::tms9980a_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: tms99xx_device(mconfig, TMS9980A, "TMS9980A", tag, 8, 14, 11, owner, clock)
+{
+}
+
+UINT16 tms9980a_device::read_workspace_register_debug(int reg)
+{
+	int temp = m_icount;
+	int addr = (WP+(reg<<1)) & 0xfffe & m_prgaddr_mask;
+	UINT16 value = (m_prgspace->read_byte(addr) << 8) | (m_prgspace->read_byte(addr+1) & 0xff);
+	m_icount = temp;
+	return value;
+}
+
+void tms9980a_device::write_workspace_register_debug(int reg, UINT16 data)
+{
+	int temp = m_icount;
+	int addr = (WP+(reg<<1)) & 0xfffe & m_prgaddr_mask;
+	m_prgspace->write_byte(addr, data>>8);
+	m_prgspace->write_byte(addr+1, data & 0xff);
+	m_icount = temp;
+}
+
+/*
+    Interrupt input. Keep in mind that the TMS9980A does not have any INTREQ
+    line but signals interrupts via IC0-IC2 only. Thus we cannot take down any
+    single interrupt; only all interrupts can be cleared at once using level 7.
+    The state parameter is actually not needed.
+*/
+void tms9980a_device::execute_set_input(int irqline, int state)
+{
+	m_irq_level = get_intlevel(state);
+
+	if (m_irq_level != 7)
+	{
+		if (m_irq_level == LOAD_INT)
+		{
+			// Clearing m_reset is a hack to prevent an initial RESET.
+			// Should fix that in tms99xx
+			m_reset = false;
+			m_load_state = true;
+		}
+		else m_irq_state = true;
+		if (VERBOSE>6) LOG("tms9980a: interrupt level=%d, ST=%04x\n", m_irq_level, ST);
+	}
+}
+
+int tms9980a_device::get_intlevel(int state)
+{
+	int level = m_get_intlevel(0) & 0x0007;
+
+	// Just to stay consistent.
+	if (state==CLEAR_LINE) level = 7;
+
+	switch (level)
+	{
+	case 0:
+	case 1:
+		level = RESET_INT;
+		m_reset = true;
+		break;
+	case 2:
+		level = LOAD_INT;
+		break;
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+		level = level - 2;
+		break;
+	case 7:
+		// Clear all interrupts
+		m_load_state = false;
+		m_irq_state = false;
+		if (VERBOSE>6) LOG("tms9980a: clear interrupts\n");
+		break;
+	}
+	return level;
+}
+
+/*****************************************************************************/
+
+/*
+    Memory read:
+    Clock cycles: 4 + 2W, W = number of wait states
+*/
+void tms9980a_device::mem_read()
+{
+	UINT8 value;
+	if (m_lowbyte)
+	{
+		value = m_prgspace->read_byte((m_address & m_prgaddr_mask) | 1);
+		m_current_value = m_current_value | (value & 0x00ff);
+		if (VERBOSE>7) LOG("tms9980a: memory read low byte %04x -> complete word %04x\n", (m_address & m_prgaddr_mask) | 1, m_current_value);
+		m_lowbyte = false;
+	}
+	else
+	{
+		value = m_prgspace->read_byte(m_address & 0x3ffe);
+		if (VERBOSE>7) LOG("tms9980a: memory read high byte %04x -> %02x\n", m_address & m_prgaddr_mask, value);
+		m_current_value = (value << 8) & 0xff00;
+		m_lowbyte = true;
+		m_pass = 2;			// make the CPU visit this method once more
+	}
+	pulse_clock(2);
+	m_check_ready = true;
+}
+
+void tms9980a_device::mem_write()
+{
+	if (m_lowbyte)
+	{
+		m_prgspace->write_byte((m_address & 0x3ffe) | 1, m_current_value & 0xff);
+		if (VERBOSE>7) LOG("tms9980a: memory write low byte %04x <- %02x\n", (m_address & m_prgaddr_mask) | 1, m_current_value & 0xff);
+		m_lowbyte = false;
+	}
+	else
+	{
+		m_prgspace->write_byte(m_address & 0x3ffe, (m_current_value >> 8)&0xff);
+		if (VERBOSE>7) LOG("tms9980a: memory write high byte %04x <- %02x\n", m_address & m_prgaddr_mask, (m_current_value >> 8)&0xff);
+		m_lowbyte = true;
+		m_pass = 2;			// make the CPU visit this method once more
+	}
+	pulse_clock(2);
+	m_check_ready = true;
+}
+
+void tms9980a_device::acquire_instruction()
+{
+	if (!m_lowbyte)
+	{
+		m_iaq_line(ASSERT_LINE);
+		m_address = PC;
+		m_first_cycle = m_icount;
+		mem_read();
+	}
+	else
+	{
+		mem_read();
+		decode(m_current_value);
+		if (VERBOSE>3) LOG("tms9980a: ===== Next operation %04x (%s) at %04x =====\n", IR, opname[m_command], PC);
+		debugger_instruction_hook(this, PC);
+		PC = (PC + 2) & 0xfffe & m_prgaddr_mask;
+	}
+	// IAQ will be cleared in the main loop
+}
+
+/**************************************************************************/
+UINT32 tms9980a_device::execute_min_cycles() const
+{
+	return 2;
+}
+
+// TODO: Compute this value, just a wild guess for the average
+UINT32 tms9980a_device::execute_max_cycles() const
+{
+	return 10;
+}
+
+UINT32 tms9980a_device::execute_input_lines() const
+{
+	return 1;
+}
+
+// clocks to cycles, cycles to clocks = id
+// execute_default_irq_vector = 0
+// execute_burn = nop
+
+// device_disasm_interface overrides
+UINT32 tms9980a_device::disasm_min_opcode_bytes() const
+{
+	return 2;
+}
+
+UINT32 tms9980a_device::disasm_max_opcode_bytes() const
+{
+	return 6;
+}
+
+offs_t tms9980a_device::disasm_disassemble(char *buffer, offs_t pc, const UINT8 *oprom, const UINT8 *opram, UINT32 options)
+{
+	return Dasm9900(buffer, pc, TMS9980_ID, oprom, opram);
+}
+
+const device_type TMS9980A = &device_creator<tms9980a_device>;
diff -Nru src-old/emu/cpu/tms9900/tms9980a.h src/emu/cpu/tms9900/tms9980a.h
--- src-old/emu/cpu/tms9900/tms9980a.h	1970-01-01 01:00:00.000000000 +0100
+++ src/emu/cpu/tms9900/tms9980a.h	2012-06-14 17:52:32.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+    TMS9980A.
+
+    See tms9980a.c and tms9900.c for documentation
+*/
+
+#ifndef __TMS9980A_H__
+#define __TMS9980A_H__
+
+#include "emu.h"
+#include "debugger.h"
+#include "tms9900.h"
+
+#define MCFG_TMS9980A_ADD(_tag, _device, _clock, _prgmap, _iomap, _config)		\
+	MCFG_DEVICE_ADD(_tag, _device, _clock )		\
+	MCFG_DEVICE_PROGRAM_MAP(_prgmap)			\
+	MCFG_DEVICE_IO_MAP(_iomap)					\
+	MCFG_DEVICE_CONFIG(_config)
+
+#define TMS9980A_CONFIG(name) \
+	const tms9900_config(name) =
+
+
+class tms9980a_device : public tms99xx_device
+{
+public:
+	tms9980a_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+protected:
+	void		mem_read(void);
+	void		mem_write(void);
+	void		acquire_instruction(void);
+
+	UINT16		read_workspace_register_debug(int reg);
+	void		write_workspace_register_debug(int reg, UINT16 data);
+
+	UINT32		execute_min_cycles() const;
+	UINT32		execute_max_cycles() const;
+	UINT32		execute_input_lines() const;
+	void		execute_set_input(int irqline, int state);
+
+	UINT32		disasm_min_opcode_bytes() const;
+	UINT32		disasm_max_opcode_bytes() const;
+	offs_t		disasm_disassemble(char *buffer, offs_t pc, const UINT8 *oprom, const UINT8 *opram, UINT32 options);
+	address_space_config	m_program_config80;
+	address_space_config	m_io_config80;
+
+	int 		get_intlevel(int state);
+};
+
+// device type definition
+extern const device_type TMS9980A;
+
+#endif /* __TMS9995_H__ */
diff -Nru src-old/emu/cpu/upd7810/7810ops.c src/emu/cpu/upd7810/7810ops.c
--- src-old/emu/cpu/upd7810/7810ops.c	2011-06-01 16:55:37.000000000 +0200
+++ src/emu/cpu/upd7810/7810ops.c	2012-06-29 22:21:16.000000000 +0200
@@ -6806,7 +6806,7 @@
 
 	RDOPARG( imm );
 	tmp = V + imm + (PSW & CY);
-	ZHC_SUB( tmp, V, (PSW & CY) );
+	ZHC_ADD( tmp, V, (PSW & CY) );
 	V = tmp;
 }
 
@@ -6817,7 +6817,7 @@
 
 	RDOPARG( imm );
 	tmp = A + imm + (PSW & CY);
-	ZHC_SUB( tmp, A, (PSW & CY) );
+	ZHC_ADD( tmp, A, (PSW & CY) );
 	A = tmp;
 }
 
@@ -6828,7 +6828,7 @@
 
 	RDOPARG( imm );
 	tmp = B + imm + (PSW & CY);
-	ZHC_SUB( tmp, B, (PSW & CY) );
+	ZHC_ADD( tmp, B, (PSW & CY) );
 	B = tmp;
 }
 
@@ -6839,7 +6839,7 @@
 
 	RDOPARG( imm );
 	tmp = C + imm + (PSW & CY);
-	ZHC_SUB( tmp, C, (PSW & CY) );
+	ZHC_ADD( tmp, C, (PSW & CY) );
 	C = tmp;
 }
 
@@ -6850,7 +6850,7 @@
 
 	RDOPARG( imm );
 	tmp = D + imm + (PSW & CY);
-	ZHC_SUB( tmp, D, (PSW & CY) );
+	ZHC_ADD( tmp, D, (PSW & CY) );
 	D = tmp;
 }
 
@@ -6861,7 +6861,7 @@
 
 	RDOPARG( imm );
 	tmp = E + imm + (PSW & CY);
-	ZHC_SUB( tmp, E, (PSW & CY) );
+	ZHC_ADD( tmp, E, (PSW & CY) );
 	E = tmp;
 }
 
@@ -6872,7 +6872,7 @@
 
 	RDOPARG( imm );
 	tmp = H + imm + (PSW & CY);
-	ZHC_SUB( tmp, H, (PSW & CY) );
+	ZHC_ADD( tmp, H, (PSW & CY) );
 	H = tmp;
 }
 
@@ -6883,7 +6883,7 @@
 
 	RDOPARG( imm );
 	tmp = L + imm + (PSW & CY);
-	ZHC_SUB( tmp, L, (PSW & CY) );
+	ZHC_ADD( tmp, L, (PSW & CY) );
 	L = tmp;
 }
 
@@ -8822,7 +8822,8 @@
 /* 61: 0110 0001 */
 static void DAA(upd7810_state *cpustate)
 {
-	UINT8 l = A & 0x0f, h = A >> 4, tmp, adj = 0x00;
+	UINT8 l = A & 0x0f, h = A >> 4, tmp, adj = 0x00, old_cy = PSW & CY;
+
 	if (0 == (PSW & HC))
 	{
 		if (l < 10)
@@ -8848,6 +8849,7 @@
 	}
 	tmp = A + adj;
 	ZHC_ADD( tmp, A, PSW & CY );
+	PSW |= old_cy;
 	A = tmp;
 }
 
diff -Nru src-old/emu/drivers/xtal.h src/emu/drivers/xtal.h
--- src-old/emu/drivers/xtal.h	2012-06-10 10:25:30.000000000 +0200
+++ src/emu/drivers/xtal.h	2012-06-26 19:51:08.000000000 +0200
@@ -193,6 +193,7 @@
 	XTAL_52_832MHz		= 52832000, 	/* Wang PC TIG video controller */
 	XTAL_53_693175MHz	= 53693175,		/* PSX-based h/w, Sony ZN1-2-based */
 	XTAL_54MHz  		= 54000000,		/* Taito JC */
+	XTAL_55MHz  		= 55000000,		/* Eolith Vega */
 	XTAL_57_2727MHz 	= 57272727,		/* Psikyo SH2 with /2 divider */
 	XTAL_60MHz  		= 60000000,
 	XTAL_61_44MHz		= 61440000,		/* dkong */
diff -Nru src-old/emu/ioport.c src/emu/ioport.c
--- src-old/emu/ioport.c	2012-05-21 08:24:12.000000000 +0200
+++ src/emu/ioport.c	2012-07-02 09:06:11.000000000 +0200
@@ -2474,12 +2474,6 @@
 
 	// hook for MESS's natural keyboard support
 	manager().natkeyboard().frame_update(*this, m_live->digital);
-
-	// call device line write handlers
-	ioport_value newvalue = read();
-	for (dynamic_field *dynfield = m_live->writelist.first(); dynfield != NULL; dynfield = dynfield->next())
-		if (dynfield->field().type() != IPT_OUTPUT)
-			dynfield->write(newvalue);
 }
 
 
@@ -2652,6 +2646,26 @@
 			mame_printf_error("Input port errors:\n%s", errors.cstr());
 	}
 
+	// renumber player numbers for controller ports
+	int player_offset = 0;
+	for (device_t *device = iter.first(); device != NULL; device = iter.next())
+	{
+		int players = 0;
+		for (ioport_port *port = first_port(); port != NULL; port = port->next())
+		{
+			if (&port->device()==device)
+			{
+				for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+					if (field->type_class()==INPUT_CLASS_CONTROLLER)
+					{
+						if (players < field->player() + 1) players = field->player() + 1;
+						field->set_player(field->player() + player_offset);
+					}
+			}
+		}
+		player_offset += players;
+	}
+
 	// allocate live structures to mirror the configuration
 	for (ioport_port *port = first_port(); port != NULL; port = port->next())
 		port->init_live_state();
@@ -3045,6 +3059,12 @@
 		// handle playback/record
 		playback_port(*port);
 		record_port(*port);
+
+		// call device line write handlers
+		ioport_value newvalue = port->read();
+		for (dynamic_field *dynfield = port->live().writelist.first(); dynfield != NULL; dynfield = dynfield->next())
+			if (dynfield->field().type() != IPT_OUTPUT)
+				dynfield->write(newvalue);
 	}
 
 g_profiler.stop();
diff -Nru src-old/emu/ioport.h src/emu/ioport.h
--- src-old/emu/ioport.h	2012-05-21 08:24:12.000000000 +0200
+++ src/emu/ioport.h	2012-06-15 08:42:35.000000000 +0200
@@ -1077,6 +1077,7 @@
 	// setters
 	void set_crosshair_scale(double scale) { m_crosshair_scale = scale; }
 	void set_crosshair_offset(double offset) { m_crosshair_offset = offset; }
+	void set_player(UINT8 player) { m_player = player; }
 
 	// derived getters
 	ioport_type_class type_class() const;
diff -Nru src-old/emu/machine/pci.c src/emu/machine/pci.c
--- src-old/emu/machine/pci.c	2011-04-30 07:12:28.000000000 +0200
+++ src/emu/machine/pci.c	2012-07-02 09:06:11.000000000 +0200
@@ -70,50 +70,41 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "devconv.h"
 #include "machine/pci.h"
 
 #define LOG_PCI	0
 
-typedef struct _pci_bus_state pci_bus_state;
-struct _pci_bus_state
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
+
+const device_type PCI_BUS_LEGACY = &device_creator<pci_bus_legacy_device>;
+
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+//-------------------------------------------------
+//  pci_bus_legacy_device - constructor
+//-------------------------------------------------
+pci_bus_legacy_device::pci_bus_legacy_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock) :
+        device_t(mconfig, PCI_BUS, "PCI Bus", tag, owner, clock),
+		m_father(NULL)
 {
-	device_t *	busdevice;
-	const pci_bus_config *	config;
-	device_t *	device[32];
-	pci_bus_state *		siblings[8];
-	UINT8				siblings_busnum[8];
-	int					siblings_count;
-	offs_t					address;
-	INT8					devicenum; // device number we are addressing
-	INT8					busnum; // pci bus number we are addressing
-	pci_bus_state *		busnumaddr; // pci bus we are addressing
-};
-
-
+	for (int i = 0; i < ARRAY_LENGTH(m_devtag); i++) {
+		m_devtag[i]= NULL;
+		m_read_callback[i] = NULL;
+		m_write_callback[i] = NULL;
+	}
+	m_siblings_count = 0;
+}
 
 /***************************************************************************
     INLINE FUNCTIONS
 ***************************************************************************/
 
-/*-------------------------------------------------
-    get_safe_token - makes sure that the passed
-    in device is, in fact, a PCI bus
--------------------------------------------------*/
-
-INLINE pci_bus_state *get_safe_token(device_t *device)
+READ32_MEMBER( pci_bus_legacy_device::read )
 {
-	assert(device != NULL);
-	assert(device->type() == PCI_BUS);
-
-	return (pci_bus_state *)downcast<legacy_device_base *>(device)->token();
-}
-
-
-
-READ32_DEVICE_HANDLER( pci_32le_r )
-{
-	pci_bus_state *pcibus = get_safe_token(device);
 	UINT32 result = 0xffffffff;
 	int function, reg;
 
@@ -122,43 +113,43 @@
 	switch (offset)
 	{
 		case 0:
-			result = pcibus->address;
+			result = m_address;
 			break;
 
 		case 1:
-			if (pcibus->devicenum != -1)
+			if (m_devicenum != -1)
 			{
-				pci_read_func read = pcibus->busnumaddr->config->device[pcibus->devicenum].read_callback;
+				pci_read_func read = m_busnumaddr->m_read_callback[m_devicenum];
 				if (read != NULL)
 				{
-					function = (pcibus->address >> 8) & 0x07;
-					reg = (pcibus->address >> 0) & 0xfc;
-					result = (*read)(pcibus->busnumaddr->busdevice, pcibus->busnumaddr->device[pcibus->devicenum], function, reg, mem_mask);
+					function = (m_address >> 8) & 0x07;
+					reg = (m_address >> 0) & 0xfc;
+					result = (*read)(m_busnumaddr, m_busnumaddr->m_device[m_devicenum], function, reg, mem_mask);
 				}
 			}
 			break;
 	}
 
 	if (LOG_PCI)
-		logerror("pci_32le_r('%s'): offset=%d result=0x%08X\n", device->tag(), offset, result);
+		logerror("read('%s'): offset=%d result=0x%08X\n", tag(), offset, result);
 
 	return result;
 }
 
 
 
-static pci_bus_state *pci_search_bustree(int busnum, int devicenum, pci_bus_state *pcibus)
+pci_bus_legacy_device *pci_bus_legacy_device::pci_search_bustree(int busnum, int devicenum, pci_bus_legacy_device *pcibus)
 {
-int a;
-pci_bus_state *ret;
+	int a;
+	pci_bus_legacy_device *ret;
 
-	if (pcibus->config->busnum == busnum)
+	if (pcibus->m_busnum == busnum)
 	{
 		return pcibus;
 	}
-	for (a = 0; a < pcibus->siblings_count; a++)
+	for (a = 0; a < pcibus->m_siblings_count; a++)
 	{
-		ret = pci_search_bustree(busnum, devicenum, pcibus->siblings[a]);
+		ret = pci_search_bustree(busnum, devicenum, pcibus->m_siblings[a]);
 		if (ret != NULL)
 			return ret;
 	}
@@ -167,50 +158,48 @@
 
 
 
-WRITE32_DEVICE_HANDLER( pci_32le_w )
+WRITE32_MEMBER( pci_bus_legacy_device::write )
 {
-	pci_bus_state *pcibus = get_safe_token(device);
-
 	offset %= 2;
 
 	if (LOG_PCI)
-		logerror("pci_32le_w('%s'): offset=%d data=0x%08X\n", device->tag(), offset, data);
+		logerror("write('%s'): offset=%d data=0x%08X\n", tag(), offset, data);
 
 	switch (offset)
 	{
 		case 0:
-			pcibus->address = data;
+			m_address = data;
 
 			/* lookup current device */
-			if (pcibus->address & 0x80000000)
+			if (m_address & 0x80000000)
 			{
-				int busnum = (pcibus->address >> 16) & 0xff;
-				int devicenum = (pcibus->address >> 11) & 0x1f;
-				pcibus->busnumaddr = pci_search_bustree(busnum, devicenum, pcibus);
-				if (pcibus->busnumaddr != NULL)
+				int busnum = (m_address >> 16) & 0xff;
+				int devicenum = (m_address >> 11) & 0x1f;
+				m_busnumaddr = pci_search_bustree(busnum, devicenum, this);
+				if (m_busnumaddr != NULL)
 				{
-					pcibus->busnum = busnum;
-					pcibus->devicenum = devicenum;
+					m_busnumber = busnum;
+					m_devicenum = devicenum;
 				}
 				else
-					pcibus->devicenum = -1;
+					m_devicenum = -1;
 				if (LOG_PCI)
 					logerror("  bus:%d device:%d\n", busnum, devicenum);
 			}
 			break;
 
 		case 1:
-			if (pcibus->devicenum != -1)
+			if (m_devicenum != -1)
 			{
-				pci_write_func write = pcibus->busnumaddr->config->device[pcibus->devicenum].write_callback;
+				pci_write_func write = m_busnumaddr->m_write_callback[m_devicenum];
 				if (write != NULL)
 				{
-					int function = (pcibus->address >> 8) & 0x07;
-					int reg = (pcibus->address >> 0) & 0xfc;
-					(*write)(pcibus->busnumaddr->busdevice, pcibus->busnumaddr->device[pcibus->devicenum], function, reg, data, mem_mask);
+					int function = (m_address >> 8) & 0x07;
+					int reg = (m_address >> 0) & 0xfc;
+					(*write)(m_busnumaddr, m_busnumaddr->m_device[m_devicenum], function, reg, data, mem_mask);
 				}
 				if (LOG_PCI)
-					logerror("  function:%d register:%d\n", (pcibus->address >> 8) & 0x07, (pcibus->address >> 0) & 0xfc);
+					logerror("  function:%d register:%d\n", (m_address >> 8) & 0x07, (m_address >> 0) & 0xfc);
 			}
 			break;
 	}
@@ -218,118 +207,343 @@
 
 
 
-READ64_DEVICE_HANDLER(pci_64be_r) { return read64be_with_32le_device_handler(pci_32le_r, device, offset, mem_mask); }
-WRITE64_DEVICE_HANDLER(pci_64be_w) { write64be_with_32le_device_handler(pci_32le_w, device, offset, data, mem_mask); }
+READ64_MEMBER(pci_bus_legacy_device::read_64be)
+{
+	UINT64 result = 0;
+	mem_mask = FLIPENDIAN_INT64(mem_mask);
+	if (ACCESSING_BITS_0_31)
+		result |= (UINT64)read(space, offset * 2 + 0, mem_mask >> 0) << 0;
+	if (ACCESSING_BITS_32_63)
+		result |= (UINT64)read(space, offset * 2 + 1, mem_mask >> 32) << 32;
+	return FLIPENDIAN_INT64(result);
+}
+
+WRITE64_MEMBER(pci_bus_legacy_device::write_64be)
+{
+	data = FLIPENDIAN_INT64(data);
+	mem_mask = FLIPENDIAN_INT64(mem_mask);
+	if (ACCESSING_BITS_0_31)
+		write(space, offset * 2 + 0, data >> 0, mem_mask >> 0);
+	if (ACCESSING_BITS_32_63)
+		write(space, offset * 2 + 1, data >> 32, mem_mask >> 32);
+}
 
 
-int pci_add_sibling( running_machine &machine, char *pcitag, char *sibling )
+void pci_bus_legacy_device::add_sibling(pci_bus_legacy_device *sibling, int busnum)
 {
-	device_t *device1 = machine.device(pcitag);
-	device_t *device2 = machine.device(sibling);
-	pci_bus_state *pcibus1 = get_safe_token(device1);
-	pci_bus_state *pcibus2 = get_safe_token(device2);
-	pci_bus_config *config2;
-
-	if ((device1 == NULL) || (device2 == NULL) || (pcibus1 == NULL) || (pcibus2 == NULL))
-		return 0;
-	if (pcibus1->siblings_count == 8)
-		return 0;
-	config2 = (pci_bus_config *)downcast<const legacy_device_base *>(device2)->inline_config();
-	pcibus1->siblings[pcibus1->siblings_count] = get_safe_token(device2);
-	pcibus1->siblings_busnum[pcibus1->siblings_count] = config2->busnum;
-	pcibus1->siblings_count++;
-	return 1;
+	m_siblings[m_siblings_count] = sibling;
+	m_siblings_busnum[m_siblings_count] = busnum;
+	m_siblings_count++;
 }
 
 
+//-------------------------------------------------
+//  device_post_load - handle updating after a
+//  restore
+//-------------------------------------------------
+
+void pci_bus_legacy_device::device_post_load()
+{
+	if (m_devicenum != -1)
+	{
+		m_busnumaddr = pci_search_bustree(m_busnumber, m_devicenum, this);
+	}
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void pci_bus_legacy_device::device_start()
+{
+	/* store a pointer back to the device */
+	m_devicenum = -1;
+
+	/* find all our devices */
+	for (int i = 0; i < ARRAY_LENGTH(m_devtag); i++)
+		if (m_devtag[i] != NULL)
+			m_device[i] = machine().device(m_devtag[i]);
+
+	if (m_father != NULL) {
+		pci_bus_legacy_device *father = machine().device<pci_bus_legacy_device>(m_father);
+		if (father)
+			father->add_sibling(this, m_busnum);
+	}
+
+	/* register pci states */
+	save_item(NAME(m_address));
+	save_item(NAME(m_devicenum));
+	save_item(NAME(m_busnum));
+}
+
+
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void pci_bus_legacy_device::device_reset()
+{
+	/* reset the drive state */
+	m_devicenum = -1;
+	m_address = 0;
+}
+
+
+// NEW IMPLEMENTATION
+
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
+
+const device_type PCI_BUS = &device_creator<pci_bus_device>;
+
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+//-------------------------------------------------
+//  pci_bus_device - constructor
+//-------------------------------------------------
+pci_bus_device::pci_bus_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock) :
+        device_t(mconfig, PCI_BUS, "PCI Bus", tag, owner, clock),
+		m_father(NULL)
+{
+	for (int i = 0; i < ARRAY_LENGTH(m_devtag); i++) {
+		m_devtag[i]= NULL;
+	}
+	m_siblings_count = 0;
+}
+
 /***************************************************************************
-    DEVICE INTERFACE
+    INLINE FUNCTIONS
 ***************************************************************************/
 
+READ32_MEMBER( pci_bus_device::read )
+{
+	UINT32 result = 0xffffffff;
+	int function, reg;
+
+	offset %= 2;
+
+	switch (offset)
+	{
+		case 0:
+			result = m_address;
+			break;
+
+		case 1:
+			if (m_devicenum != -1)
+			{
+				if (m_busnumaddr->m_device[m_devicenum] != NULL)
+				{
+					function = (m_address >> 8) & 0x07;
+					reg = (m_address >> 0) & 0xfc;
+					result = m_busnumaddr->m_device[m_devicenum]->pci_read(m_busnumaddr, function, reg, mem_mask);
+				}
+			}
+			break;
+	}
+
+	if (LOG_PCI)
+		logerror("read('%s'): offset=%d result=0x%08X\n", tag(), offset, result);
+
+	return result;
+}
+
+
+
+pci_bus_device *pci_bus_device::pci_search_bustree(int busnum, int devicenum, pci_bus_device *pcibus)
+{
+	int a;
+	pci_bus_device *ret;
+
+	if (pcibus->m_busnum == busnum)
+	{
+		return pcibus;
+	}
+	for (a = 0; a < pcibus->m_siblings_count; a++)
+	{
+		ret = pci_search_bustree(busnum, devicenum, pcibus->m_siblings[a]);
+		if (ret != NULL)
+			return ret;
+	}
+	return NULL;
+}
 
-static void pci_bus_postload(pci_bus_state *pcibus)
+
+
+WRITE32_MEMBER( pci_bus_device::write )
 {
-	if (pcibus->devicenum != -1)
+	offset %= 2;
+
+	if (LOG_PCI)
+		logerror("write('%s'): offset=%d data=0x%08X\n", tag(), offset, data);
+
+	switch (offset)
 	{
-		pcibus->busnumaddr = pci_search_bustree(pcibus->busnum, pcibus->devicenum, pcibus);
+		case 0:
+			m_address = data;
+
+			/* lookup current device */
+			if (m_address & 0x80000000)
+			{
+				int busnum = (m_address >> 16) & 0xff;
+				int devicenum = (m_address >> 11) & 0x1f;
+				m_busnumaddr = pci_search_bustree(busnum, devicenum, this);
+				if (m_busnumaddr != NULL)
+				{
+					m_busnumber = busnum;
+					m_devicenum = devicenum;
+				}
+				else
+					m_devicenum = -1;
+				if (LOG_PCI)
+					logerror("  bus:%d device:%d\n", busnum, devicenum);
+			}
+			break;
+
+		case 1:
+			if (m_devicenum != -1)
+			{
+				if (m_busnumaddr->m_device[m_devicenum] != NULL)
+				{
+					int function = (m_address >> 8) & 0x07;
+					int reg = (m_address >> 0) & 0xfc;
+					m_busnumaddr->m_device[m_devicenum]->pci_write(m_busnumaddr, function, reg, data, mem_mask);
+				}
+				if (LOG_PCI)
+					logerror("  function:%d register:%d\n", (m_address >> 8) & 0x07, (m_address >> 0) & 0xfc);
+			}
+			break;
 	}
 }
 
 
-/*-------------------------------------------------
-    device start callback
--------------------------------------------------*/
 
-static DEVICE_START( pci_bus )
+READ64_MEMBER(pci_bus_device::read_64be)
 {
-	pci_bus_state *pcibus = get_safe_token(device);
-	int devicenum;
+	UINT64 result = 0;
+	mem_mask = FLIPENDIAN_INT64(mem_mask);
+	if (ACCESSING_BITS_0_31)
+		result |= (UINT64)read(space, offset * 2 + 0, mem_mask >> 0) << 0;
+	if (ACCESSING_BITS_32_63)
+		result |= (UINT64)read(space, offset * 2 + 1, mem_mask >> 32) << 32;
+	return FLIPENDIAN_INT64(result);
+}
 
-	/* validate some basic stuff */
-	assert(device != NULL);
-	assert(device->static_config() == NULL);
-	assert(downcast<const legacy_device_base *>(device)->inline_config() != NULL);
+WRITE64_MEMBER(pci_bus_device::write_64be)
+{
+	data = FLIPENDIAN_INT64(data);
+	mem_mask = FLIPENDIAN_INT64(mem_mask);
+	if (ACCESSING_BITS_0_31)
+		write(space, offset * 2 + 0, data >> 0, mem_mask >> 0);
+	if (ACCESSING_BITS_32_63)
+		write(space, offset * 2 + 1, data >> 32, mem_mask >> 32);
+}
+
+
+void pci_bus_device::add_sibling(pci_bus_device *sibling, int busnum)
+{
+	m_siblings[m_siblings_count] = sibling;
+	m_siblings_busnum[m_siblings_count] = busnum;
+	m_siblings_count++;
+}
+
+
+//-------------------------------------------------
+//  device_post_load - handle updating after a
+//  restore
+//-------------------------------------------------
+
+void pci_bus_device::device_post_load()
+{
+	if (m_devicenum != -1)
+	{
+		m_busnumaddr = pci_search_bustree(m_busnumber, m_devicenum, this);
+	}
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
 
+void pci_bus_device::device_start()
+{
 	/* store a pointer back to the device */
-	pcibus->config = (const pci_bus_config *)downcast<const legacy_device_base *>(device)->inline_config();
-	pcibus->busdevice = device;
-	pcibus->devicenum = -1;
+	m_devicenum = -1;
 
+	char id[3];
 	/* find all our devices */
-	for (devicenum = 0; devicenum < ARRAY_LENGTH(pcibus->device); devicenum++)
-		if (pcibus->config->device[devicenum].devtag != NULL)
-			pcibus->device[devicenum] = device->machine().device(pcibus->config->device[devicenum].devtag);
+	for (int i = 0; i < ARRAY_LENGTH(m_devtag); i++)
+	{
+		sprintf(id, "%d", i);
+		pci_connector *conn = downcast<pci_connector *>(subdevice(id));
+		if (conn!=NULL)
+			m_device[i] = conn->get_device();
+		else
+			m_device[i] = NULL;
+	}
 
-	if (pcibus->config->father != NULL)
-		pci_add_sibling(device->machine(), (char *)pcibus->config->father, (char *)device->tag());
+	if (m_father != NULL) {
+		pci_bus_device *father = machine().device<pci_bus_device>(m_father);
+		if (father)
+			father->add_sibling(this, m_busnum);
+	}
 
 	/* register pci states */
-	device->save_item(NAME(pcibus->address));
-	device->save_item(NAME(pcibus->devicenum));
-	device->save_item(NAME(pcibus->busnum));
-
-	device->machine().save().register_postload(save_prepost_delegate(FUNC(pci_bus_postload), pcibus));
+	save_item(NAME(m_address));
+	save_item(NAME(m_devicenum));
+	save_item(NAME(m_busnum));
 }
 
 
-/*-------------------------------------------------
-    device reset callback
--------------------------------------------------*/
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
 
-static DEVICE_RESET( pci_bus )
+void pci_bus_device::device_reset()
 {
-	pci_bus_state *pcibus = get_safe_token(device);
-
 	/* reset the drive state */
-	pcibus->devicenum = -1;
-	pcibus->address = 0;
+	m_devicenum = -1;
+	m_address = 0;
 }
 
+//-------------------------------------------------
+//  pci_device_interface - constructor
+//-------------------------------------------------
+
+pci_device_interface::pci_device_interface(const machine_config &mconfig, device_t &device)
+	: device_slot_card_interface(mconfig, device)
+{
+}
 
-/*-------------------------------------------------
-    device get info callback
--------------------------------------------------*/
+//-------------------------------------------------
+//  ~pci_device_interface - destructor
+//-------------------------------------------------
 
-DEVICE_GET_INFO( pci_bus )
+pci_device_interface::~pci_device_interface()
 {
-	switch (state)
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:			info->i = sizeof(pci_bus_state);		break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:	info->i = sizeof(pci_bus_config);		break;
+}
 
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:					info->start = DEVICE_START_NAME(pci_bus); break;
-		case DEVINFO_FCT_RESET:					info->reset = DEVICE_RESET_NAME(pci_bus);break;
 
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:					strcpy(info->s, "PCI Bus");				break;
-		case DEVINFO_STR_FAMILY:				strcpy(info->s, "Peripherial Bus");		break;
-		case DEVINFO_STR_VERSION:				strcpy(info->s, "1.0");					break;
-		case DEVINFO_STR_SOURCE_FILE:			strcpy(info->s, __FILE__);				break;
-		case DEVINFO_STR_CREDITS:				strcpy(info->s, "Copyright Nicola Salmoria and the MAME Team"); break;
-	}
+const device_type PCI_CONNECTOR = &device_creator<pci_connector>;
+
+
+pci_connector::pci_connector(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock) :
+	device_t(mconfig, PCI_CONNECTOR, "PCI device connector abstraction", tag, owner, clock),
+	device_slot_interface(mconfig, *this)
+{
 }
 
+pci_connector::~pci_connector()
+{
+}
 
-DEFINE_LEGACY_DEVICE(PCI_BUS, pci_bus);
+void pci_connector::device_start()
+{
+}
+
+pci_device_interface *pci_connector::get_device()
+{
+	return dynamic_cast<pci_device_interface *>(get_card_device());
+}
diff -Nru src-old/emu/machine/pci.h src/emu/machine/pci.h
--- src-old/emu/machine/pci.h	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/machine/pci.h	2012-07-02 09:06:11.000000000 +0200
@@ -9,65 +9,177 @@
 #ifndef PCI_H
 #define PCI_H
 
-#include "devlegcy.h"
-
-
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
 
 typedef UINT32 (*pci_read_func)(device_t *pcibus, device_t *device, int function, int reg, UINT32 mem_mask);
 typedef void (*pci_write_func)(device_t *pcibus, device_t *device, int function, int reg, UINT32 data, UINT32 mem_mask);
 
-typedef struct _pci_device_entry pci_device_entry;
-struct _pci_device_entry
-{
-	const char *		devtag;
-	pci_read_func		read_callback;
-	pci_write_func		write_callback;
-};
+// ======================> pci_bus_legacy_device
 
-typedef struct _pci_bus_config pci_bus_config;
-struct _pci_bus_config
+class pci_bus_legacy_device :  public device_t
 {
-	UINT8				busnum;
-	pci_device_entry	device[32];
-	const char *		father;
+public:
+    // construction/destruction
+    pci_bus_legacy_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	DECLARE_READ32_MEMBER( read );
+	DECLARE_WRITE32_MEMBER( write );
+
+	DECLARE_READ64_MEMBER( read_64be );
+	DECLARE_WRITE64_MEMBER( write_64be );
+
+	void set_busnum(int busnum) { m_busnum = busnum; }
+	void set_father(const char *father) { m_father = father; }
+	void set_device(int num, const char *tag, pci_read_func read_func, pci_write_func write_func) {
+		m_devtag[num] = tag; m_read_callback[num] = read_func; m_write_callback[num] = write_func; }
+
+	pci_bus_legacy_device *pci_search_bustree(int busnum, int devicenum, pci_bus_legacy_device *pcibus);
+	void add_sibling(pci_bus_legacy_device *sibling, int busnum);
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+	virtual void device_reset();
+    virtual void device_post_load();
+
+private:
+	UINT8				m_busnum;
+	const char *		m_devtag[32];
+	pci_read_func		m_read_callback[32];
+	pci_write_func		m_write_callback[32];
+	const char *		m_father;
+	device_t *			m_device[32];
+	pci_bus_legacy_device *	m_siblings[8];
+	UINT8				m_siblings_busnum[8];
+	int					m_siblings_count;
+
+	offs_t				m_address;
+	INT8				m_devicenum; // device number we are addressing
+	INT8				m_busnumber; // pci bus number we are addressing
+	pci_bus_legacy_device *	m_busnumaddr; // pci bus we are addressing
 };
 
+// device type definition
+extern const device_type PCI_BUS_LEGACY;
 
 
 /***************************************************************************
     DEVICE CONFIGURATION MACROS
 ***************************************************************************/
 
-#define MCFG_PCI_BUS_ADD(_tag, _busnum) \
-	MCFG_DEVICE_ADD(_tag, PCI_BUS, 0) \
-	MCFG_DEVICE_CONFIG_DATA32(pci_bus_config, busnum, _busnum)
+#define MCFG_PCI_BUS_LEGACY_ADD(_tag, _busnum) \
+	MCFG_DEVICE_ADD(_tag, PCI_BUS_LEGACY, 0) \
+	downcast<pci_bus_legacy_device *>(device)->set_busnum(_busnum); \
 
-#define MCFG_PCI_BUS_DEVICE(_devnum, _devtag, _configread, _configwrite) \
-	MCFG_DEVICE_CONFIG_DATAPTR_ARRAY_MEMBER(pci_bus_config, device, _devnum, pci_device_entry, devtag, _devtag) \
-	MCFG_DEVICE_CONFIG_DATAPTR_ARRAY_MEMBER(pci_bus_config, device, _devnum, pci_device_entry, read_callback, _configread) \
-	MCFG_DEVICE_CONFIG_DATAPTR_ARRAY_MEMBER(pci_bus_config, device, _devnum, pci_device_entry, write_callback, _configwrite)
+#define MCFG_PCI_BUS_LEGACY_DEVICE(_devnum, _devtag, _configread, _configwrite) \
+	downcast<pci_bus_legacy_device *>(device)->set_device(_devnum, _devtag,_configread,_configwrite); \
 
-#define MCFG_PCI_BUS_SIBLING(_father_tag) \
-	MCFG_DEVICE_CONFIG_DATAPTR(pci_bus_config, father, _father_tag)
+#define MCFG_PCI_BUS_LEGACY_SIBLING(_father_tag) \
+	downcast<pci_bus_legacy_device *>(device)->set_father(_father_tag); \
+
+
+// NEW IMPLEMENTATION
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+class pci_bus_device;
+
+// ======================> pci_device_interface
+
+class pci_device_interface :  public device_slot_card_interface
+{
+public:
+    // construction/destruction
+	pci_device_interface(const machine_config &mconfig, device_t &device);
+	virtual ~pci_device_interface();
+
+	virtual UINT32 pci_read(pci_bus_device *pcibus, int function, int offset, UINT32 mem_mask) = 0;
+	virtual void pci_write(pci_bus_device *pcibus, int function, int offset, UINT32 data, UINT32 mem_mask) = 0;
+private:
+};
+
+class pci_connector: public device_t,
+				     public device_slot_interface
+{
+public:
+	pci_connector(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+	virtual ~pci_connector();
+
+	pci_device_interface *get_device();
+
+protected:
+	virtual void device_start();
+};
+
+extern const device_type PCI_CONNECTOR;
+
+// ======================> pci_bus_device
+
+class pci_bus_device :  public device_t
+{
+public:
+    // construction/destruction
+    pci_bus_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	DECLARE_READ32_MEMBER( read );
+	DECLARE_WRITE32_MEMBER( write );
+
+	DECLARE_READ64_MEMBER( read_64be );
+	DECLARE_WRITE64_MEMBER( write_64be );
+
+	void set_busnum(int busnum) { m_busnum = busnum; }
+	void set_father(const char *father) { m_father = father; }
+	void set_device(int num, const char *tag) {
+		m_devtag[num] = tag; }
+
+	pci_bus_device *pci_search_bustree(int busnum, int devicenum, pci_bus_device *pcibus);
+	void add_sibling(pci_bus_device *sibling, int busnum);
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+	virtual void device_reset();
+    virtual void device_post_load();
+
+private:
+	UINT8				m_busnum;
+
+	const char *		m_devtag[32];
+	pci_device_interface *m_device[32];
+
+	const char *		m_father;
+	pci_bus_device *	m_siblings[8];
+	UINT8				m_siblings_busnum[8];
+	int					m_siblings_count;
+
+	offs_t				m_address;
+	INT8				m_devicenum; // device number we are addressing
+	INT8				m_busnumber; // pci bus number we are addressing
+	pci_bus_device *	m_busnumaddr; // pci bus we are addressing
+};
+
+// device type definition
+extern const device_type PCI_BUS;
 
 
 /***************************************************************************
-    FUNCTION PROTOTYPES
+    DEVICE CONFIGURATION MACROS
 ***************************************************************************/
 
-READ32_DEVICE_HANDLER( pci_32le_r );
-WRITE32_DEVICE_HANDLER( pci_32le_w );
+#define MCFG_PCI_BUS_ADD(_tag, _busnum) \
+	MCFG_DEVICE_ADD(_tag, PCI_BUS, 0) \
+	downcast<pci_bus_device *>(device)->set_busnum(_busnum); \
 
-READ64_DEVICE_HANDLER( pci_64be_r );
-WRITE64_DEVICE_HANDLER( pci_64be_w );
+#define MCFG_PCI_BUS_DEVICE(_tag, _slot_intf, _def_slot, _def_inp, _def_config, _def_clock, _fixed) \
+	MCFG_DEVICE_ADD(_tag, PCI_CONNECTOR, 0) \
+	MCFG_DEVICE_SLOT_INTERFACE_FULL(_slot_intf, _def_slot, _def_inp, _def_config, _def_clock, _fixed)
 
-int pci_add_sibling( running_machine &machine, char *pcitag, char *sibling );
+#define MCFG_PCI_BUS_SIBLING(_father_tag) \
+	downcast<pci_bus_device *>(device)->set_father(_father_tag); \
 
-/* ----- device interface ----- */
 
-DECLARE_LEGACY_DEVICE(PCI_BUS, pci_bus);
 
 #endif /* PCI_H */
diff -Nru src-old/emu/machine/s3c24xx.c src/emu/machine/s3c24xx.c
--- src-old/emu/machine/s3c24xx.c	2012-01-16 13:06:28.000000000 +0100
+++ src/emu/machine/s3c24xx.c	2012-06-17 17:13:23.000000000 +0200
@@ -1166,36 +1166,41 @@
 	s3c24xx_t *s3c24xx = get_token( device);
 	UINT32 temp;
 	// normal irq
-	temp = (s3c24xx->irq.regs.srcpnd & ~s3c24xx->irq.regs.intmsk) & ~s3c24xx->irq.regs.intmod;
-	if (temp != 0)
+
+	if ((s3c24xx->irq.regs.intpnd == 0) && (s3c24xx->irq.regs.intoffset == 0)) // without this "touryuu" crashes
 	{
-		UINT32 int_type = 0;
-		verboselog( device->machine(), 5, "srcpnd %08X intmsk %08X intmod %08X\n", s3c24xx->irq.regs.srcpnd, s3c24xx->irq.regs.intmsk, s3c24xx->irq.regs.intmod);
-		while ((temp & 1) == 0)
+		temp = (s3c24xx->irq.regs.srcpnd & ~s3c24xx->irq.regs.intmsk) & ~s3c24xx->irq.regs.intmod;
+		if (temp != 0)
 		{
-			int_type++;
-			temp = temp >> 1;
-		}
-		verboselog( device->machine(), 5, "intpnd set bit %d\n", int_type);
-		s3c24xx->irq.regs.intpnd |= (1 << int_type);
-		s3c24xx->irq.regs.intoffset = int_type;
-		if (s3c24xx->irq.line_irq != ASSERT_LINE)
-		{
-			verboselog( device->machine(), 5, "ARM7_IRQ_LINE -> ASSERT_LINE\n");
-			cputag_set_input_line( device->machine(), "maincpu", ARM7_IRQ_LINE, ASSERT_LINE);
-			s3c24xx->irq.line_irq = ASSERT_LINE;
+			UINT32 int_type = 0;
+			verboselog( device->machine(), 5, "srcpnd %08X intmsk %08X intmod %08X\n", s3c24xx->irq.regs.srcpnd, s3c24xx->irq.regs.intmsk, s3c24xx->irq.regs.intmod);
+			while ((temp & 1) == 0)
+			{
+				int_type++;
+				temp = temp >> 1;
+			}
+			verboselog( device->machine(), 5, "intpnd set bit %d\n", int_type);
+			s3c24xx->irq.regs.intpnd |= (1 << int_type);
+			s3c24xx->irq.regs.intoffset = int_type;
+			if (s3c24xx->irq.line_irq != ASSERT_LINE)
+			{
+				verboselog( device->machine(), 5, "ARM7_IRQ_LINE -> ASSERT_LINE\n");
+				cputag_set_input_line( device->machine(), "maincpu", ARM7_IRQ_LINE, ASSERT_LINE);
+				s3c24xx->irq.line_irq = ASSERT_LINE;
+			}
 		}
-	}
-	else
-	{
-		if (s3c24xx->irq.line_irq != CLEAR_LINE)
+		else
 		{
-			verboselog( device->machine(), 5, "srcpnd %08X intmsk %08X intmod %08X\n", s3c24xx->irq.regs.srcpnd, s3c24xx->irq.regs.intmsk, s3c24xx->irq.regs.intmod);
-			verboselog( device->machine(), 5, "ARM7_IRQ_LINE -> CLEAR_LINE\n");
-			cputag_set_input_line( device->machine(), "maincpu", ARM7_IRQ_LINE, CLEAR_LINE);
-			s3c24xx->irq.line_irq = CLEAR_LINE;
+			if (s3c24xx->irq.line_irq != CLEAR_LINE)
+			{
+				verboselog( device->machine(), 5, "srcpnd %08X intmsk %08X intmod %08X\n", s3c24xx->irq.regs.srcpnd, s3c24xx->irq.regs.intmsk, s3c24xx->irq.regs.intmod);
+				verboselog( device->machine(), 5, "ARM7_IRQ_LINE -> CLEAR_LINE\n");
+				cputag_set_input_line( device->machine(), "maincpu", ARM7_IRQ_LINE, CLEAR_LINE);
+				s3c24xx->irq.line_irq = CLEAR_LINE;
+			}
 		}
 	}
+
 	// fast irq
 	temp = (s3c24xx->irq.regs.srcpnd & ~s3c24xx->irq.regs.intmsk) & s3c24xx->irq.regs.intmod;
 	if (temp != 0)
@@ -1330,6 +1335,7 @@
 		{
 			s3c24xx->irq.regs.intpnd = (old_value & ~data); // clear only the bit positions of INTPND corresponding to those set to one in the data
 			s3c24xx->irq.regs.intoffset = 0; // "This bit can be cleared automatically by clearing SRCPND and INTPND."
+			s3c24xx_check_pending_irq( device);
 		}
 		break;
 #if defined(DEVICE_S3C2410) || defined(DEVICE_S3C2440)
diff -Nru src-old/emu/sound/pokey.c src/emu/sound/pokey.c
--- src-old/emu/sound/pokey.c	2012-06-11 10:00:48.000000000 +0200
+++ src/emu/sound/pokey.c	2012-06-23 16:18:47.000000000 +0200
@@ -436,7 +436,7 @@
 		/* do nothing, caused by a forced resync */
 		break;
 	case SYNC_POT:
-		logerror("x %02x \n", (param & 0x20));
+		//logerror("x %02x \n", (param & 0x20));
 		m_ALLPOT |= (param & 0xff);
 		break;
 	case SYNC_SET_IRQST:
diff -Nru src-old/emu/sound/qs1000.c src/emu/sound/qs1000.c
--- src-old/emu/sound/qs1000.c	1970-01-01 01:00:00.000000000 +0100
+++ src/emu/sound/qs1000.c	2012-07-02 09:06:11.000000000 +0200
@@ -0,0 +1,639 @@
+/***************************************************************************
+
+    qs1000.c
+
+    QS1000 device emulator.
+
+****************************************************************************
+
+    The QS1000 is a 32-voice wavetable synthesizer, believed to be based on
+    the OPTi 82C941. It contains an 8051 core, 256b of RAM and an (undumped)
+    internal program ROM. The internal ROM can be bypassed in favour of an
+    external ROM. Commands are issued to the chip via the 8051 serial port.
+
+    The QS1000 can access 24Mb of sample ROM. To reduce demand on the CPU,
+    instrument parameters such as playback rate, envelope and filter values
+    are encoded in ROM and directly accessed by the wavetable engine.
+    There are table entries for every note of every instrument.
+
+    Registers
+    =========
+
+    [200] = Key on/off
+            0 = Key on
+            1 = ?
+            2 = key off
+    [201] = Address byte 0 (LSB)
+    [202] = Address byte 1
+    [203] = Address byte 2
+    [204] = Pitch
+    [205] = Pitch high byte? (Usually 0)
+    [206] = Left volume
+    [207] = Right volume
+    [208] = Volume
+    [209] = ?
+    [20a] = ?
+    [20b] = ?
+    [20c] = ?
+    [20d] = Velocity
+    [20e] = Channel select
+    [20f] = Modulation
+    [210] = Modulation
+    [211] = 0 - Select global registers?
+            3 - Select channel registers?
+
+    Velocity register values for MIDI range 0-127:
+
+    01 01 01 01 01 01 01 02 02 03 03 04 04 05 05 06
+    06 07 07 08 08 09 09 0A 0A 0B 0B 0C 0C 0D 0D 0E
+    0E 0F 10 11 11 12 13 14 14 15 16 17 17 18 19 1A
+    1A 1B 1C 1D 1D 1E 1F 20 20 21 22 23 23 24 25 26
+    26 27 28 29 29 2A 2B 2C 2C 2D 2E 2F 2F 30 31 32
+    35 38 3B 3E 41 44 47 4A 4D 50 4F 51 52 53 54 56
+    57 58 59 5B 5C 5D 5E 60 61 62 63 65 66 67 6A 6B
+    6C 6E 6F 70 71 73 74 75 76 78 79 7A 7B 7D 7E 7F
+
+    (TODO: Other register values)
+
+    This is the sequence of register writes used to play the Iron Fortress credit sound:
+
+    [211] 0     Select global registers?
+    [200] 1     ?
+    [203] d6    Address byte 2
+    [202] a9    Address byte 1
+    [201] 1     Address byte 0
+    [204] 80    Pitch
+    [205] 0     ?
+    [206] 80    Left volume
+    [207] 80    Right volume
+    [208] b3    Volume
+    [209] 0     ?
+    [20a] ff    ?
+    [20b] 0     ?
+    [20c] 0     ?
+    [20d] 78    Velocity
+    [211] 3     Select channel registers
+    [20e] 0     Select channel
+    [200] 0     Key on
+
+
+    Sound Headers
+    =============
+
+    The address registers point to a 6 byte entry in the sound ROM:
+
+    [019be0]
+    097b 397f 1510
+    ^    ^    ^
+    |    |    |
+    |    |    +----- Sound descriptor pointer
+    |    +---------- ?
+    +--------------- Playback frequency (fixed point value representing 24MHz clock periods)
+
+    This in turn points to a 24 byte descriptor:
+
+    [1510]:
+    0 4502D 4508E 45F91 D0 7F 0F 2A 1F 90 00 FF
+    ^ ^     ^     ^     ^  ^  ^  ^  ^  ^  ^  ^
+    | |     |     |     |  |  |  |  |  |  |  |
+    | |     |     |     |  |  |  |  |  |  |  +-- ?
+    | |     |     |     |  |  |  |  |  |  +----- ?
+    | |     |     |     |  |  |  |  |  +-------- ?
+    | |     |     |     |  |  |  |  +----------- ?
+    | |     |     |     |  |  |  +-------------- ?
+    | |     |     |     |  |  +----------------- Bit 7: Format (0:PCM 1:ADPCM)
+    | |     |     |     |  +-------------------- ?
+    | |     |     |     +----------------------- ?
+    | |     |     +----------------------------- Loop end address
+    | |     +----------------------------------- Loop start address
+    | +----------------------------------------- Start address
+    +------------------------------------------- Address most-significant nibble (shared with loop addresses)
+
+    * The unknown parameters are most likely envelope and filter parameters.
+    * Is there a loop flag or do sounds loop indefinitely until stopped?
+
+
+    TODO:
+    * Looping is currently disabled
+    * Figure out unknown sound header parameters
+    * Figure out and implement envelopes and filters
+    * Pitch bending
+    * Dump the internal ROM
+
+***************************************************************************/
+#define ADDRESS_MAP_MODERN
+
+#include "emu.h"
+#include "qs1000.h"
+
+
+#define LOGGING_ENABLED		0
+
+
+// device type definition
+const device_type QS1000 = &device_creator<qs1000_device>;
+
+static int data_to_i8052(device_t *device);
+
+
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
+
+static ADDRESS_MAP_START( qs1000_prg_map, AS_PROGRAM, 8, qs1000_device )
+	AM_RANGE(0x0000, 0x7fff) AM_ROM
+ADDRESS_MAP_END
+
+
+static ADDRESS_MAP_START( qs1000_io_map, AS_IO, 8, qs1000_device )
+	AM_RANGE(0x0000, 0x00ff) AM_RAM
+	AM_RANGE(0x0200, 0x0211) AM_WRITE(wave_w)
+	AM_RANGE(MCS51_PORT_P1, MCS51_PORT_P1) AM_READWRITE(p1_r, p1_w)
+	AM_RANGE(MCS51_PORT_P2, MCS51_PORT_P2) AM_READWRITE(p2_r, p2_w)
+	AM_RANGE(MCS51_PORT_P3, MCS51_PORT_P3) AM_READWRITE(p3_r, p3_w)
+ADDRESS_MAP_END
+
+
+// Machine fragment
+static MACHINE_CONFIG_FRAGMENT( qs1000 )
+	MCFG_CPU_ADD("cpu", I8052, DERIVED_CLOCK(1, 1))
+	MCFG_CPU_PROGRAM_MAP(qs1000_prg_map)
+	MCFG_CPU_IO_MAP(qs1000_io_map)
+MACHINE_CONFIG_END
+
+
+// ROM definition for the QS1000 internal program ROM
+ROM_START( qs1000 )
+	ROM_REGION( 0x10000, "cpu", 0 )
+	ROM_LOAD_OPTIONAL( "qs1000.bin", 0x0000, 0x10000, NO_DUMP )
+ROM_END
+
+
+// Wavetable ROM address map
+static ADDRESS_MAP_START( qs1000, AS_0, 8, qs1000_device )
+	AM_RANGE(0x000000, 0xffffff) AM_ROM AM_REGION("qs1000", 0)
+ADDRESS_MAP_END
+
+
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+//-------------------------------------------------
+//  qs1000_device - constructor
+//-------------------------------------------------
+qs1000_device::qs1000_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: device_t(mconfig, QS1000, "QS1000", "qs1000", tag, owner, clock),
+	  device_sound_interface(mconfig, *this),
+	  device_memory_interface(mconfig, *this),
+	  m_space_config("samples", ENDIANNESS_LITTLE, 8, 24, 0, NULL),
+	  m_stream(NULL),
+	  m_direct(NULL),
+	  m_cpu(*this, "cpu")
+{
+	m_shortname = "qs1000";
+	m_address_map[0] = *ADDRESS_MAP_NAME(qs1000);
+}
+
+
+//-------------------------------------------------
+//  rom_region - return a pointer to the device's
+//  internal ROM region
+//-------------------------------------------------
+const rom_entry *qs1000_device::device_rom_region() const
+{
+	return m_external_rom ? NULL : ROM_NAME( qs1000 );
+}
+
+
+//-------------------------------------------------
+//  machine_config_additions - return a pointer to
+//  the device's machine fragment
+//-------------------------------------------------
+machine_config_constructor qs1000_device::device_mconfig_additions() const
+{
+	return MACHINE_CONFIG_NAME( qs1000 );
+}
+
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+void qs1000_device::device_start()
+{
+	// Find our direct access
+	m_direct = &space()->direct();
+
+	// The QS1000 operates at 24MHz. Creating a stream at that rate
+	// would be overkill so we opt for a fraction of that rate which
+	// gives reasonable results
+	m_stream = stream_alloc(0, 2, clock() / 32);
+
+	// Resolve CPU port callbacks
+	m_p1_r_func.resolve(m_in_p1_cb, *this);
+	m_p2_r_func.resolve(m_in_p2_cb, *this);
+	m_p3_r_func.resolve(m_in_p3_cb, *this);
+
+	m_p1_w_func.resolve(m_out_p1_cb, *this);
+	m_p2_w_func.resolve(m_out_p2_cb, *this);
+	m_p3_w_func.resolve(m_out_p3_cb, *this);
+
+	i8051_set_serial_rx_callback(m_cpu, data_to_i8052);
+
+	// TODO: register state for saving
+}
+
+
+//-------------------------------------------------
+//  serial_in - send data to the chip
+//-------------------------------------------------
+void qs1000_device::serial_in(UINT8 data)
+{
+	m_serial_data_in = data;
+
+	// Signal to the CPU that data is available
+	m_cpu->set_input_line(MCS51_RX_LINE, ASSERT_LINE);
+	m_cpu->set_input_line(MCS51_RX_LINE, CLEAR_LINE);
+}
+
+
+//-------------------------------------------------
+//  set_irq - interrupt the internal CPU
+//-------------------------------------------------
+void qs1000_device::set_irq(int state)
+{
+	// Signal to the CPU that data is available
+	m_cpu->set_input_line(MCS51_INT1_LINE, state ? ASSERT_LINE : CLEAR_LINE);
+}
+
+
+//-------------------------------------------------
+//  data_to_i8052 - called by the 8052 core to
+//  receive serial data
+//-------------------------------------------------
+static int data_to_i8052(device_t *device)
+{
+	// Ugh
+	qs1000_device *qs1000 = device->machine().device<qs1000_device>("qs1000");
+
+	return qs1000->m_serial_data_in;
+}
+
+
+//-------------------------------------------------
+//  device_config_complete
+//-------------------------------------------------
+void qs1000_device::device_config_complete()
+{
+	const qs1000_interface *intf = reinterpret_cast<const qs1000_interface *>(static_config());
+
+	if (intf != NULL)
+		*static_cast<qs1000_interface *>(this) = *intf;
+}
+
+
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+void qs1000_device::device_reset()
+{
+	for (int ch = 0; ch < QS1000_CHANNELS; ++ch)
+	{
+		m_channels[ch].m_flags = 0;
+	}
+}
+
+
+//-------------------------------------------------
+//  memory_space_config - return a description of
+//  any address spaces owned by this device
+//-------------------------------------------------
+const address_space_config *qs1000_device::memory_space_config(address_spacenum spacenum) const
+{
+	return (spacenum == 0) ? &m_space_config : NULL;
+}
+
+
+//-------------------------------------------------
+//  device_timer - handle deferred writes and
+//  resets as a timer callback
+//-------------------------------------------------
+void qs1000_device::device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr)
+{
+}
+
+
+//-------------------------------------------------
+//  p0_r
+//-------------------------------------------------
+READ8_MEMBER( qs1000_device::p0_r )
+{
+	return 0xff;
+}
+
+
+//-------------------------------------------------
+//  p1_r
+//-------------------------------------------------
+READ8_MEMBER( qs1000_device::p1_r )
+{
+	return m_p1_r_func(0);
+}
+
+
+//-------------------------------------------------
+//  p2_r
+//-------------------------------------------------
+READ8_MEMBER( qs1000_device::p2_r )
+{
+	return m_p2_r_func(0);
+}
+
+
+//-------------------------------------------------
+//  p3_r
+//-------------------------------------------------
+READ8_MEMBER( qs1000_device::p3_r )
+{
+	return m_p3_r_func(0);
+}
+
+
+//-------------------------------------------------
+//  p1_w
+//-------------------------------------------------
+WRITE8_MEMBER( qs1000_device::p0_w )
+{
+
+}
+
+
+//-------------------------------------------------
+//  p1_w
+//-------------------------------------------------
+
+WRITE8_MEMBER( qs1000_device::p1_w )
+{
+	m_p1_w_func(0, data);
+}
+
+
+//-------------------------------------------------
+//  p2_w
+//-------------------------------------------------
+
+WRITE8_MEMBER( qs1000_device::p2_w )
+{
+	m_p2_w_func(0, data);
+}
+
+
+//-------------------------------------------------
+//  p3_w
+//-------------------------------------------------
+
+WRITE8_MEMBER( qs1000_device::p3_w )
+{
+	m_p3_w_func(0, data);
+}
+
+
+//-------------------------------------------------
+//  wave_w - process writes to wavetable engine
+//-------------------------------------------------
+
+WRITE8_MEMBER( qs1000_device::wave_w )
+{
+	m_stream->update();
+
+	if (LOGGING_ENABLED)
+		printf("QS1000 W[%x] %x\n", 0x200 + offset, data);
+
+	switch (offset)
+	{
+		case 0x00:
+		{
+			int ch = m_wave_regs[0xe];
+
+			if (data == 0)
+			{
+				// TODO
+				for (int i = 0; i < 16; ++i)
+					m_channels[ch].m_regs[i] = m_wave_regs[i];
+
+				// Key on
+				start_voice(ch);
+			}
+			if (data == 1)
+			{
+				// ?
+			}
+			else if (data == 2)
+			{
+				// Key off
+				m_channels[ch].m_flags &= ~QS1000_KEYON;
+			}
+			break;
+		}
+
+		case 0x01:
+		case 0x02:
+		case 0x03:
+		case 0x04:
+		case 0x05:
+		case 0x06:
+		case 0x07:
+		case 0x08:
+		case 0x09:
+		case 0x0a:
+		case 0x0b:
+		case 0x0c:
+		case 0x0d:
+		{
+			if (m_wave_regs[0x11] == 3)
+			{
+				// Channel-specific write?
+				m_channels[m_wave_regs[0xe]].m_regs[offset] = data;
+			}
+			else
+			{
+				// Global write?
+				m_wave_regs[offset] = data;
+			}
+			break;
+		}
+
+		default:
+			m_wave_regs[offset] = data;
+	}
+}
+
+
+//-------------------------------------------------
+//  sound_stream_update -
+//-------------------------------------------------
+void qs1000_device::sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples)
+{
+	// Rset the output stream
+	memset(outputs[0], 0x0, samples * sizeof(*outputs[0]));
+	memset(outputs[1], 0x0, samples * sizeof(*outputs[1]));
+
+	// Iterate over voices and accumulate sample data
+	for (int ch = 0; ch < QS1000_CHANNELS; ch++)
+	{
+		qs1000_channel &chan = m_channels[ch];
+
+		UINT8 lvol = chan.m_regs[6];
+		UINT8 rvol = chan.m_regs[7];
+		UINT8 vol  = chan.m_regs[8];
+
+		if (chan.m_flags & QS1000_PLAYING)
+		{
+			if (chan.m_flags & QS1000_ADPCM)
+			{
+				for (int samp = 0; samp < samples; samp++)
+				{
+					if (chan.m_addr >= chan.m_loop_end)
+					{
+#if 0 // Looping disabled until envelopes work
+						if (chan.m_flags & QS1000_KEYON)
+						{
+							chan.m_addr = chan.m_loop_start;
+						}
+						else
+#endif
+						{
+							chan.m_flags &= ~QS1000_PLAYING;
+							break;
+						}
+					}
+
+					// Not too keen on this but it'll do for now
+					while (chan.m_start + chan.m_adpcm_addr != chan.m_addr)
+					{
+						chan.m_adpcm_addr++;
+
+						if (chan.m_start + chan.m_adpcm_addr >=  chan.m_loop_end)
+							chan.m_adpcm_addr = chan.m_loop_start - chan.m_start;
+
+						UINT8 data = m_direct->read_raw_byte(chan.m_start + (chan.m_adpcm_addr >> 1));
+						UINT8 nibble = (chan.m_adpcm_addr & 1 ? data : data >> 4) & 0xf;
+						chan.m_adpcm_signal = chan.m_adpcm.clock(nibble);
+					}
+
+					INT8 result = (chan.m_adpcm_signal >> 4);
+					chan.m_acc += chan.m_freq;
+					chan.m_addr = (chan.m_addr + (chan.m_acc >> 18)) & QS1000_ADDRESS_MASK;
+					chan.m_acc &= ((1 << 18) - 1);
+
+					outputs[0][samp] += (result * 4 * lvol * vol) >> 12;
+					outputs[1][samp] += (result * 4 * rvol * vol) >> 12;
+				}
+			}
+			else
+			{
+				for (int samp = 0; samp < samples; samp++)
+				{
+					if (chan.m_addr >= chan.m_loop_end)
+					{
+#if 0 // Looping disabled until envelopes work
+						if (chan.m_flags & QS1000_KEYON)
+						{
+							chan.m_addr = chan.m_loop_start;
+						}
+						else
+#endif
+						{
+							chan.m_flags &= ~QS1000_PLAYING;
+							break;
+						}
+					}
+
+					INT8 result = m_direct->read_raw_byte(chan.m_addr) - 128;
+
+					chan.m_acc += chan.m_freq;
+					chan.m_addr = (chan.m_addr + (chan.m_acc >> 18)) & QS1000_ADDRESS_MASK;
+					chan.m_acc &= ((1 << 18) - 1);
+
+					outputs[0][samp] += (result * lvol * vol) >> 12;
+					outputs[1][samp] += (result * rvol * vol) >> 12;
+				}
+			}
+		}
+	}
+}
+
+
+void qs1000_device::start_voice(int ch)
+{
+	UINT32 table_addr = (m_channels[ch].m_regs[0x01] << 16) | (m_channels[ch].m_regs[0x02] << 8) | m_channels[ch].m_regs[0x03];
+
+	// Fetch the sound information
+	UINT16 freq = (m_direct->read_raw_byte(table_addr + 0) << 8) | m_direct->read_raw_byte(table_addr + 1);
+	UINT16 word1 = (m_direct->read_raw_byte(table_addr + 2) << 8) | m_direct->read_raw_byte(table_addr + 3);
+	UINT16 base = (m_direct->read_raw_byte(table_addr + 4) << 8) | m_direct->read_raw_byte(table_addr + 5);
+
+	if (LOGGING_ENABLED)
+		printf("[%.6x] Freq:%.4x  ????:%.4x  Addr:%.4x\n", table_addr, freq, word1, base);
+
+	// See Raccoon World and Wyvern Wings NULL sound
+	if (freq == 0)
+		return;
+
+	// Fetch the sample pointers and flags
+	UINT8 byte0 = m_direct->read_raw_byte(base);
+
+	UINT32 start_addr;
+
+	start_addr  = byte0 << 16;
+	start_addr |= m_direct->read_raw_byte(base + 1) << 8;
+	start_addr |= m_direct->read_raw_byte(base + 2) << 0;
+	start_addr &= QS1000_ADDRESS_MASK;
+
+	UINT32 loop_start;
+
+	loop_start = (byte0 & 0xf0) << 16;
+	loop_start |= m_direct->read_raw_byte(base + 3) << 12;
+	loop_start |= m_direct->read_raw_byte(base + 4) << 4;
+	loop_start |= m_direct->read_raw_byte(base + 5) >> 4;
+	loop_start &= QS1000_ADDRESS_MASK;
+
+	UINT32 loop_end;
+
+	loop_end = (byte0 & 0xf0) << 16;
+	loop_end |= (m_direct->read_raw_byte(base + 5) & 0xf) << 16;
+	loop_end |= m_direct->read_raw_byte(base + 6) << 8;
+	loop_end |= m_direct->read_raw_byte(base + 7);
+	loop_end &= QS1000_ADDRESS_MASK;
+
+	UINT8 byte8 = m_direct->read_raw_byte(base + 8);
+
+	if (LOGGING_ENABLED)
+	{
+		UINT8 byte9 = m_direct->read_raw_byte(base + 9);
+		UINT8 byte10 = m_direct->read_raw_byte(base + 10);
+		UINT8 byte11 = m_direct->read_raw_byte(base + 11);
+		UINT8 byte12 = m_direct->read_raw_byte(base + 12);
+		UINT8 byte13 = m_direct->read_raw_byte(base + 13);
+		UINT8 byte14 = m_direct->read_raw_byte(base + 14);
+		UINT8 byte15 = m_direct->read_raw_byte(base + 15);
+
+		printf("[%.6x] Sample Start:%.6x  Loop Start:%.6x  Loop End:%.6x  Params: %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x\n", base, start_addr, loop_start, loop_end, byte8, byte9, byte10, byte11, byte12, byte13, byte14, byte15);
+	}
+
+	m_channels[ch].m_acc = 0;
+	m_channels[ch].m_start = start_addr;
+	m_channels[ch].m_addr = start_addr;
+	m_channels[ch].m_loop_start = loop_start;
+	m_channels[ch].m_loop_end = loop_end;
+	m_channels[ch].m_freq = freq;
+	m_channels[ch].m_flags = QS1000_PLAYING | QS1000_KEYON;
+
+	if (byte8 & 0x08)
+	{
+		m_channels[ch].m_adpcm.reset();
+		m_channels[ch].m_adpcm_addr = -1;
+//      m_channels[ch].m_adpcm_signal = -2;
+		m_channels[ch].m_flags |= QS1000_ADPCM;
+	}
+}
diff -Nru src-old/emu/sound/qs1000.h src/emu/sound/qs1000.h
--- src-old/emu/sound/qs1000.h	1970-01-01 01:00:00.000000000 +0100
+++ src/emu/sound/qs1000.h	2012-07-02 09:06:11.000000000 +0200
@@ -0,0 +1,154 @@
+/***************************************************************************
+
+    qs1000.h
+
+    QS1000 device emulator.
+
+***************************************************************************/
+
+#pragma once
+
+#ifndef __QS1000_H__
+#define __QS1000_H__
+
+#include "cpu/mcs51/mcs51.h"
+#include "sound/okiadpcm.h"
+
+//**************************************************************************
+//  INTERFACE CONFIGURATION MACROS
+//**************************************************************************
+
+#define MCFG_QS1000_ADD(_tag, _clock, _config) \
+	MCFG_DEVICE_ADD(_tag, QS1000, _clock) \
+	MCFG_DEVICE_CONFIG(_config)
+
+#define QS1000_INTERFACE(name) \
+	const qs1000_interface (name) =
+
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+#define QS1000_CHANNELS			32
+#define QS1000_ADDRESS_MASK		0xffffff
+
+class qs1000_device;
+
+
+struct qs1000_interface
+{
+	bool					m_external_rom;
+
+	devcb_read8				m_in_p1_cb;
+	devcb_read8				m_in_p2_cb;
+	devcb_read8				m_in_p3_cb;
+
+	devcb_write8			m_out_p1_cb;
+	devcb_write8			m_out_p2_cb;
+	devcb_write8			m_out_p3_cb;
+
+	devcb_write8			m_serial_w;
+};
+
+// ======================> qs1000_device
+
+class qs1000_device :	public device_t,
+						public device_sound_interface,
+						public device_memory_interface,
+						public qs1000_interface
+{
+
+public:
+	// construction/destruction
+	qs1000_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	// external
+	void serial_in(UINT8 data);
+	void set_irq(int state);
+
+protected:
+	// device-level overrides
+	const rom_entry *device_rom_region() const;
+	machine_config_constructor device_mconfig_additions() const;
+	virtual void device_config_complete();
+	virtual void device_start();
+	virtual void device_reset();
+	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
+
+	// device_memory_interface overrides
+	virtual const address_space_config *memory_space_config(address_spacenum spacenum = AS_0) const;
+
+	// device_sound_interface overrides
+	virtual void sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples);
+
+public:
+	DECLARE_WRITE8_MEMBER( wave_w );
+
+	DECLARE_READ8_MEMBER( p0_r );
+	DECLARE_WRITE8_MEMBER( p0_w );
+
+	DECLARE_READ8_MEMBER( p1_r );
+	DECLARE_WRITE8_MEMBER( p1_w );
+
+	DECLARE_READ8_MEMBER( p2_r );
+	DECLARE_WRITE8_MEMBER( p2_w );
+
+	DECLARE_READ8_MEMBER( p3_r );
+	DECLARE_WRITE8_MEMBER( p3_w );
+
+	enum
+	{
+		QS1000_KEYON   = 1,
+		QS1000_PLAYING = 2,
+		QS1000_ADPCM   = 4,
+	};
+
+	void start_voice(int ch);
+	void set_voice_regs(int ch);
+
+	// Callbacks
+	devcb_resolved_read8			m_p1_r_func;
+	devcb_resolved_read8			m_p2_r_func;
+	devcb_resolved_read8			m_p3_r_func;
+	devcb_resolved_write8			m_p1_w_func;
+	devcb_resolved_write8			m_p2_w_func;
+	devcb_resolved_write8			m_p3_w_func;
+
+	// Internal state
+	const address_space_config		m_space_config;
+	sound_stream *					m_stream;
+	direct_read_data *				m_direct;
+	required_device<i8052_device>	m_cpu;
+
+	// Wavetable engine
+	UINT8							m_serial_data_in;
+	UINT8							m_wave_regs[18];
+
+	struct qs1000_channel
+	{
+		UINT32			m_acc;
+		INT32			m_adpcm_signal;
+		UINT32			m_start;
+		UINT32			m_addr;
+		UINT32			m_adpcm_addr;
+		UINT32			m_loop_start;
+		UINT32			m_loop_end;
+		UINT16			m_freq;
+		UINT16			m_flags;
+
+		UINT8			m_regs[16];	// FIXME
+
+		oki_adpcm_state	m_adpcm;
+	};
+
+	qs1000_channel					m_channels[QS1000_CHANNELS];
+};
+
+
+// device type definition
+extern const device_type QS1000;
+
+
+#endif /* __QS1000_H__ */
diff -Nru src-old/emu/sound/sn76496.c src/emu/sound/sn76496.c
--- src-old/emu/sound/sn76496.c	2012-01-10 23:48:39.000000000 +0100
+++ src/emu/sound/sn76496.c	2012-06-27 12:54:01.000000000 +0200
@@ -111,7 +111,7 @@
         * Test the NCR7496; Smspower says the whitenoise taps are A and E,
           but this needs verification on real hardware.
         * Factor out common code so that the SAA1099 can share some code.
-        * Convert to modern device
+
 ***************************************************************************/
 
 #include "emu.h"
@@ -613,3 +613,301 @@
 DEFINE_LEGACY_SOUND_DEVICE(NCR7496, ncr7496);
 DEFINE_LEGACY_SOUND_DEVICE(GAMEGEAR, gamegear);
 DEFINE_LEGACY_SOUND_DEVICE(SEGAPSG, segapsg);
+
+/*****************************************************************
+    New class implementation
+    Michael Zapf, June 2012
+*****************************************************************/
+
+sn76496_base_device::sn76496_base_device(const machine_config &mconfig, device_type type,  const char *name,
+	const char *tag, int feedbackmask, int noisetap1, int noisetap2, bool negate, bool stereo, int clockdivider, int freq0,
+	device_t *owner, UINT32 clock)
+
+	: device_t(mconfig, type, name, tag, owner, clock),
+	  device_sound_interface(mconfig, *this),
+	  m_feedback_mask(feedbackmask),
+	  m_whitenoise_tap1(noisetap1),
+	  m_whitenoise_tap2(noisetap2),
+	  m_negate(negate),
+	  m_stereo(stereo),
+	  m_clock_divider(clockdivider),
+	  m_freq0_is_max(freq0)
+{
+}
+
+void sn76496_base_device::device_start()
+{
+	int sample_rate = clock()/2;
+	int i;
+	double out;
+	int gain;
+
+	const sn76496_config *conf = reinterpret_cast<const sn76496_config *>(static_config());
+	m_ready.resolve(conf->ready, *this);
+
+	m_sound = machine().sound().stream_alloc(*this, 0, (m_stereo? 2:1), sample_rate, this);
+
+	for (i = 0; i < 4; i++) m_volume[i] = 0;
+
+	m_last_register = 0;
+	for (i = 0; i < 8; i+=2)
+	{
+		m_register[i] = 0;
+		m_register[i + 1] = 0x0f;	// volume = 0
+	}
+
+	for (i = 0; i < 4; i++)
+	{
+		m_output[i] = 0;
+		m_period[i] = 0;
+		m_count[i] = 0;
+	}
+
+	m_RNG = m_feedback_mask;
+	m_output[3] = m_RNG & 1;
+
+	m_cycles_to_ready = 1;			// assume ready is not active immediately on init. is this correct?
+	m_stereo_mask = 0xFF;			// all channels enabled
+	m_current_clock = m_clock_divider-1;
+
+	// set gain
+	gain = 0;
+
+	gain &= 0xff;
+
+	// increase max output basing on gain (0.2 dB per step)
+	out = MAX_OUTPUT / 4; // four channels, each gets 1/4 of the total range
+	while (gain-- > 0)
+		out *= 1.023292992;	// = (10 ^ (0.2/20))
+
+	// build volume table (2dB per step)
+	for (i = 0; i < 15; i++)
+	{
+		// limit volume to avoid clipping
+		if (out > MAX_OUTPUT / 4) m_vol_table[i] = MAX_OUTPUT / 4;
+		else m_vol_table[i] = out;
+
+		out /= 1.258925412;	/* = 10 ^ (2/20) = 2dB */
+	}
+	m_vol_table[15] = 0;
+
+	m_ready_state = true;
+
+	register_for_save_states();
+}
+
+READ_LINE_MEMBER( sn76496_base_device::ready_r )
+{
+	m_sound->update();
+	return (m_cycles_to_ready > 0)? FALSE : TRUE;
+}
+
+WRITE8_MEMBER( sn76496_base_device::stereo_w )
+{
+	m_sound->update();
+	if (m_stereo) m_stereo_mask = data;
+	else fatalerror("sn76496_base_device: Call to stereo write with mono chip!\n");
+}
+
+WRITE8_MEMBER( sn76496_base_device::write )
+{
+	int n, r, c;
+
+	// update the output buffer before changing the registers
+	m_sound->update();
+
+	// set number of cycles until READY is active; this is always one
+	// 'sample', i.e. it equals the clock divider exactly; until the
+	// clock divider is fully supported, we delay until one sample has
+	// played. The fact that this below is '2' and not '1' is because
+	// of a ?race condition? in the mess crvision driver, where after
+	// any sample is played at all, no matter what, the cycles_to_ready
+	// ends up never being not ready, unless this value is greater than
+	// 1. Once the full clock divider stuff is written, this should no
+	// longer be an issue.
+
+	m_cycles_to_ready = 2;
+
+	if (data & 0x80)
+	{
+		r = (data & 0x70) >> 4;
+		m_last_register = r;
+		m_register[r] = (m_register[r] & 0x3f0) | (data & 0x0f);
+	}
+	else
+	{
+		r = m_last_register;
+	}
+
+	c = r >> 1;
+	switch (r)
+	{
+		case 0:	// tone 0: frequency
+		case 2:	// tone 1: frequency
+		case 4:	// tone 2: frequency
+			if ((data & 0x80) == 0) m_register[r] = (m_register[r] & 0x0f) | ((data & 0x3f) << 4);
+			if ((m_register[r] != 0) || (!m_freq0_is_max)) m_period[c] = m_register[r];
+			else m_period[c] = 0x400;
+
+			if (r == 4)
+			{
+				// update noise shift frequency
+				if ((m_register[6] & 0x03) == 0x03)	m_period[3] = m_period[2]<<1;
+			}
+			break;
+		case 1:	// tone 0: volume
+		case 3:	// tone 1: volume
+		case 5:	// tone 2: volume
+		case 7:	// noise: volume
+			m_volume[c] = m_vol_table[data & 0x0f];
+			if ((data & 0x80) == 0) m_register[r] = (m_register[r] & 0x3f0) | (data & 0x0f);
+			break;
+		case 6:	// noise: frequency, mode
+			{
+				if ((data & 0x80) == 0) logerror("sn76496_base_device: write to reg 6 with bit 7 clear; data was %03x, new write is %02x! report this to LN!\n", m_register[6], data);
+				if ((data & 0x80) == 0) m_register[r] = (m_register[r] & 0x3f0) | (data & 0x0f);
+				n = m_register[6];
+				// N/512,N/1024,N/2048,Tone #3 output
+				m_period[3] = ((n&3) == 3)? (m_period[2]<<1) : (1 << (5+(n&3)));
+				m_RNG = m_feedback_mask;
+			}
+			break;
+	}
+}
+
+inline bool sn76496_base_device::in_noise_mode()
+{
+	return ((m_register[6] & 4)!=0);
+}
+
+void sn76496_base_device::countdown_cycles()
+{
+	if (m_cycles_to_ready > 0)
+	{
+		m_cycles_to_ready--;
+		if (m_ready_state==true) m_ready(CLEAR_LINE);
+		m_ready_state = false;
+	}
+	else
+	{
+		if (m_ready_state==false) m_ready(ASSERT_LINE);
+		m_ready_state = true;
+	}
+}
+
+void sn76496_base_device::sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples)
+{
+	int i;
+	stream_sample_t *lbuffer = outputs[0];
+	stream_sample_t *rbuffer = (m_stereo)? outputs[1] : NULL;
+
+	INT16 out = 0;
+	INT16 out2 = 0;
+
+	while (samples > 0)
+	{
+		// clock chip once
+		if (m_current_clock > 0) // not ready for new divided clock
+		{
+			m_current_clock--;
+		}
+		else // ready for new divided clock, make a new sample
+		{
+			m_current_clock = m_clock_divider-1;
+			// decrement Cycles to READY by one
+			countdown_cycles();
+
+			// handle channels 0,1,2
+			for (i = 0; i < 3; i++)
+			{
+				m_count[i]--;
+				if (m_count[i] <= 0)
+				{
+					m_output[i] ^= 1;
+					m_count[i] = m_period[i];
+				}
+			}
+
+			// handle channel 3
+			m_count[3]--;
+			if (m_count[3] <= 0)
+			{
+				// if noisemode is 1, both taps are enabled
+				// if noisemode is 0, the lower tap, whitenoisetap2, is held at 0
+				// The != was a bit-XOR (^) before
+				if (((m_RNG & m_whitenoise_tap1)!=0) != (((m_RNG & m_whitenoise_tap2)!=0) && in_noise_mode()))
+				{
+					m_RNG >>= 1;
+					m_RNG |= m_feedback_mask;
+				}
+				else
+				{
+					m_RNG >>= 1;
+				}
+				m_output[3] = m_RNG & 1;
+
+				m_count[3] = m_period[3];
+			}
+		}
+
+		if (m_stereo)
+		{
+			out = ((((m_stereo_mask & 0x10)!=0) && (m_output[0]!=0))? m_volume[0] : 0)
+				+ ((((m_stereo_mask & 0x20)!=0) && (m_output[1]!=0))? m_volume[1] : 0)
+				+ ((((m_stereo_mask & 0x40)!=0) && (m_output[2]!=0))? m_volume[2] : 0)
+				+ ((((m_stereo_mask & 0x80)!=0) && (m_output[3]!=0))? m_volume[3] : 0);
+
+			out2= ((((m_stereo_mask & 0x1)!=0) && (m_output[0]!=0))? m_volume[0] : 0)
+				+ ((((m_stereo_mask & 0x2)!=0) && (m_output[1]!=0))? m_volume[1] : 0)
+				+ ((((m_stereo_mask & 0x4)!=0) && (m_output[2]!=0))? m_volume[2] : 0)
+				+ ((((m_stereo_mask & 0x8)!=0) && (m_output[3]!=0))? m_volume[3] : 0);
+		}
+		else
+		{
+			out= ((m_output[0]!=0)? m_volume[0]:0)
+				+((m_output[1]!=0)? m_volume[1]:0)
+				+((m_output[2]!=0)? m_volume[2]:0)
+				+((m_output[3]!=0)? m_volume[3]:0);
+		}
+
+		if (m_negate) { out = -out; out2 = -out2; }
+
+		*(lbuffer++) = out;
+		if (m_stereo) *(rbuffer++) = out2;
+		samples--;
+	}
+}
+
+void sn76496_base_device::register_for_save_states()
+{
+	save_item(NAME(m_vol_table));
+	save_item(NAME(m_register));
+	save_item(NAME(m_last_register));
+	save_item(NAME(m_volume));
+	save_item(NAME(m_RNG));
+//  save_item(NAME(m_clock_divider));
+	save_item(NAME(m_current_clock));
+//  save_item(NAME(m_feedback_mask));
+//  save_item(NAME(m_whitenoise_tap1));
+//  save_item(NAME(m_whitenoise_tap2));
+//  save_item(NAME(m_negate));
+//  save_item(NAME(m_stereo));
+	save_item(NAME(m_stereo_mask));
+	save_item(NAME(m_period));
+	save_item(NAME(m_count));
+	save_item(NAME(m_output));
+	save_item(NAME(m_cycles_to_ready));
+//  save_item(NAME(m_freq0_is_max));
+}
+
+const device_type SN76496N = &device_creator<sn76496n_device>;
+const device_type U8106N = &device_creator<u8106n_device>;
+const device_type Y2404N = &device_creator<y2404n_device>;
+const device_type SN76489N = &device_creator<sn76489n_device>;
+const device_type SN76489AN = &device_creator<sn76489an_device>;
+const device_type SN76494N = &device_creator<sn76494n_device>;
+const device_type SN94624N = &device_creator<sn94624n_device>;
+const device_type NCR7496N = &device_creator<ncr7496n_device>;
+const device_type GAMEGEARN = &device_creator<gamegearn_device>;
+const device_type SEGAPSGN = &device_creator<segapsgn_device>;
+
diff -Nru src-old/emu/sound/sn76496.h src/emu/sound/sn76496.h
--- src-old/emu/sound/sn76496.h	2012-01-10 23:48:39.000000000 +0100
+++ src/emu/sound/sn76496.h	2012-06-27 12:54:01.000000000 +0200
@@ -20,4 +20,161 @@
 DECLARE_LEGACY_SOUND_DEVICE(GAMEGEAR, gamegear);
 DECLARE_LEGACY_SOUND_DEVICE(SEGAPSG, segapsg);
 
+/*****************************************************************
+    New class implementation
+    Michael Zapf, June 2012
+*****************************************************************/
+
+extern const device_type SN76496N;
+extern const device_type U8106N;
+extern const device_type Y2404N;
+extern const device_type SN76489N;
+extern const device_type SN76489AN;
+extern const device_type SN76494N;
+extern const device_type SN94624N;
+extern const device_type NCR7496N;
+extern const device_type GAMEGEARN;
+extern const device_type SEGAPSGN;
+
+typedef struct _sn76496_config
+{
+	devcb_write_line		ready;
+} sn76496_config;
+
+class sn76496_base_device : public device_t, public device_sound_interface
+{
+public:
+	sn76496_base_device(const machine_config &mconfig, device_type type,  const char *name, const char *tag,
+		int feedbackmask, int noisetap1, int noisetap2, bool negate, bool stereo, int clockdivider, int freq0,
+		device_t *owner, UINT32 clock);
+	DECLARE_READ_LINE_MEMBER( ready_r );
+	DECLARE_WRITE8_MEMBER( stereo_w );
+	DECLARE_WRITE8_MEMBER( write );
+
+protected:
+	void	device_start();
+	void	sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples);
+
+private:
+	inline bool 	in_noise_mode();
+	void			register_for_save_states();
+	void			countdown_cycles();
+
+	bool			m_ready_state;
+
+	devcb_resolved_write_line	m_ready;
+
+	sound_stream*	m_sound;
+
+	const INT32 	m_feedback_mask;	// mask for feedback
+	const INT32 	m_whitenoise_tap1;	// mask for white noise tap 1 (higher one, usually bit 14)
+	const INT32 	m_whitenoise_tap2;	// mask for white noise tap 2 (lower one, usually bit 13)
+	const bool		m_negate;			// output negate flag
+	const bool		m_stereo;			// whether we're dealing with stereo or not
+	const INT32 	m_clock_divider;	// clock divider
+	const bool		m_freq0_is_max;		// flag for if frequency zero acts as if it is one more than max (0x3ff+1) or if it acts like 0
+
+	INT32			m_vol_table[16];	// volume table (for 4-bit to db conversion)
+	INT32			m_register[8];		// registers
+	INT32			m_last_register;	// last register written
+	INT32			m_volume[4];		// db volume of voice 0-2 and noise
+	UINT32			m_RNG;				// noise generator LFSR
+	INT32			m_current_clock;
+	INT32			m_stereo_mask;		// the stereo output mask
+	INT32			m_period[4];		// Length of 1/2 of waveform
+	INT32			m_count[4];			// Position within the waveform
+	INT32			m_output[4];		// 1-bit output of each channel, pre-volume
+	INT32			m_cycles_to_ready;	// number of cycles until the READY line goes active
+};
+
+// SN76496: Whitenoise verified, phase verified, periodic verified (by Michael Zapf)
+class sn76496n_device : public sn76496_base_device
+{
+public:
+	sn76496n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	:  sn76496_base_device(mconfig, SN76496N, "SN76496N", tag, 0x10000, 0x04, 0x08, false, false, 8, true, owner, clock)
+	{ }
+};
+
+// U8106 not verified yet. todo: verify; (a custom marked sn76489? only used on mr. do and maybe other universal games)
+class u8106n_device : public sn76496_base_device
+{
+public:
+	u8106n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	:  sn76496_base_device(mconfig, U8106N, "U8106N", tag, 0x4000, 0x01, 0x02, true, false, 8, true, owner, clock)
+	{ }
+};
+
+// Y2404 not verified yet. todo: verify; (don't be fooled by the Y, it's a TI chip, not Yamaha)
+class y2404n_device : public sn76496_base_device
+{
+public:
+	y2404n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	:  sn76496_base_device(mconfig, Y2404N, "Y2404N", tag, 0x10000, 0x04, 0x08, false, false, 8, true, owner, clock)
+	{ }
+};
+
+// SN76489 not verified yet. todo: verify;
+class sn76489n_device : public sn76496_base_device
+{
+public:
+	sn76489n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	:  sn76496_base_device(mconfig, SN76489N, "SN76489N", tag, 0x4000, 0x01, 0x02, true, false, 8, true, owner, clock)
+	{ }
+};
+
+// SN76489A: whitenoise verified, phase verified, periodic verified (by plgdavid)
+class sn76489an_device : public sn76496_base_device
+{
+public:
+	sn76489an_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	:  sn76496_base_device(mconfig, SN76489AN, "SN76489AN", tag, 0x10000, 0x04, 0x08, false, false, 8, true, owner, clock)
+	{ }
+};
+
+// SN76494 not verified, (according to datasheet: same as sn76489a but without the /8 divider)
+class sn76494n_device : public sn76496_base_device
+{
+public:
+	sn76494n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	:  sn76496_base_device(mconfig, SN76494N, "SN76494N", tag, 0x10000, 0x04, 0x08, false, false, 1, true, owner, clock)
+	{ }
+};
+
+// SN94624 whitenoise verified, phase verified, period verified; verified by PlgDavid
+class sn94624n_device : public sn76496_base_device
+{
+public:
+	sn94624n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	:  sn76496_base_device(mconfig, SN94624N, "SN94624N", tag, 0x4000, 0x01, 0x02, true, false, 1, true, owner, clock)
+	{ }
+};
+
+// NCR7496 not verified; info from smspower wiki
+class ncr7496n_device : public sn76496_base_device
+{
+public:
+	ncr7496n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	:  sn76496_base_device(mconfig, NCR7496N, "NCR7496N", tag, 0x8000, 0x02, 0x20, false, false, 8, true, owner, clock)
+	{ }
+};
+
+// Verified by Justin Kerk
+class gamegearn_device : public sn76496_base_device
+{
+public:
+	gamegearn_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	:  sn76496_base_device(mconfig, GAMEGEARN, "Game Gear PSGN", tag, 0x8000, 0x01, 0x08, true, true, 8, false, owner, clock)
+	{ }
+};
+
+// todo: verify; from smspower wiki, assumed to have same invert as gamegear
+class segapsgn_device : public sn76496_base_device
+{
+public:
+	segapsgn_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	:  sn76496_base_device(mconfig, SEGAPSGN, "SEGA VDP PSGN", tag, 0x8000, 0x01, 0x08, true, false, 8, false, owner, clock)
+	{ }
+};
+
 #endif /* __SN76496_H__ */
diff -Nru src-old/emu/sound/sound.mak src/emu/sound/sound.mak
--- src-old/emu/sound/sound.mak	2012-05-09 16:52:29.000000000 +0200
+++ src/emu/sound/sound.mak	2012-06-12 19:49:05.000000000 +0200
@@ -420,6 +420,16 @@
 
 
 #-------------------------------------------------
+# AdMOS QS1000
+#-------------------------------------------------
+
+#ifneq ($(filter QS1000,$(SOUNDS)),)
+SOUNDOBJS += $(SOUNDOBJ)/qs1000.o
+#endif
+
+
+
+#-------------------------------------------------
 # QSound sample player
 #-------------------------------------------------
 
diff -Nru src-old/emu/sound/tms5220.c src/emu/sound/tms5220.c
--- src-old/emu/sound/tms5220.c	2012-05-03 11:16:42.000000000 +0200
+++ src/emu/sound/tms5220.c	2012-06-25 13:29:00.000000000 +0200
@@ -332,7 +332,6 @@
 // above debugs the tms5220_data_r and data_w access methods which actually respect rs and ws
 
 #define MAX_SAMPLE_CHUNK	512
-#define FIFO_SIZE 16
 
 /* Variants */
 
@@ -2039,3 +2038,1389 @@
 DEFINE_LEGACY_SOUND_DEVICE(TMS5220, tms5220);
 DEFINE_LEGACY_SOUND_DEVICE(TMC0285, tmc0285);
 DEFINE_LEGACY_SOUND_DEVICE(TMS5200, tms5200);
+
+
+/******************************************************************************
+   New class implementation
+******************************************************************************/
+
+#define M_INTERP_SHIFT >> m_coeff->interp_coeff[m_interp_period]
+
+tms52xx_device::tms52xx_device(const machine_config &mconfig, device_type type,  const char *name, const char *tag, const struct tms5100_coeffs* coeffs, const int var, device_t *owner, UINT32 clock)
+	: device_t(mconfig, type, name, tag, owner, clock),
+	  device_sound_interface(mconfig, *this),
+	  m_variant(var),
+	  m_coeff(coeffs)
+{
+}
+
+
+tms5220n_device::tms5220n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: tms52xx_device(mconfig, TMS5220N, "TMS5220N", tag, &tms5220_coeff, TMS5220_IS_5220, owner, clock)
+{
+}
+
+tms5220cn_device::tms5220cn_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: tms52xx_device(mconfig, TMS5220CN, "TMS5220CN", tag, &tms5220c_coeff, TMS5220_IS_5220C, owner, clock)
+{
+}
+
+tmc0285n_device::tmc0285n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: tms52xx_device(mconfig, TMC0285N, "TMC0285N", tag, &tms5200_coeff, TMS5220_IS_TMC0285, owner, clock)
+{
+}
+
+tms5200n_device::tms5200n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: tms52xx_device(mconfig, TMS5200N, "TMS5200N", tag, &tms5200_coeff, TMS5220_IS_5200, owner, clock)
+{
+}
+
+void tms52xx_device::device_start()
+{
+	const tms52xx_config *conf = reinterpret_cast<const tms52xx_config *>(static_config());
+	//m_table = region();
+
+	/* resolve irq and readyq line */
+	m_irq_func.resolve(conf->irq_func, *this);
+	m_readyq_func.resolve(conf->readyq_func, *this);
+	m_read_mem.resolve(conf->read_mem, *this);
+	m_load_address.resolve(conf->load_address, *this);
+	m_read_and_branch.resolve(conf->read_and_branch, *this);
+
+	/* initialize a stream */
+	m_stream = machine().sound().stream_alloc(*this, 0, 1, clock() / 80, this);
+
+	/*if (m_table == NULL)
+    {
+        assert_always(m_conf->M0_callback != NULL, "Missing _mandatory_ 'M0_callback' function pointer in the TMS5110 interface\n  This function is used by TMS5220 to call for a new single bit\n  needed to generate the speech when in VSM mode\n  Aborting startup...\n");
+        m_M0_callback = conf->M0_callback;
+        m_set_load_address = conf->load_address;
+    }
+    else
+    {
+        m_M0_callback = speech_rom_read_bit;
+        m_set_load_address = speech_rom_set_addr;
+    }*/
+
+	/* not during reset which is called frm within a write! */
+	m_io_ready = true;
+	m_true_timing = false;
+	m_rs_ws = 0x03; // rs and ws are assumed to be inactive on device startup
+
+	m_ready_timer = timer_alloc(0);
+
+	register_for_save_states();
+}
+
+void tms52xx_device::device_reset()
+{
+	m_digital_select = FORCE_DIGITAL;			// assume analog output
+	// initialize the FIFO */
+	// memset(tms->fifo, 0, sizeof(tms->fifo));
+	m_fifo_head = 0;
+	m_fifo_tail = 0;
+	m_fifo_count = 0;
+	m_fifo_bits_taken = 0;
+
+	// initialize the chip state
+	// Note that we do not actually clear IRQ on start-up: IRQ is even raised
+	// if m_buffer_empty or m_buffer_low are 0
+	m_speaking_now = false;
+	m_speak_external = false;
+	m_talk_status = false;
+	m_irq_pin = 0;		// CLEAR_LINE
+	m_ready_pin = 0;	// CLEAR_LINE
+
+	set_interrupt_state(0);			// CLEAR_LINE
+	update_ready_state();
+	m_buffer_empty = true;
+	m_buffer_low = true;
+
+	m_RDB_flag = false;
+
+	/* initialize the energy/pitch/k states */
+#ifdef PERFECT_INTERPOLATION_HACK
+	m_old_frame_energy_idx = 0;
+	m_old_frame_pitch_idx = 0;
+	memset(m_old_frame_k_idx, 0, sizeof(m_old_frame_k_idx));
+#endif
+
+	m_new_frame_energy_idx = 0;
+	m_current_energy = 0;
+	m_target_energy = 0;
+	m_new_frame_pitch_idx = 0;
+	m_current_pitch = 0;
+	m_target_pitch = 0;
+
+	memset(m_new_frame_k_idx, 0, sizeof(m_new_frame_k_idx));
+	memset(m_current_k, 0, sizeof(m_current_k));
+	memset(m_target_k, 0, sizeof(m_target_k));
+
+	/* initialize the sample generators */
+	m_inhibit = true;
+	m_subcycle = 0;
+	m_tms5220c_rate = 0;
+	m_pitch_count = 0;
+	m_PC = 0;
+
+	m_subc_reload = FORCE_SUBC_RELOAD;
+	m_OLDE = 1;
+	m_OLDP = 1;
+
+	m_interp_period = reload_table[m_tms5220c_rate&0x3];
+	m_RNG = 0x1FFF;
+	memset(m_u, 0, sizeof(m_u));
+	memset(m_x, 0, sizeof(m_x));
+
+	m_load_address(0, 0);
+	m_schedule_dummy_read = true;
+}
+
+/******************************************************************************
+     set_interrupt_state -- generate an interrupt
+*******************************************************************************/
+
+void tms52xx_device::set_interrupt_state(int state)
+{
+#ifdef DEBUG_PIN_READS
+	logerror("tms52xx: irq pin set to state %d\n", state);
+#endif
+    if (state != m_irq_pin) m_irq_func(!state);
+    m_irq_pin = state;
+}
+
+/******************************************************************************
+     update_ready_state -- update the ready line
+*******************************************************************************/
+
+void tms52xx_device::update_ready_state()
+{
+	int state = ready_read();
+#ifdef DEBUG_PIN_READS
+	logerror("tms52xx: ready pin set to state %d\n", state);
+#endif
+	if (state != m_ready_pin) m_readyq_func(!state);
+	m_ready_pin = state;
+}
+
+/******************************************************************************
+     tms5220_set_frequency -- adjusts the playback frequency
+*******************************************************************************/
+
+void tms52xx_device::set_frequency(int frequency)
+{
+	m_stream->set_sample_rate(frequency / 80);
+	m_clock = frequency;
+}
+
+/******************************************************************************
+     tms5220_update -- update the sound chip so that it is in sync with CPU execution
+*******************************************************************************/
+
+void tms52xx_device::sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples)
+{
+	INT16 sample_data[MAX_SAMPLE_CHUNK];
+	stream_sample_t *buffer = outputs[0];
+
+	/* loop while we still have samples to generate */
+	while (samples>0)
+	{
+		int length = (samples > MAX_SAMPLE_CHUNK) ? MAX_SAMPLE_CHUNK : samples;
+		int index;
+
+		/* generate the samples and copy to the target buffer */
+		process(sample_data, length);
+		for (index = 0; index < length; index++)
+			*buffer++ = sample_data[index];
+
+		/* account for the samples */
+		samples -= length;
+	}
+}
+
+/******************************************************************************
+    process -- fill the buffer with a specific number of samples
+*******************************************************************************/
+
+void tms52xx_device::process(INT16 *buffer, unsigned int size)
+{
+	int buf_count=0;
+	int i, bitout;
+	bool zpar;
+	INT32 this_sample;
+
+	// The following gotos are probably safe to remove
+	// if we're empty and still not speaking, fill with nothingness
+	if (!m_speaking_now) goto empty;
+
+	// if speak external is set, but talk status is not (yet) set,
+	// wait for buffer low to clear
+	if (!m_talk_status && m_speak_external && m_buffer_low) goto empty;
+
+	// loop until the buffer is full or we've stopped speaking
+	while ((size > 0) && m_speaking_now)
+	{
+		// if it is the appropriate time to update the old energy/pitch idxes,
+		// i.e. when IP=7, PC=12, T=17, subcycle=2, do so. Since IP=7 PC=12 T=17
+		// is JUST BEFORE the transition to IP=0 PC=0 T=0 sybcycle=(0 or 1),
+		// which happens 4 T-cycles later), we change on the latter.
+		if ((m_interp_period == 0) && (m_PC == 0) && (m_subcycle < 2))
+		{
+			m_OLDE = (m_new_frame_energy_idx == 0);
+			m_OLDP = (m_new_frame_pitch_idx == 0);
+		}
+
+		//if we're ready for a new frame to be applied, i.e. when IP=0, PC=12, Sub=1
+		// (In reality, the frame was really loaded incrementally during the
+		// entire IP=0 PC=x time period, but it doesn't affect anything until IP=0 PC=12 happens)
+		if ((m_interp_period == 0) && (m_PC == 12) && (m_subcycle == 1))
+		{
+			// HACK for regression testing, be sure to comment out before release!
+			// m_RNG = 0x1234;
+			// end HACK
+
+			// appropriately override the interp count if needed; this will be incremented after the frame parse!
+			m_interp_period = reload_table[m_tms5220c_rate & 0x3];
+
+#ifdef PERFECT_INTERPOLATION_HACK
+			// remember previous frame energy, pitch, and coefficients
+			m_old_frame_energy_idx = m_new_frame_energy_idx;
+			m_old_frame_pitch_idx = m_new_frame_pitch_idx;
+			for (i = 0; i < m_coeff->num_k; i++)
+				m_old_frame_k_idx[i] = m_new_frame_k_idx[i];
+#endif
+
+			// if the talk status was clear last frame, halt speech now.
+			if (m_talk_status == false)
+			{
+#ifdef DEBUG_GENERATION
+				fprintf(stderr,"tms5220_process: processing frame: talk status = 0 caused by stop frame or buffer empty, halting speech.\n");
+#endif
+				m_speaking_now = false; // finally halt speech
+				goto empty;
+			}
+
+			// Parse a new frame into the new_target_energy, new_target_pitch and new_target_k[]
+			parse_frame();
+#ifdef DEBUG_PARSE_FRAME_DUMP
+			fprintf(stderr,"\n");
+#endif
+			// if the new frame is a stop frame, set an interrupt and set talk status to 0
+			if (M_NEW_FRAME_STOP_FLAG == 1)
+			{
+				m_talk_status = false;
+				m_speak_external = false;
+				set_interrupt_state(1);
+				update_status_and_ints();
+			}
+
+			// in all cases where interpolation would be inhibited, set the inhibit flag; otherwise clear it.
+			// Interpolation inhibit cases:
+			// * Old frame was voiced, new is unvoiced
+			// * Old frame was silence/zero energy, new has nonzero energy
+			// * Old frame was unvoiced, new is voiced
+
+			if ( ((M_OLD_FRAME_UNVOICED_FLAG == false) && (M_NEW_FRAME_UNVOICED_FLAG == true))
+				|| ((M_OLD_FRAME_UNVOICED_FLAG == true) && (M_NEW_FRAME_UNVOICED_FLAG == false))
+				|| ((M_OLD_FRAME_SILENCE_FLAG == true) && (M_NEW_FRAME_SILENCE_FLAG == false)) )
+				m_inhibit = true;
+			else // normal frame, normal interpolation
+				m_inhibit = false;
+
+			// load new frame targets from tables, using parsed indices
+			m_target_energy = m_coeff->energytable[m_new_frame_energy_idx];
+			m_target_pitch = m_coeff->pitchtable[m_new_frame_pitch_idx];
+			zpar = M_NEW_FRAME_UNVOICED_FLAG; // find out if parameters k5-k10 should be zeroed
+			for (i = 0; i < 4; i++)
+				m_target_k[i] = m_coeff->ktable[i][m_new_frame_k_idx[i]];
+			for (i = 4; i < m_coeff->num_k; i++)
+				m_target_k[i] = (m_coeff->ktable[i][m_new_frame_k_idx[i]] * (1-zpar));
+
+#ifdef DEBUG_GENERATION
+			/* Debug info for current parsed frame */
+			fprintf(stderr, "OLDE: %d; OLDP: %d; ", m_OLDE, m_OLDP);
+			fprintf(stderr,"Processing frame: ");
+			if (m_inhibit == 0)
+				fprintf(stderr, "Normal Frame\n");
+			else
+				fprintf(stderr,"Interpolation Inhibited\n");
+			fprintf(stderr,"*** current Energy, Pitch and Ks =      %04d,   %04d, %04d, %04d, %04d, %04d, %04d, %04d, %04d, %04d, %04d, %04d\n",
+				m_current_energy, m_current_pitch,
+				m_current_k[0], m_current_k[1],	m_current_k[2], m_current_k[3],
+				m_current_k[4], m_current_k[5], m_current_k[6], m_current_k[7],
+				m_current_k[8], m_current_k[9]);
+			fprintf(stderr,"*** target Energy(idx), Pitch, and Ks = %04d(%x),%04d, %04d, %04d, %04d, %04d, %04d, %04d, %04d, %04d, %04d, %04d\n",
+				m_target_energy, m_new_frame_energy_idx, m_target_pitch,
+				m_target_k[0], m_target_k[1], m_target_k[2], m_target_k[3],
+				m_target_k[4], m_target_k[5], m_target_k[6], m_target_k[7],
+				m_target_k[8], m_target_k[9]);
+#endif
+
+			/* if TS is now 0, ramp the energy down to 0. Is this really correct to hardware? */
+			if (!m_talk_status)
+			{
+#ifdef DEBUG_GENERATION
+				fprintf(stderr,"Talk status is 0, forcing target energy to 0\n");
+#endif
+				m_target_energy = 0;
+			}
+		}
+		else // Not a new frame, just interpolate the existing frame.
+		{
+			bool inhibit_state = (m_inhibit && (m_interp_period != 0)); // disable inhibit when reaching the last interp period, but don't overwrite the tms->inhibit value
+#ifdef PERFECT_INTERPOLATION_HACK
+			int samples_per_frame = (m_subc_reload!=0)? 175:266;		// either (13 A cycles + 12 B cycles) * 7 interps for normal SPEAK/SPKEXT, or (13*2 A cycles + 12 B cycles) * 7 interps for SPKSLOW
+			//int samples_per_frame = (m_subc_reload!=0)?200:304; // either (13 A cycles + 12 B cycles) * 8 interps for normal SPEAK/SPKEXT, or (13*2 A cycles + 12 B cycles) * 8 interps for SPKSLOW
+			int current_sample = (tms->subcycle - tms->subc_reload)+(tms->PC*(3-tms->subc_reload))+((tms->subc_reload?25:38)*((tms->interp_period-1)&7));
+
+			zpar = M_OLD_FRAME_UNVOICED_FLAG;
+			//fprintf(stderr, "CS: %03d", current_sample);
+			// reset the current energy, pitch, etc to what it was at frame start
+			m_current_energy = m_coeff->energytable[m_old_frame_energy_idx];
+			m_current_pitch = m_coeff->pitchtable[m_old_frame_pitch_idx];
+			for (i = 0; i < 4; i++)
+				m_current_k[i] = m_coeff->ktable[i][m_old_frame_k_idx[i]];
+			for (i = 4; i < m_coeff->num_k; i++)
+				m_current_k[i] = (m_coeff->ktable[i][m_old_frame_k_idx[i]] * (1-zpar));
+			// now adjust each value to be exactly correct for each of the samples per frame
+			if (m_interp_period != 0) // if we're still interpolating...
+			{
+				if (!inhibit_state)
+				{
+					m_current_energy += ((m_target_energy - m_current_energy)*current_sample)/samples_per_frame;
+					m_current_pitch += ((m_target_pitch - m_current_pitch)*current_sample)/samples_per_frame;
+					for (i = 0; i < m_coeff->num_k; i++)
+					{
+						m_current_k[i] += ((m_target_k[i] - m_current_k[i])*current_sample)/samples_per_frame;
+					}
+				}
+			}
+			else // we're done, play this frame for 1/8 frame.
+			{
+				m_current_energy = m_target_energy;
+				m_current_pitch = m_target_pitch;
+				for (i = 0; i < m_coeff->num_k; i++)
+					m_current_k[i] = m_target_k[i];
+			}
+#else
+			// Updates to parameters only happen on subcycle '2' (B cycle) of PCs.
+			if (m_subcycle == 2)
+			{
+				if (!inhibit_state)
+				{
+					switch(m_PC)
+					{
+					case 0: // PC = 0, B cycle, write updated energy
+						m_current_energy += ((m_target_energy - m_current_energy) M_INTERP_SHIFT);
+						break;
+					case 1: /* PC = 1, B cycle, write updated pitch */
+						m_current_pitch += ((m_target_pitch - m_current_pitch) M_INTERP_SHIFT);
+						break;
+					case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11:
+						/* PC = 2 through 11, B cycle, write updated K1 through K10 */
+						m_current_k[m_PC-2] += ((m_target_k[m_PC-2] - m_current_k[m_PC-2]) M_INTERP_SHIFT);
+						break;
+					case 12: /* PC = 12, do nothing */
+						break;
+					}
+				}
+			}
+#endif
+		}
+
+		// calculate the output
+		if (M_OLD_FRAME_UNVOICED_FLAG == true)
+		{
+			// generate unvoiced samples here
+#ifndef UNVOICED_HACK
+			if (m_RNG & 1)
+				m_excitation_data = ~0x3F; // according to the patent it is (either + or -) half of the maximum value in the chirp table, so either 01000000(0x40) or 11000000(0xC0)
+			else
+				m_excitation_data = 0x40;
+#else // hack to double unvoiced strength, doesn't match patent
+			if (m_RNG & 1)
+				m_excitation_data = ~0x7F;
+			else
+				m_excitation_data = 0x80;
+#endif
+		}
+		else // (M_OLD_FRAME_UNVOICED_FLAG == false)
+		{
+			// generate voiced samples here
+			// US patent 4331836 Figure 14B shows, and logic would hold, that a pitch based chirp
+			// function has a chirp/peak and then a long chain of zeroes.
+			// The last entry of the chirp rom is at address 0b110011 (51d), the 52nd sample,
+			// and if the address reaches that point the ADDRESS incrementer is
+			// disabled, forcing all samples beyond 51d to be == 51d
+			// (address 51d holds zeroes, which may or may not be inverted to -1)
+
+			if (m_pitch_count >= 51)
+				m_excitation_data = m_coeff->chirptable[51];
+			else // tms->pitch_count < 51
+				m_excitation_data = m_coeff->chirptable[m_pitch_count];
+#ifdef VOICED_INV_HACK
+			// invert waveform
+			if (m_pitch_count >= 51)
+				m_excitation_data = ~m_coeff->chirptable[51];
+			else // tms->pitch_count < 51
+				m_excitation_data = ~m_coeff->chirptable[m_pitch_count];
+#endif
+#ifdef VOICED_ZERO_HACK
+			// 0 and >=51 are -128, as implied by qboxpro tables
+			if ((m_pitch_count == 0) | (m_pitch_count >= 51))
+				m_excitation_data = -128;
+			else /*tms->pitch_count < 51 && > 0*/
+				m_excitation_data = m_coeff->chirptable[m_pitch_count];
+#endif
+#ifdef VOICED_PULSE_HACK
+			// if pitch is between 1 and PWIDTH+1, out = PAMP, if between PWIDTH+1 and (2*PWIDTH)+1, out ~PAMP, else out = 0
+			if (m_pitch_count == 0)
+				m_excitation_data = 0;
+			else if (m_pitch_count < PWIDTH+1)
+				m_excitation_data = PAMP;
+			else if (m_pitch_count < (PWIDTH*2)+1)
+				m_excitation_data = ~PAMP;
+			else
+				m_excitation_data = 0;
+#endif
+#ifdef VOICED_PULSE_MONOPOLAR_HACK
+			// if pitch is between 1 and PWIDTH+1, out = PAMP, else out = 0
+			if (m_pitch_count == 0)
+				m_excitation_data = 0;
+			else if (m_pitch_count < PWIDTH+1)
+				m_excitation_data = PAMP;
+			else
+				m_excitation_data = 0;
+#endif
+		}
+
+		// Update LFSR *20* times every sample (once per T cycle), like patent shows
+		for (i=0; i<20; i++)
+		{
+			bitout = ((m_RNG >> 12) & 1) ^
+					((m_RNG >>  3) & 1) ^
+					((m_RNG >>  2) & 1) ^
+					((m_RNG >>  0) & 1);
+			m_RNG <<= 1;
+			m_RNG |= bitout;
+		}
+
+		this_sample = lattice_filter(); // execute lattice filter
+#ifdef DEBUG_GENERATION_VERBOSE
+		//fprintf(stderr,"C:%01d; ",tms->subcycle);
+		fprintf(stderr,"IP:%01d PC:%02d X:%04d E:%03d P:%03d Pc:%03d ",m_interp_period, m_PC,
+			m_excitation_data, m_current_energy, m_current_pitch, m_pitch_count);
+		//fprintf(stderr,"X:%04d E:%03d P:%03d Pc:%03d ", m_excitation_data, m_current_energy, m_current_pitch, m_pitch_count);
+		for (i=0; i<10; i++)
+			fprintf(stderr,"K%d:%04d ", i+1, m_current_k[i]);
+		fprintf(stderr,"Out:%06d", this_sample);
+		fprintf(stderr,"\n");
+#endif
+		// next, force result to 14 bits (since its possible that the addition at the final (k1) stage of the lattice overflowed)
+		while (this_sample > 16383) this_sample -= 32768;
+		while (this_sample < -16384) this_sample += 32768;
+		if (!m_digital_select) // analog SPK pin output is only 8 bits, with clipping
+			buffer[buf_count] = clip_analog(this_sample);
+		else // digital I/O pin output is 12 bits
+		{
+#ifdef ALLOW_4_LSB
+			// input:  ssss ssss ssss ssss ssnn nnnn nnnn nnnn
+			// N taps:                       ^                 = 0x2000;
+			// output: ssss ssss ssss ssss snnn nnnn nnnn nnnN
+			buffer[buf_count] = (this_sample<<1)|((this_sample&0x2000)>>13);
+#else
+			this_sample &= ~0xF;
+			// input:  ssss ssss ssss ssss ssnn nnnn nnnn 0000
+			// N taps:                       ^^ ^^^            = 0x3E00;
+			// output: ssss ssss ssss ssss snnn nnnn nnnN NNNN
+			buffer[buf_count] = (this_sample<<1)|((this_sample&0x3E00)>>9);
+#endif
+		}
+
+		// Update all counts
+		m_subcycle++;
+		if ((m_subcycle == 2) && (m_PC == 12))
+		{
+			m_subcycle = m_subc_reload;
+			m_PC = 0;
+			m_interp_period++;
+			m_interp_period &= 0x7;
+		}
+		else if (m_subcycle == 3)
+		{
+			m_subcycle = m_subc_reload;
+			m_PC++;
+		}
+		// Circuit 412 in the patent ensures that when INHIBIT is true,
+		// during the period from IP=7 PC=12 T12, to IP=0 PC=12 T12, the pitch
+		// count is forced to 0; since the initial stop happens right before
+		// the switch to IP=0 PC=0 and this code is located after the switch would
+		// happen, we check for ip=0 inhibit=1, which covers that whole range.
+		// The purpose of Circuit 412 is to prevent a spurious click caused by
+		// the voiced source being fed to the filter before all the values have
+		// been updated during ip=0 when interpolation was inhibited.
+
+		m_pitch_count++;
+		if (m_pitch_count >= m_current_pitch) m_pitch_count = 0;
+		if ((m_interp_period == 0) && m_inhibit) m_pitch_count = 0;
+		m_pitch_count &= 0x1FF;
+		buf_count++;
+		size--;
+	}
+
+empty:
+
+	while (size > 0)
+	{
+		m_subcycle++;
+		if ((m_subcycle == 2) && (m_PC == 12))
+		{
+			m_subcycle = m_subc_reload;
+			m_PC = 0;
+			m_interp_period++;
+			m_interp_period &= 0x7;
+		}
+		else if (m_subcycle == 3)
+		{
+			m_subcycle = m_subc_reload;
+			m_PC++;
+		}
+		buffer[buf_count] = -1;	// should be just -1; actual chip outputs -1 every idle sample; (cf note in data sheet, p 10, table 4)
+		buf_count++;
+		size--;
+	}
+}
+
+/******************************************************************************
+    lattice_filter -- executes one 'full run' of the lattice filter on a
+    specific byte of excitation data, and specific values of all the current k
+    constants,  and returns the resulting sample.
+******************************************************************************/
+
+INT32 tms52xx_device::lattice_filter()
+{
+	// Lattice filter here */
+	// Aug/05/07: redone as unrolled loop, for clarity - LN
+	// Originally Copied verbatim from table I in US patent 4,209,804, now updated
+	// to be in same order as the actual chip does it, not that it matters.
+	// notation equivalencies from table:
+	//      Yn(i) == m_u[n-1]
+	//      Kn = m_current_k[n-1]
+	//      bn = m_x[n-1]
+
+	m_u[10] = matrix_multiply(m_previous_energy, (m_excitation_data<<6));  //Y(11)
+	m_u[9] = m_u[10] - matrix_multiply(m_current_k[9], m_x[9]);
+	m_u[8] = m_u[9] - matrix_multiply(m_current_k[8], m_x[8]);
+	m_u[7] = m_u[8] - matrix_multiply(m_current_k[7], m_x[7]);
+	m_u[6] = m_u[7] - matrix_multiply(m_current_k[6], m_x[6]);
+	m_u[5] = m_u[6] - matrix_multiply(m_current_k[5], m_x[5]);
+	m_u[4] = m_u[5] - matrix_multiply(m_current_k[4], m_x[4]);
+	m_u[3] = m_u[4] - matrix_multiply(m_current_k[3], m_x[3]);
+	m_u[2] = m_u[3] - matrix_multiply(m_current_k[2], m_x[2]);
+	m_u[1] = m_u[2] - matrix_multiply(m_current_k[1], m_x[1]);
+	m_u[0] = m_u[1] - matrix_multiply(m_current_k[0], m_x[0]);
+	m_x[9] = m_x[8] + matrix_multiply(m_current_k[8], m_u[8]);
+	m_x[8] = m_x[7] + matrix_multiply(m_current_k[7], m_u[7]);
+	m_x[7] = m_x[6] + matrix_multiply(m_current_k[6], m_u[6]);
+	m_x[6] = m_x[5] + matrix_multiply(m_current_k[5], m_u[5]);
+	m_x[5] = m_x[4] + matrix_multiply(m_current_k[4], m_u[4]);
+	m_x[4] = m_x[3] + matrix_multiply(m_current_k[3], m_u[3]);
+	m_x[3] = m_x[2] + matrix_multiply(m_current_k[2], m_u[2]);
+	m_x[2] = m_x[1] + matrix_multiply(m_current_k[1], m_u[1]);
+	m_x[1] = m_x[0] + matrix_multiply(m_current_k[0], m_u[0]);
+	m_x[0] = m_u[0];
+	m_previous_energy = m_current_energy;
+#ifdef DEBUG_LATTICE
+
+	int i;
+	fprintf(stderr,"V:%04d ", m_u[10]);
+	for (i = 9; i >= 0; i--)
+	{
+		fprintf(stderr,"Y%d:%04d ", i+1, m_u[i]);
+		fprintf(stderr,"b%d:%04d ", i+1, m_x[i]);
+		if ((i % 5) == 0) fprintf(stderr,"\n");
+	}
+#endif
+	return m_u[0];
+}
+
+/**********************************************************************************************
+    data_write -- handle a write to the TMS5220
+***********************************************************************************************/
+
+void tms52xx_device::data_write(int data)
+{
+#ifdef DEBUG_DUMP_INPUT_DATA
+	fprintf(stdout, "%c",data);
+#endif
+	if (m_speak_external) // If we're in speak external mode
+	{
+		/* add this byte to the FIFO */
+		if (m_fifo_count < FIFO_SIZE)
+		{
+			m_fifo[m_fifo_tail] = data;
+			m_fifo_tail = (m_fifo_tail + 1) % FIFO_SIZE;
+			m_fifo_count++;
+#ifdef DEBUG_FIFO
+			logerror("tms52xx: data_write: Added byte to FIFO (current count=%2d)\n", m_fifo_count);
+#endif
+			update_status_and_ints();
+			if ((!m_talk_status) && (!m_buffer_low)) // we just unset buffer low with that last write, and talk status *was* zero...
+			{
+				int i;
+#ifdef DEBUG_FIFO
+				logerror("tms52xx: data_write triggered talk status to go active!\n");
+#endif
+				// ...then we now have enough bytes to start talking; clear out
+				// the new frame parameters (it will become old frame just before the first call to parse_frame())
+				// TODO: the 3 lines below (and others) are needed for victory
+				// to not fail its selftest due to a sample ending too late, may require additional investigation
+				m_subcycle = m_subc_reload;
+				m_PC = 0;
+				m_interp_period = reload_table[m_tms5220c_rate & 0x3]; // is this correct? should this be always 7 instead, so that the new frame is loaded quickly?
+				m_new_frame_energy_idx = 0;
+				m_new_frame_pitch_idx = 0;
+
+				for (i = 0; i < 4; i++)
+					m_new_frame_k_idx[i] = 0;
+				for (i = 4; i < 7; i++)
+					m_new_frame_k_idx[i] = 0xF;
+				for (i = 7; i < m_coeff->num_k; i++)
+					m_new_frame_k_idx[i] = 0x7;
+				m_talk_status = m_speaking_now = true;
+			}
+		}
+		else
+		{
+#ifdef DEBUG_FIFO
+			logerror("tms52xx: data_write: Ran out of room in the tms52xx FIFO! this should never happen!\n");
+			// at this point, /READY should remain HIGH/inactive until the fifo has at least one byte open in it.
+#endif
+		}
+
+
+	}
+	else //(! m_speak_external)
+		/* R Nabet : we parse commands at once.  It is necessary for such commands as read. */
+		process_command(data);
+}
+
+/******************************************************************************
+    process_command -- extract a byte from the FIFO and interpret it as a command
+*******************************************************************************/
+
+void tms52xx_device::process_command(unsigned char cmd)
+{
+#ifdef DEBUG_COMMAND_DUMP
+	fprintf(stderr,"process_command called with parameter %02X\n",cmd);
+#endif
+	// parse the command
+	switch (cmd & 0x70)
+	{
+	case 0x10 : // read byte
+		if (!m_talk_status) // TALKST must be clear for RDBY
+		{
+			if (m_schedule_dummy_read)
+			{
+				m_schedule_dummy_read = false;
+				(void)m_read_mem(1);
+			}
+			m_data_register = m_read_mem(8);	// read one byte from speech ROM...
+			m_RDB_flag = true;
+		}
+		break;
+
+	case 0x00:
+	case 0x20: // set rate (tms5220c only), otherwise NOP
+		if (m_variant == SUBTYPE_TMS5220C)
+		{
+			m_tms5220c_rate = cmd & 0x0F;
+		}
+		break;
+
+	case 0x30: // read and branch
+		if (!m_talk_status) // TALKST must be clear for RB
+		{
+#ifdef VERBOSE
+			logerror("tms5520: read and branch command received\n");
+#endif
+			m_RDB_flag = false;
+			m_read_and_branch(0, 0);
+		}
+		break;
+
+	case 0x40 : // load address
+		if (!m_talk_status) // TALKST must be clear for LA
+		{
+			// tms5220 data sheet says that if we load only one 4-bit nibble, it won't work.
+			// This code does not care about this.
+			m_load_address(0, cmd & 0x0f);
+			m_schedule_dummy_read = true;
+		}
+		break;
+
+	case 0x50:	// speak
+		if (m_schedule_dummy_read)
+		{
+			m_schedule_dummy_read = false;
+			(void)m_read_mem(1);
+		}
+		m_speaking_now = true;
+		m_speak_external = false;
+		m_talk_status = true;  // start immediately
+		// clear out variables before speaking
+		// TODO: similar to the victory case described above, but for VSM speech
+		m_subcycle = m_subc_reload;
+		m_PC = 0;
+		m_interp_period = reload_table[m_tms5220c_rate & 0x3];
+		m_new_frame_energy_idx = 0;
+		m_new_frame_pitch_idx = 0;
+
+		int i;
+		for (i = 0; i < 4; i++)
+			m_new_frame_k_idx[i] = 0;
+		for (i = 4; i < 7; i++)
+			m_new_frame_k_idx[i] = 0xF;
+		for (i = 7; i < m_coeff->num_k; i++)
+			m_new_frame_k_idx[i] = 0x7;
+		break;
+
+	case 0x60: // speak external
+		if (!m_talk_status) // TALKST must be clear for SPKEXT
+		{
+			//SPKEXT going active activates SPKEE which clears the fifo
+			m_fifo_head = m_fifo_tail = 0;
+			m_fifo_count = m_fifo_bits_taken = 0;
+			m_speak_external = true;
+			m_RDB_flag = false;
+		}
+		break;
+
+	case 0x70: // reset
+		if (m_schedule_dummy_read)
+		{
+			m_schedule_dummy_read = false;
+			(void)m_read_mem(1);
+		}
+		device_reset();
+		break;
+	}
+
+	// update the buffer low state
+	update_status_and_ints();
+}
+
+/******************************************************************************
+    parse_frame -- parse a new frame's worth of data; returns 0 if not
+    enough bits in buffer
+*******************************************************************************/
+
+void tms52xx_device::parse_frame()
+{
+	int indx, i, rep_flag;
+
+	// We actually don't care how many bits are left in the fifo here; the
+	// frame subpart will be processed normally, and any bits extracted 'past
+	// the end' of the fifo will be read as zeroes; the fifo being emptied will
+	// set the /BE latch which will halt speech exactly as if a stop frame had
+	// been encountered (instead of whatever partial frame was read); the same
+	// exact circuitry is used for both on the real chip, see us patent 4335277
+	// sheet 16, gates 232a (decode stop frame) and 232b (decode /BE plus DDIS
+	// (decode disable) which is active during speak external).
+
+	// if the chip is a tms5220C, and the rate mode is set to that each frame (0x04 bit set)
+	// has a 2 bit rate preceding it, grab two bits here and store them as the rate;
+	if ((m_variant == SUBTYPE_TMS5220C) && (m_tms5220c_rate & 0x04))
+	{
+		indx = extract_bits(2);
+#ifdef DEBUG_PARSE_FRAME_DUMP
+		printbits(indx,2);
+		fprintf(stderr," ");
+#endif
+		m_interp_period = reload_table[indx];
+	}
+	else // non-5220C and 5220C in fixed rate mode
+		m_interp_period = reload_table[m_tms5220c_rate & 0x3];
+
+	update_status_and_ints();
+	if (!m_talk_status) goto ranout;
+
+	// attempt to extract the energy index
+	m_new_frame_energy_idx = extract_bits(m_coeff->energy_bits);
+#ifdef DEBUG_PARSE_FRAME_DUMP
+	printbits(m_new_frame_energy_idx,m_coeff->energy_bits);
+	fprintf(stderr," ");
+#endif
+	update_status_and_ints();
+	if (!m_talk_status) goto ranout;
+	// if the energy index is 0 or 15, we're done
+	if ((m_new_frame_energy_idx == 0) || (m_new_frame_energy_idx == 15))
+		return;
+
+	// attempt to extract the repeat flag
+	rep_flag = extract_bits(1);
+#ifdef DEBUG_PARSE_FRAME_DUMP
+	printbits(rep_flag, 1);
+	fprintf(stderr," ");
+#endif
+
+	// attempt to extract the pitch
+	m_new_frame_pitch_idx = extract_bits(m_coeff->pitch_bits);
+#ifdef DEBUG_PARSE_FRAME_DUMP
+	printbits(m_new_frame_pitch_idx, m_coeff->pitch_bits);
+	fprintf(stderr," ");
+#endif
+	update_status_and_ints();
+	if (!m_talk_status) goto ranout;
+	// if this is a repeat frame, just do nothing, it will reuse the
+	// old coefficients's
+	if (rep_flag) return;
+
+	// extract first 4 K coefficients
+	for (i = 0; i < 4; i++)
+	{
+		m_new_frame_k_idx[i] = extract_bits(m_coeff->kbits[i]);
+#ifdef DEBUG_PARSE_FRAME_DUMP
+		printbits(m_new_frame_k_idx[i], m_coeff->kbits[i]);
+		fprintf(stderr," ");
+#endif
+		update_status_and_ints();
+		if (!m_talk_status) goto ranout;
+	}
+
+	// if the pitch index was zero, we only need 4 K's...
+	if (m_new_frame_pitch_idx == 0)
+	{
+		// and the rest of the coefficients are zeroed, but that's done in the generator code
+		return;
+	}
+
+	// If we got here, we need the remaining 6 K's
+	for (i = 4; i < m_coeff->num_k; i++)
+	{
+		m_new_frame_k_idx[i] = extract_bits(m_coeff->kbits[i]);
+#ifdef DEBUG_PARSE_FRAME_DUMP
+		printbits(m_new_frame_k_idx[i], m_coeff->kbits[i]);
+		fprintf(stderr," ");
+#endif
+		update_status_and_ints();
+		if (!m_talk_status) goto ranout;
+	}
+#ifdef VERBOSE
+	if (m_speak_external)
+		logerror("tms52xx: Parsed a frame successfully in FIFO - %d bits remaining\n", (m_fifo_count*8)-(m_fifo_bits_taken));
+	else
+		logerror("tms52xx: Parsed a frame successfully in ROM\n");
+#endif
+	return;
+
+	ranout:
+#ifdef DEBUG_FRAME_ERRORS
+	logerror("tms52xx: Ran out of bits on a parse!\n");
+#endif
+	return;
+}
+
+/**********************************************************************************************
+
+     update_status_and_ints -- check to see if the various flags should be on or off
+     Description of flags, and their position in the status register:
+      From the data sheet:
+        bit D0(bit 7) = TS - Talk Status is active (high) when the VSP is processing speech data.
+                Talk Status goes active at the initiation of a Speak command or after nine
+                bytes of data are loaded into the FIFO following a Speak External command. It
+                goes inactive (low) when the stop code (Energy=1111) is processed, or
+                immediately by a buffer empty condition or a reset command.
+        bit D1(bit 6) = BL - Buffer Low is active (high) when the FIFO buffer is more than half empty.
+                Buffer Low is set when the "Last-In" byte is shifted down past the half-full
+                boundary of the stack. Buffer Low is cleared when data is loaded to the stack
+                so that the "Last-In" byte lies above the half-full boundary and becomes the
+                eighth data byte of the stack.
+        bit D2(bit 5) = BE - Buffer Empty is active (high) when the FIFO buffer has run out of data
+                while executing a Speak External command. Buffer Empty is set when the last bit
+                of the "Last-In" byte is shifted out to the Synthesis Section. This causes
+                Talk Status to be cleared. Speed is terminated at some abnormal point and the
+                Speak External command execution is terminated.
+
+***********************************************************************************************/
+
+void tms52xx_device::update_status_and_ints()
+{
+	// update flags and set ints if needed
+	update_ready_state();
+
+	// BL is set if neither byte 9 nor 8 of the fifo are in use; this
+	// translates to having fifo_count (which ranges from 0 bytes in use to 16
+	// bytes used) being less than or equal to 8. Victory/Victorba depends on this.
+	if (m_fifo_count <= 8)
+	{
+		// generate an interrupt if necessary; if /BL was inactive and is now active, set int.
+		if (!m_buffer_low) set_interrupt_state(1);
+		m_buffer_low = true;
+	}
+	else
+		m_buffer_low = false;
+
+	// BE is set if neither byte 15 nor 14 of the fifo are in use; this
+	// translates to having fifo_count equal to exactly 0 */
+	if (m_fifo_count == 0)
+	{
+		// generate an interrupt if necessary; if /BE was inactive and is now active, set int.
+		if (!m_buffer_empty) set_interrupt_state(1);
+		m_buffer_empty = true;
+	}
+	else
+		m_buffer_empty = false;
+
+	// TS is talk status and is set elsewhere in the fifo parser and in
+	// the SPEAK command handler; however, if /BE is true during speak external
+	// mode, it is immediately unset here.
+	if (m_speak_external && m_buffer_empty)
+	{
+		// generate an interrupt: /TS was active, and is now inactive.
+		if (m_talk_status)
+		{
+			m_talk_status = m_speak_external = false;
+			set_interrupt_state(1);
+		}
+	}
+	// Note that TS being unset will also generate an interrupt when a STOP
+	// frame is encountered; this is handled in the sample generator code and not here */
+}
+
+/******************************************************************************
+    extract_bits -- extract a specific number of bits from the current input stream (FIFO or VSM)
+*******************************************************************************/
+
+int tms52xx_device::extract_bits(int count)
+{
+	int val = 0;
+
+	if (m_speak_external)
+	{
+		// extract from FIFO
+		while (count--)
+		{
+			val = (val << 1) | ((m_fifo[m_fifo_head] >> m_fifo_bits_taken) & 1);
+			m_fifo_bits_taken++;
+			if (m_fifo_bits_taken >= 8)
+			{
+				m_fifo_count--;
+				m_fifo[m_fifo_head] = 0; // zero the newly depleted fifo head byte
+				m_fifo_head = (m_fifo_head + 1) % FIFO_SIZE;
+				m_fifo_bits_taken = 0;
+				update_status_and_ints();
+			}
+		}
+	}
+	else
+	{
+		// extract from VSM (speech ROM)
+		val = m_read_mem(count);
+	}
+	return val;
+}
+
+/******************************************************************************
+    status_read -- read status or data from the TMS5220
+*******************************************************************************/
+
+int tms52xx_device::status_read()
+{
+	if (m_RDB_flag)
+	{	// if last command was read, return data register
+		m_RDB_flag = false;
+		return m_data_register;
+	}
+	else
+	{	// read status
+		// clear the interrupt pin on status read
+		set_interrupt_state(0);
+#ifdef DEBUG_PIN_READS
+		logerror("tms52xx: Status read: TS=%d BL=%d BE=%d\n", m_talk_status, m_buffer_low, m_buffer_empty);
+#endif
+
+		int retvalue = 0;
+		if (m_talk_status) retvalue |= 0x80;
+		if (m_buffer_low) retvalue |= 0x40;
+		if (m_buffer_empty) retvalue |= 0x20;
+		return retvalue;
+	}
+}
+
+/******************************************************************************
+    ready_read -- returns the ready state of the TMS5220
+*******************************************************************************/
+
+inline bool tms52xx_device::ready_read()
+{
+#ifdef DEBUG_PIN_READS
+	logerror("tms52xx: ready_read: ready pin read, io_ready is %d, fifo count is %d\n", m_io_ready, m_fifo_count);
+#endif
+	return ((m_fifo_count < FIFO_SIZE)||(!m_speak_external)) && m_io_ready;
+}
+
+/******************************************************************************
+    int_read -- returns the interrupt state of the TMS5220
+*******************************************************************************/
+
+inline int tms52xx_device::int_read()
+{
+#ifdef DEBUG_PIN_READS
+	logerror("tms52xx: int_read: irq pin read, state is %d\n", m_irq_pin);
+#endif
+	return m_irq_pin;
+}
+
+/******************************************************************************
+    cycles_to_ready -- returns the number of cycles until ready is asserted
+    NOTE: this function is deprecated and is known to be VERY inaccurate.
+    Use at your own peril!
+*******************************************************************************/
+
+int tms52xx_device::cycles_to_ready()
+{
+	int answer;
+
+	if (ready_read()) answer = 0;
+	else
+	{
+		int val;
+		int samples_per_frame = (m_subc_reload!=0)? 200:304; // either (13 A cycles + 12 B cycles) * 8 interps for normal SPEAK/SPKEXT, or (13*2 A cycles + 12 B cycles) * 8 interps for SPKSLOW
+		int current_sample = ((m_PC * (3-m_subc_reload)) + (((m_subc_reload!=0)? 38:25) * m_interp_period));
+		answer = samples_per_frame - current_sample + 8;
+
+		// total number of bits available in current byte is (8 - tms->fifo_bits_taken)
+		// if more than 4 are available, we need to check the energy
+		if (m_fifo_bits_taken < 4)
+		{
+			// read energy
+			val = (m_fifo[m_fifo_head] >> m_fifo_bits_taken) & 0xf;
+			if (val == 0)
+				// 0 -> silence frame: we will only read 4 bits, and we will
+				// therefore need to read another frame before the FIFO is not
+				// full any more
+				answer += 200;
+			// 15 -> stop frame, we will only read 4 bits, but the FIFO will
+			// we cleared
+			//otherwise, we need to parse the repeat flag (1 bit) and the
+			// pitch (6 bits), so everything will be OK.
+		}
+	}
+	return answer;
+}
+
+/******************************************************************************
+    True timing
+*******************************************************************************/
+
+void tms52xx_device::device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr)
+{
+	if (param)
+	{
+		switch (m_rs_ws)
+		{
+		case 0x02:
+			// Write
+			// bring up to date first
+#ifdef DEBUG_IO_READY
+			logerror("tms52xx: Serviced write: %02x\n", tms->write_latch);
+			//fprintf(stderr, "Processed write data: %02X\n", tms->write_latch);
+#endif
+			m_stream->update();
+			data_write(m_write_latch);
+		    break;
+		case 0x01:
+			// Read
+			// bring up to date first
+			m_stream->update();
+			m_read_latch = status_read();
+			break;
+		case 0x03:
+			// High Impedance
+		case 0x00:
+			// illegal
+			break;
+		}
+	}
+	m_io_ready = param;
+	update_ready_state();
+}
+
+/*****************************************************
+    /RS line write handler
+*****************************************************/
+
+WRITE_LINE_MEMBER( tms52xx_device::rsq_w )
+{
+	UINT8 new_val;
+
+	m_true_timing = true;
+	state &= 0x01;
+#ifdef DEBUG_RS_WS
+	logerror("tms52xx: /RS written with data: %d\n", state);
+#endif
+	new_val = (m_rs_ws & 0x01) | (state<<1);
+	if (new_val != m_rs_ws)
+	{
+		m_rs_ws = new_val;
+		if (new_val == 0)
+		{
+			if (m_variant == SUBTYPE_TMS5220C)
+				reset();
+#ifdef DEBUG_RS_WS
+			else
+				// illegal
+				logerror("tms52xx: illegal line setting /RS=0 and /WS=0\n");
+#endif
+			return;
+		}
+		else if (new_val == 3)
+		{
+			// high impedance
+			m_read_latch = 0xff;
+			return;
+		}
+		if (state)
+		{
+			// low to high
+		}
+		else
+		{
+			// high to low - schedule ready cycle
+#ifdef DEBUG_RS_WS
+			logerror("tms52xx: Scheduling ready cycle for /RS...\n");
+#endif
+			// upon /RS being activated, /READY goes inactive after 100 nsec from
+			// data sheet, through 3 asynchronous gates on patent. This is effectively
+			// within one clock, so we immediately set io_ready to 0 and activate the callback. */
+			m_io_ready = 0;
+			update_ready_state();
+			// How long does /READY stay inactive, when /RS is pulled low?
+			// I believe its almost always ~16 clocks (25 usec at 800khz as shown on the datasheet)
+			m_ready_timer->adjust(attotime::from_hz(clock()/16));
+		}
+	}
+}
+
+/*****************************************************
+    /WS line write handler
+*****************************************************/
+
+WRITE_LINE_MEMBER( tms52xx_device::wsq_w )
+{
+	UINT8 new_val;
+
+	m_true_timing = true;
+	state &= 0x01;
+#ifdef DEBUG_RS_WS
+	logerror("tms52xx: /WS written with data: %d\n", state);
+#endif
+	new_val = (m_rs_ws & 0x02) | (state<<0);
+	if (new_val != m_rs_ws)
+	{
+		m_rs_ws = new_val;
+		if (new_val == 0)
+		{
+			if (m_variant == SUBTYPE_TMS5220C)
+				reset();
+#ifdef DEBUG_RS_WS
+			else
+				// illegal
+				logerror("tms52xx: illegal line setting /RS=0 and /WS=0\n");
+#endif
+			return;
+		}
+		else if ( new_val == 3)
+		{
+			// high impedance
+			m_read_latch = 0xff;
+			return;
+		}
+		if (state)
+		{
+			// low to high
+		}
+		else
+		{
+			// high to low - schedule ready cycle
+#ifdef DEBUG_RS_WS
+			logerror("tms52xx: Scheduling ready cycle for /WS...\n");
+#endif
+			// upon /WS being activated, /READY goes inactive after 100 nsec
+			// from data sheet, through 3 asynchronous gates on patent.
+			// This is effectively within one clock, so we immediately set io_ready to 0 and activate the callback.
+			m_io_ready = 0;
+			update_ready_state();
+			// Now comes the complicated part: long does /READY stay inactive
+			// when /WS is pulled low? This depends ENTIRELY on the command written,
+			// or whether the chip is in speak external mode or not...
+			// Speak external mode: ~16 cycles
+			// Command Mode:
+			// SPK: ? cycles
+			// SPKEXT: ? cycles
+			// RDBY: between 60 and 140 cycles
+			// RB: ? cycles (80?)
+			// RST: between 60 and 140 cycles
+			// SET RATE (5220C only): ? cycles (probably ~16)
+
+			// TODO: actually HANDLE the timing differences! currently just assuming always 16 cycles
+			m_ready_timer->adjust(attotime::from_hz(clock()/16));
+		}
+	}
+}
+
+/*****************************************************************************
+    write -- write data to the sound chip
+*******************************************************************************/
+
+WRITE8_MEMBER( tms52xx_device::write )
+{
+#ifdef DEBUG_RS_WS
+	logerror("tms52xx: write data %02x\n", data);
+#endif
+	if (!m_true_timing)
+	{
+		// bring up to date first
+		m_stream->update();
+		data_write(data);
+	}
+	else
+	{
+		// actually in a write?
+#ifdef DEBUG_RS_WS
+		if (!(m_rs_ws == 0x02))
+			logerror("tms52xx: write data written outside ws, status: %02x!\n", m_rs_ws);
+#endif
+		m_write_latch = data;
+	}
+}
+
+/******************************************************************************
+    read -- read status or data from the sound chip
+*******************************************************************************/
+
+READ8_MEMBER( tms52xx_device::read )
+{
+	if (!m_true_timing)
+	{
+		// bring up-to-date first
+		m_stream->update();
+		return status_read();
+	}
+	else
+	{
+		// actually in a read?
+		if (m_rs_ws == 0x01)
+			return m_read_latch;
+#ifdef DEBUG_RS_WS
+		else
+			logerror("tms52xx: data read outside rs!\n");
+#endif
+		return 0xff;
+	}
+}
+
+/*******************************************************************************
+    ready -- return the not ready status from the sound chip
+*******************************************************************************/
+
+READ_LINE_MEMBER( tms52xx_device::readyq )
+{
+	// bring up-to-date first
+	m_stream->update();
+	return !ready_read();
+}
+
+
+/******************************************************************************
+    time_to_ready -- return the time in seconds until the
+    ready line is asserted
+*******************************************************************************/
+
+double tms52xx_device::time_to_ready()
+{
+	double cycles;
+
+	// bring up-to-date
+	m_stream->update();
+	cycles = cycles_to_ready();
+	return cycles * 80.0 / m_clock;
+}
+
+/******************************************************************************
+    intq -- return the interrupt status from the sound chip
+******************************************************************************/
+
+READ_LINE_MEMBER( tms52xx_device::intq )
+{
+	// bring up-to-date first
+	m_stream->update();
+	return !int_read();
+}
+
+void tms52xx_device::register_for_save_states()
+{
+	save_item(NAME(m_fifo));
+	save_item(NAME(m_fifo_head));
+	save_item(NAME(m_fifo_tail));
+	save_item(NAME(m_fifo_count));
+	save_item(NAME(m_fifo_bits_taken));
+
+	save_item(NAME(m_speaking_now));
+	save_item(NAME(m_speak_external));
+	save_item(NAME(m_talk_status));
+	save_item(NAME(m_buffer_low));
+	save_item(NAME(m_buffer_empty));
+	save_item(NAME(m_irq_pin));
+	save_item(NAME(m_ready_pin));
+
+	save_item(NAME(m_OLDE));
+	save_item(NAME(m_OLDP));
+
+	save_item(NAME(m_new_frame_energy_idx));
+	save_item(NAME(m_new_frame_pitch_idx));
+	save_item(NAME(m_new_frame_k_idx));
+#ifdef PERFECT_INTERPOLATION_HACK
+	save_item(NAME(m_old_frame_energy_idx));
+	save_item(NAME(m_old_frame_pitch_idx));
+	save_item(NAME(m_old_frame_k_idx));
+#endif
+	save_item(NAME(m_current_energy));
+	save_item(NAME(m_current_pitch));
+	save_item(NAME(m_current_k));
+
+	save_item(NAME(m_target_energy));
+	save_item(NAME(m_target_pitch));
+	save_item(NAME(m_target_k));
+
+	save_item(NAME(m_previous_energy));
+
+	save_item(NAME(m_subcycle));
+	save_item(NAME(m_subc_reload));
+	save_item(NAME(m_PC));
+	save_item(NAME(m_interp_period));
+	save_item(NAME(m_inhibit));
+	save_item(NAME(m_tms5220c_rate));
+	save_item(NAME(m_pitch_count));
+
+	save_item(NAME(m_u));
+	save_item(NAME(m_x));
+
+	save_item(NAME(m_RNG));
+	save_item(NAME(m_excitation_data));
+
+	save_item(NAME(m_schedule_dummy_read));
+	save_item(NAME(m_data_register));
+	save_item(NAME(m_RDB_flag));
+	save_item(NAME(m_digital_select));
+
+	save_item(NAME(m_io_ready));
+}
+
+
+const device_type TMS5220N = &device_creator<tms5220n_device>;
+const device_type TMS5220CN = &device_creator<tms5220cn_device>;
+const device_type TMC0285N = &device_creator<tmc0285n_device>;
+const device_type TMS5200N = &device_creator<tms5200n_device>;
+
diff -Nru src-old/emu/sound/tms5220.h src/emu/sound/tms5220.h
--- src-old/emu/sound/tms5220.h	2010-12-31 23:42:55.000000000 +0100
+++ src/emu/sound/tms5220.h	2012-06-25 13:29:00.000000000 +0200
@@ -5,6 +5,7 @@
 
 #include "devlegcy.h"
 
+#define FIFO_SIZE 16
 
 /* clock rate = 80 * output sample rate,     */
 /* usually 640000 for 8000 Hz sample rate or */
@@ -47,4 +48,204 @@
 DECLARE_LEGACY_SOUND_DEVICE(TMS5200, tms5200);
 
 
+/***************************************************************************
+        New class implementation
+        Michael Zapf, June 2012
+***************************************************************************/
+
+extern const device_type TMS5220N;
+extern const device_type TMS5220CN;
+extern const device_type TMC0285N;
+extern const device_type TMS5200N;
+
+
+typedef struct _tms52xx_config
+{
+	devcb_write_line		irq_func;					// IRQ callback function, active low, i.e. state=0  (TODO: change to ASSERT/CLEAR)
+	devcb_write_line		readyq_func;				// Ready callback function, active low, i.e. state=0
+
+	devcb_read8				read_mem;					// speech ROM read callback
+	devcb_write8			load_address;				// speech ROM load address callback
+	devcb_write8			read_and_branch;			// speech ROM read and branch callback
+
+} tms52xx_config;
+
+// Change back from 5220n to 5220 when all client drivers will be converted
+class tms52xx_device : public device_t, public device_sound_interface
+{
+public:
+	tms52xx_device(const machine_config &mconfig, device_type type,  const char *name, const char *tag, const struct tms5100_coeffs* coeffs, const int var, device_t *owner, UINT32 clock);
+	void sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples);
+	void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
+
+	DECLARE_WRITE_LINE_MEMBER( rsq_w );
+	DECLARE_WRITE_LINE_MEMBER( wsq_w );
+	DECLARE_WRITE8_MEMBER( write );
+	DECLARE_READ8_MEMBER( read );
+	DECLARE_READ_LINE_MEMBER( readyq );
+	DECLARE_READ_LINE_MEMBER( intq );
+
+	double time_to_ready();
+
+protected:
+	void device_start();
+	void device_reset();
+
+private:
+	// Methods
+	void set_interrupt_state(int state);
+	void register_for_save_states();
+	void update_ready_state();
+	void set_frequency(int frequency);
+	void process(INT16 *buffer, unsigned int size);
+	void data_write(int data);
+	void update_status_and_ints();
+	void parse_frame();
+
+	int extract_bits(int count);
+	int status_read();
+	int cycles_to_ready();
+	INT32 lattice_filter();
+	void process_command(unsigned char cmd);
+
+	inline bool ready_read();
+	inline int int_read();
+
+	// coefficient tables
+	const int m_variant;				// Variant of the 5xxx - see tms5110r.h
+
+	// coefficient tables
+	const struct tms5100_coeffs *m_coeff;
+
+	// callbacks
+	devcb_resolved_write_line	m_irq_func;
+	devcb_resolved_write_line	m_readyq_func;
+	devcb_resolved_read8		m_read_mem;
+	devcb_resolved_write8		m_load_address;
+	devcb_resolved_write8		m_read_and_branch;
+
+	// these contain data that describes the 128-bit data FIFO
+	UINT8	m_fifo[FIFO_SIZE];
+	UINT8	m_fifo_head;
+	UINT8	m_fifo_tail;
+	int		m_fifo_count;
+	int		m_fifo_bits_taken;
+
+	// these contain global status bits
+	bool	m_speaking_now;		// True only if actual speech is being generated right now. Is set when a speak vsm command happens OR when speak external happens and buffer low becomes nontrue; Is cleared when speech halts after the last stop frame or the last frame after talk status is otherwise cleared.
+	bool	m_speak_external;	// If 1, DDIS is 1, i.e. Speak External command in progress, writes go to FIFO.
+	bool	m_talk_status;		// If 1, TS status bit is 1, i.e. speak or speak external is in progress and we have not encountered a stop frame yet; talk_status differs from speaking_now in that speaking_now is set as soon as a speak or speak external command is started; talk_status does NOT go active until after 8 bytes are written to the fifo on a speak external command, otherwise the two are the same. TS is cleared by 3 things: 1. when a STOP command has just been processed as a new frame in the speech stream; 2. if the fifo runs out in speak external mode; 3. on power-up/during a reset command; When it gets cleared, speak_external is also cleared, an interrupt is generated, and speaking_now will be cleared when the next frame starts.
+	bool	m_buffer_low;		// If 1, FIFO has less than 8 bytes in it
+	bool	m_buffer_empty;		// If 1, FIFO is empty
+	int		m_irq_pin;			// state of the IRQ pin (output)
+	int		m_ready_pin;		// state of the READY pin (output)
+
+	// these contain data describing the current and previous voice frames
+#define M_OLD_FRAME_SILENCE_FLAG m_OLDE // 1 if E=0, 0 otherwise.
+#define M_OLD_FRAME_UNVOICED_FLAG m_OLDP // 1 if P=0 (unvoiced), 0 if voiced
+	bool	m_OLDE;
+	bool	m_OLDP;
+
+#define M_NEW_FRAME_STOP_FLAG (m_new_frame_energy_idx == 0xF)		// 1 if this is a stop (Energy = 0xF) frame
+#define M_NEW_FRAME_SILENCE_FLAG (m_new_frame_energy_idx == 0)	// ditto as above
+#define M_NEW_FRAME_UNVOICED_FLAG (m_new_frame_pitch_idx == 0)	// ditto as above
+	int		m_new_frame_energy_idx;
+	int		m_new_frame_pitch_idx;
+	int		m_new_frame_k_idx[10];
+
+	// these are all used to contain the current state of the sound generation
+#ifndef PERFECT_INTERPOLATION_HACK
+	INT16	m_current_energy;
+	INT16	m_current_pitch;
+	INT16	m_current_k[10];
+
+	INT16	m_target_energy;
+	INT16	m_target_pitch;
+	INT16	m_target_k[10];
+#else
+	int 	m_old_frame_energy_idx;
+	int		m_old_frame_pitch_idx;
+	int		m_old_frame_k_idx[10];
+
+	INT32	m_current_energy;
+	INT32	m_current_pitch;
+	INT32	m_current_k[10];
+
+	INT32	m_target_energy;
+	INT32	m_target_pitch;
+	INT32	m_target_k[10];
+#endif
+
+	UINT16	m_previous_energy;	// needed for lattice filter to match patent
+	int 	m_subcycle;			// contains the current subcycle for a given PC: 0 is A' (only used on SPKSLOW mode on 51xx), 1 is A, 2 is B
+	int 	m_subc_reload;		// contains 1 for normal speech, 0 when SPKSLOW is active
+	int		m_PC;				// current parameter counter (what param is being interpolated), ranges from 0 to 12
+
+	// TODO/NOTE: the current interpolation period, counts 1,2,3,4,5,6,7,0 for divide by 8,8,8,4,4,4,2,1
+	int 	m_interp_period;	// the current interpolation period
+	bool	m_inhibit;			// If 1, interpolation is inhibited until the DIV1 period
+	UINT8	m_tms5220c_rate;	// only relevant for tms5220C's multi frame rate feature; is the actual 4 bit value written on a 0x2* or 0x0* command
+	UINT16	m_pitch_count;		// pitch counter; provides chirp rom address
+
+	INT32	m_u[11];
+	INT32	m_x[10];
+
+	UINT16	m_RNG;      // the random noise generator configuration is: 1 + x + x^3 + x^4 + x^13
+	INT16	m_excitation_data;
+
+	// R Nabet : These have been added to emulate speech Roms
+	bool	m_schedule_dummy_read;	// set after each load address, so that next read operation is preceded by a dummy read
+	UINT8	m_data_register;		// data register, used by read command
+	bool	m_RDB_flag;				// whether we should read data register or status register
+
+	// io_ready: page 3 of the datasheet specifies that READY will be asserted until
+	// data is available or processed by the system.
+	int		m_io_ready;
+
+	// flag for "true" timing involving rs/ws
+	bool	m_true_timing;
+
+	// rsws - state, rs bit 1, ws bit 0
+	int		m_rs_ws;
+	UINT8	m_read_latch;
+	UINT8	m_write_latch;
+
+	// The TMS52xx has two different ways of providing output data: the
+	// analog speaker pin (which was usually used) and the Digital I/O pin.
+	// The internal DAC used to feed the analog pin is only 8 bits, and has the
+	// funny clipping/clamping logic, while the digital pin gives full 12? bit
+	// resolution of the output data.
+	// TODO: add a way to set/reset this other than the FORCE_DIGITAL define
+	bool			m_digital_select;
+
+	sound_stream	*m_stream;
+
+	emu_timer		*m_ready_timer;
+};
+
+class tms5220n_device : public tms52xx_device
+{
+public:
+	tms5220n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+};
+
+class tms5220cn_device : public tms52xx_device
+{
+public:
+	tms5220cn_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+};
+
+class tmc0285n_device : public tms52xx_device
+{
+public:
+	tmc0285n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+};
+
+class tms5200n_device : public tms52xx_device
+{
+public:
+	tms5200n_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+};
+
+
 #endif /* __TMS5220_H__ */
diff -Nru src-old/emu/video/hd63484.c src/emu/video/hd63484.c
--- src-old/emu/video/hd63484.c	2011-09-13 03:51:48.000000000 +0200
+++ src/emu/video/hd63484.c	2012-06-12 02:09:44.000000000 +0200
@@ -7,6 +7,7 @@
   - shanghai.c
   - adp.c
   - sigmab52.c
+  - wildpkr.c
 
   ACRTC memory map:
 
diff -Nru src-old/emu/video/pc_cga.c src/emu/video/pc_cga.c
--- src-old/emu/video/pc_cga.c	2012-06-08 18:51:36.000000000 +0200
+++ src/emu/video/pc_cga.c	2012-06-21 08:40:19.000000000 +0200
@@ -224,10 +224,16 @@
 MACHINE_CONFIG_END
 
 MACHINE_CONFIG_FRAGMENT( pcvideo_mc1502 )
-	MCFG_FRAGMENT_ADD( pcvideo_cga )
-	MCFG_VIDEO_START( cga_mc1502 )
-	MCFG_SCREEN_MODIFY(CGA_SCREEN_NAME)
+	MCFG_SCREEN_ADD(CGA_SCREEN_NAME, RASTER)
+	MCFG_SCREEN_RAW_PARAMS(XTAL_16MHz,912,0,640,262,0,200)
 	MCFG_SCREEN_UPDATE_STATIC( cga_poisk2 )
+
+	MCFG_PALETTE_LENGTH(/* CGA_PALETTE_SETS * 16*/ 65536 )
+	MCFG_PALETTE_INIT(pc_cga)
+
+	MCFG_MC6845_ADD(CGA_MC6845_NAME, MC6845, XTAL_16MHz/8, mc6845_cga_intf)
+
+	MCFG_VIDEO_START( cga_mc1502 )
 MACHINE_CONFIG_END
 
 MACHINE_CONFIG_FRAGMENT( pcvideo_pc1512 )
diff -Nru src-old/emu/video/polynew.h src/emu/video/polynew.h
--- src-old/emu/video/polynew.h	2012-04-22 04:47:03.000000000 +0200
+++ src/emu/video/polynew.h	2012-06-13 15:14:27.000000000 +0200
@@ -690,6 +690,12 @@
 			}
 		}
 	}
+    else    // GCC 4.7.0 incorrectly claims these are uninitialized; humor it by initializing in the (hopefully rare) zero parameter case
+    {
+        param_start[0] = _BaseType(0.0);
+        param_dpdx[0] = _BaseType(0.0);
+        param_dpdy[0] = _BaseType(0.0);
+    }
 
 	// compute the X extents for each scanline
 	INT32 pixels = 0;
diff -Nru src-old/lib/formats/esq8_dsk.c src/lib/formats/esq8_dsk.c
--- src-old/lib/formats/esq8_dsk.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/formats/esq8_dsk.c	2012-07-02 09:06:11.000000000 +0200
@@ -0,0 +1,164 @@
+/*********************************************************************
+
+    formats/esq8_dsk.c
+
+    Formats for 8-bit Ensoniq synthesizers and samplers
+
+    Disk is PC MFM, 40 tracks, single (Mirage) or double (SQ-80) sided,
+    with 6 sectors per track.
+    Sectors 0-4 are 1024 bytes, sector 5 is 512 bytes
+
+*********************************************************************/
+
+#include "emu.h"
+#include "flopimg.h"
+#include "formats/esq8_dsk.h"
+
+const floppy_image_format_t::desc_e esq8img_format::esq_6_desc[] = {
+	{ MFM, 0x4e, 80 },
+	{ MFM, 0x00, 12 },
+	{ RAW, 0x5224, 3 },
+	{ MFM, 0xfc, 1 },
+	{ MFM, 0x4e, 50 },
+	{ MFM, 0x00, 12 },
+	{ SECTOR_LOOP_START, 0, 5 },
+	{   CRC_CCITT_START, 1 },
+	{     RAW, 0x4489, 3 },
+	{     MFM, 0xfe, 1 },
+	{     TRACK_ID },
+	{     HEAD_ID },
+	{     SECTOR_ID },
+	{     SIZE_ID },
+	{   CRC_END, 1 },
+	{   CRC, 1 },
+	{   MFM, 0x4e, 22 },
+	{   MFM, 0x00, 12 },
+	{   CRC_CCITT_START, 2 },
+	{     RAW, 0x4489, 3 },
+	{     MFM, 0xfb, 1 },
+	{     SECTOR_DATA, -1 },
+	{   CRC_END, 2 },
+	{   CRC, 2 },
+	{   MFM, 0x4e, 84 },
+	{   MFM, 0x00, 12 },
+	{ SECTOR_LOOP_END },
+	{ MFM, 0x4e, 170 },
+	{ END }
+};
+
+esq8img_format::esq8img_format()
+{
+}
+
+const char *esq8img_format::name() const
+{
+	return "img";
+}
+
+const char *esq8img_format::description() const
+{
+	return "Ensoniq Mirage/SQ-80 floppy disk image";
+}
+
+const char *esq8img_format::extensions() const
+{
+	return "img";
+}
+
+bool esq8img_format::supports_save() const
+{
+	return true;
+}
+
+void esq8img_format::find_size(io_generic *io, int &track_count, int &head_count, int &sector_count)
+{
+	int size = io_generic_size(io);
+	track_count = 80;
+    head_count = 1;
+	sector_count = 6;
+
+    if (size == 5632 * 80)
+    {
+        return;
+    }
+
+    track_count = head_count = sector_count = 0;
+}
+
+int esq8img_format::identify(io_generic *io, UINT32 form_factor)
+{
+	int track_count, head_count, sector_count;
+	find_size(io, track_count, head_count, sector_count);
+
+	if(track_count)
+		return 50;
+	return 0;
+}
+
+bool esq8img_format::load(io_generic *io, UINT32 form_factor, floppy_image *image)
+{
+	int track_count, head_count, sector_count;
+	find_size(io, track_count, head_count, sector_count);
+
+	UINT8 sectdata[(5*1024) + 512];
+	desc_s sectors[6];
+	for(int i=0; i<sector_count; i++) {
+        if (i < 5)
+        {
+            sectors[i].data = sectdata + (1024*i);  // 5 1024 byte sectors
+            sectors[i].size = 1024;
+            sectors[i].sector_id = i;
+        }
+        else
+        {
+            sectors[i].data = sectdata + (5*1024);  // 1 512 byte sector
+            sectors[i].size = 512;
+            sectors[i].sector_id = i;
+        }
+	}
+
+	int track_size = (5*1024) + 512;
+
+	for(int track=0; track < track_count; track++)
+    {
+		for(int head=0; head < head_count; head++)
+        {
+			io_generic_read(io, sectdata, (track*head_count + head)*track_size, track_size);
+			generate_track(esq_6_desc, track, head, sectors, sector_count, 109376, image);
+		}
+	}
+
+	image->set_variant(floppy_image::DSDD);
+
+	return true;
+}
+
+bool esq8img_format::save(io_generic *io, floppy_image *image)
+{
+	int track_count, head_count, sector_count;
+	get_geometry_mfm_pc(image, 2000, track_count, head_count, sector_count);
+
+	if(track_count != 80)
+		track_count = 80;
+
+	// Happens for a fully unformatted floppy
+	if(!head_count)
+		head_count = 1;
+
+	if(sector_count != 6)
+		sector_count = 6;
+
+	UINT8 sectdata[10*512];
+	int track_size = (5*1024) + 512;
+
+	for(int track=0; track < track_count; track++) {
+		for(int head=0; head < head_count; head++) {
+			get_track_data_mfm_pc(track, head, image, 2000, 512, sector_count, sectdata);
+			io_generic_write(io, sectdata, (track*head_count + head)*track_size, track_size);
+		}
+	}
+
+	return true;
+}
+
+const floppy_format_type FLOPPY_ESQ8IMG_FORMAT = &floppy_image_format_creator<esq8img_format>;
diff -Nru src-old/lib/formats/esq8_dsk.h src/lib/formats/esq8_dsk.h
--- src-old/lib/formats/esq8_dsk.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/formats/esq8_dsk.h	2012-07-02 09:06:11.000000000 +0200
@@ -0,0 +1,40 @@
+/*********************************************************************
+
+    formats/esq8_dsk.h
+
+    Formats for 8-bit Ensoniq synthesizers and samplers
+
+    Disk is PC MFM, 40 tracks, single (Mirage) or double (SQ-80) sided,
+    with 6 sectors per track.
+    Sectors 0-4 are 1024 bytes, sector 5 is 512 bytes
+
+*********************************************************************/
+
+#ifndef ESQ8_DSK_H_
+#define ESQ8_DSK_H_
+
+#include "flopimg.h"
+
+class esq8img_format : public floppy_image_format_t
+{
+public:
+	esq8img_format();
+
+	virtual int identify(io_generic *io, UINT32 form_factor);
+	virtual bool load(io_generic *io, UINT32 form_factor, floppy_image *image);
+	virtual bool save(io_generic *io, floppy_image *image);
+
+	virtual const char *name() const;
+	virtual const char *description() const;
+	virtual const char *extensions() const;
+	virtual bool supports_save() const;
+
+	static const desc_e esq_6_desc[];
+
+private:
+	void find_size(io_generic *io, int &track_count, int &head_count, int &sector_count);
+};
+
+extern const floppy_format_type FLOPPY_ESQ8IMG_FORMAT;
+
+#endif /* ESQ8_DSK_H_ */
diff -Nru src-old/lib/lib.mak src/lib/lib.mak
--- src-old/lib/lib.mak	2012-05-27 23:03:38.000000000 +0200
+++ src/lib/lib.mak	2012-06-18 08:23:28.000000000 +0200
@@ -117,6 +117,7 @@
 	$(LIBOBJ)/formats/dfi_dsk.o		\
 	$(LIBOBJ)/formats/dim_dsk.o		\
 	$(LIBOBJ)/formats/dsk_dsk.o		\
+	$(LIBOBJ)/formats/esq8_dsk.o	\
 	$(LIBOBJ)/formats/esq16_dsk.o	\
 	$(LIBOBJ)/formats/fdi_dsk.o		\
 	$(LIBOBJ)/formats/fm7_cas.o		\
diff -Nru src-old/lib/util/cdrom.c src/lib/util/cdrom.c
--- src-old/lib/util/cdrom.c	2012-04-30 08:44:14.000000000 +0200
+++ src/lib/util/cdrom.c	2012-06-17 22:00:37.000000000 +0200
@@ -734,6 +734,7 @@
 		{
 			/* parse the metadata */
 			type[0] = subtype[0] = 0;
+            pgtype[0] = pgsub[0] = 0;
 			if (sscanf(metadata, CDROM_TRACK_METADATA_FORMAT, &tracknum, type, subtype, &frames) != 4)
 				return CHDERR_INVALID_DATA;
 			if (tracknum == 0 || tracknum > CD_MAX_TRACKS)
diff -Nru src-old/lib/util/chd.c src/lib/util/chd.c
--- src-old/lib/util/chd.c	2012-05-18 19:44:15.000000000 +0200
+++ src/lib/util/chd.c	2012-06-17 22:00:37.000000000 +0200
@@ -1788,6 +1788,7 @@
 		compressed[12] = lengthbits;
 		compressed[13] = selfbits;
 		compressed[14] = parentbits;
+        compressed[15] = 0;
 
 		// write the result
 		m_mapoffset = file_append(compressed, complen + 16);
diff -Nru src-old/lib/util/huffman.c src/lib/util/huffman.c
--- src-old/lib/util/huffman.c	2012-02-19 17:23:23.000000000 +0100
+++ src/lib/util/huffman.c	2012-06-17 22:00:37.000000000 +0200
@@ -535,7 +535,11 @@
 {
 	const node_t *node1 = *(const node_t **)item1;
 	const node_t *node2 = *(const node_t **)item2;
-	return node2->m_weight - node1->m_weight;
+	if (node2->m_weight != node1->m_weight)
+	    return node2->m_weight - node1->m_weight;
+	if (node2->m_bits - node1->m_bits == 0)
+	    fprintf(stderr, "identical node sort keys, should not happen!\n");
+	return (int)node1->m_bits - (int)node2->m_bits;
 }
 
 
@@ -555,16 +559,28 @@
 		{
 			list[listitems++] = &m_huffnode[curcode];
 			m_huffnode[curcode].m_count = m_datahisto[curcode];
+			m_huffnode[curcode].m_bits = curcode;
 
 			// scale the weight by the current effective length, ensuring we don't go to 0
 			m_huffnode[curcode].m_weight = UINT64(m_datahisto[curcode]) * UINT64(totalweight) / UINT64(totaldata);
 			if (m_huffnode[curcode].m_weight == 0)
 				m_huffnode[curcode].m_weight = 1;
 		}
-
+/*
+        fprintf(stderr, "Pre-sort:\n");
+        for (int i = 0; i < listitems; i++) {
+            fprintf(stderr, "weight: %d code: %d\n", list[i]->m_weight, list[i]->m_bits);
+        }
+*/
 	// sort the list by weight, largest weight first
 	qsort(list, listitems, sizeof(list[0]), tree_node_compare);
-
+/*
+        fprintf(stderr, "Post-sort:\n");
+        for (int i = 0; i < listitems; i++) {
+            fprintf(stderr, "weight: %d code: %d\n", list[i]->m_weight, list[i]->m_bits);
+        }
+        fprintf(stderr, "===================\n");
+*/
 	// now build the tree
 	int nextalloc = m_numcodes;
 	while (listitems > 1)
@@ -597,6 +613,7 @@
 	{
 		node_t &node = m_huffnode[curcode];
 		node.m_numbits = 0;
+		node.m_bits = 0;
 
 		// if we have a non-zero weight, compute the number of bits
 		if (node.m_weight > 0)
diff -Nru src-old/mame/audio/jaguar.c src/mame/audio/jaguar.c
--- src-old/mame/audio/jaguar.c	2012-05-24 14:25:59.000000000 +0200
+++ src/mame/audio/jaguar.c	2012-06-25 00:10:34.000000000 +0200
@@ -134,7 +134,7 @@
     F1D400          R     xxxxxxxx xxxxxxxx   ROM_AMSINE - amplitude modulated sine wave
     F1D600          R     xxxxxxxx xxxxxxxx   ROM_12W - sine wave and second order harmonic
     F1D800          R     xxxxxxxx xxxxxxxx   ROM_CHIRP16 - chirp
-    F1DA00          R     xxxxxxxx xxxxxxxx   ROM_NTRI - traingle wave with noise
+    F1DA00          R     xxxxxxxx xxxxxxxx   ROM_NTRI - triangle wave with noise
     F1DC00          R     xxxxxxxx xxxxxxxx   ROM_DELTA - spike
     F1DE00          R     xxxxxxxx xxxxxxxx   ROM_NOISE - white noise
     ------------------------------------------------------------
@@ -250,7 +250,7 @@
 		/* F1D800 = chirp (sine wave of increasing frequency) */
 		jaguar_wave_rom[0x200 + i] = (int)(32767. * sin(2.0 * M_PI * (double)i / (double)0x80));
 
-		/* F1DA00 = traingle wave with noise */
+		/* F1DA00 = triangle wave with noise */
 		jaguar_wave_rom[0x280 + i] = jaguar_wave_rom[0x000 + i] * (machine.rand() % 32768) / 32768;
 
 		/* F1DC00 = spike */
diff -Nru src-old/mame/audio/taito_en.c src/mame/audio/taito_en.c
--- src-old/mame/audio/taito_en.c	2012-06-11 10:00:48.000000000 +0200
+++ src/mame/audio/taito_en.c	2012-06-23 21:20:14.000000000 +0200
@@ -311,7 +311,7 @@
  *************************************/
 
 MACHINE_CONFIG_FRAGMENT( taito_en_sound )
-	MCFG_CPU_ADD("audiocpu", M68000, XTAL_16MHz)
+	MCFG_CPU_ADD("audiocpu", M68000, XTAL_30_4761MHz / 2)
 	MCFG_CPU_PROGRAM_MAP(en_sound_map)
 
 	MCFG_DUART68681_ADD("duart68681", XTAL_16MHz / 4, taito_en_duart68681_config)
diff -Nru src-old/mame/drivers/8080bw.c src/mame/drivers/8080bw.c
--- src-old/mame/drivers/8080bw.c	2012-05-24 15:34:04.000000000 +0200
+++ src/mame/drivers/8080bw.c	2012-07-02 09:06:11.000000000 +0200
@@ -184,6 +184,7 @@
 #include "cpu/m6800/m6800.h"
 #include "cpu/i8085/i8085.h"
 #include "machine/mb14241.h"
+#include "machine/eeprom.h"
 #include "sound/speaker.h"
 #include "includes/8080bw.h"
 
@@ -2004,8 +2005,6 @@
 
 */
 
-
-
 static MACHINE_START( darthvdr )
 {
 	/* do nothing for now - different interrupt system */
@@ -2083,6 +2082,8 @@
 
 MACHINE_CONFIG_END
 
+
+
 /*************************************
  *
  * Vortex (by Zilec AKA Zenitone-Microsec)
@@ -2213,6 +2214,8 @@
 	auto_free(machine, buf1);
 }
 
+
+
 /* unknown gun game by Model Racing, possibly Gun Champ?
 
 BOARD 1:
@@ -2356,6 +2359,8 @@
 
 MACHINE_CONFIG_END
 
+
+
 /* Taito Galactica / Space Missile
 This game was officially only distributed in Brazil.
 Not much information is avaliable. It is speculated that the original is "Space Missile", whose manufacturer was sued by Taito in Japan.
@@ -2411,6 +2416,155 @@
 INPUT_PORTS_END
 
 
+
+/*****************************************************
+
+ Space Invaders Multigame kit, Braze Technologies,
+ produced from 2002(version 1A) to 2006(version 3D).
+ This is an 8-in-1 hack on a daughterboard, containing:
+
+ - 8080 CPU taken from main PCB
+ - SST 29EE010 or AM27C010 (or other similar) 128KB EEPROM
+   (EEPROM functionality not used)
+ - 93C46P E2PROM for saving highscore/settings
+ - PALCE22V10H-25PC/4
+
+ The kit is compatible with the original Midway boardset
+
+******************************************************/
+
+static INPUT_PORTS_START( invmulti )
+	/* same as Midway Space Invaders, except that SW is unused */
+	PORT_START("IN0")
+	PORT_DIPUNUSED_DIPLOC( 0x01, 0x00, "SW:8" )
+	PORT_BIT( 0x06, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, mw8080bw_state,invaders_sw6_sw7_r, NULL)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW,  IPT_UNUSED )
+	PORT_BIT( 0x70, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, mw8080bw_state,invaders_in0_control_r, NULL)
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, mw8080bw_state,invaders_sw5_r, NULL)
+
+	PORT_START("IN1")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW,  IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, mw8080bw_state,invaders_coin_input_r, NULL)
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START2 )
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_START1 )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW,  IPT_UNUSED )
+	PORT_BIT( 0x70, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, mw8080bw_state,invaders_in1_control_r, NULL)
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNUSED )
+
+	PORT_START("IN2")
+	PORT_DIPUNUSED_DIPLOC( 0x01, 0x00, "SW:3" )
+	PORT_DIPUNUSED_DIPLOC( 0x02, 0x00, "SW:4" )
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_UNUSED )
+	PORT_DIPUNUSED_DIPLOC( 0x08, 0x00, "SW:2" )
+	PORT_BIT( 0x70, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, mw8080bw_state,invaders_in2_control_r, NULL)
+	PORT_DIPUNUSED_DIPLOC( 0x80, 0x00, "SW:1" )
+
+	/* fake port for reading the coin input */
+	PORT_START(INVADERS_COIN_INPUT_PORT_TAG)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW,  IPT_COIN1 )
+	PORT_BIT( 0xfe, IP_ACTIVE_HIGH, IPT_UNUSED )
+
+	/* fake port for cabinet type */
+	PORT_START(INVADERS_CAB_TYPE_PORT_TAG)
+	PORT_CONFNAME( 0x01, 0x00, DEF_STR( Cabinet ) )
+	PORT_CONFSETTING(    0x00, DEF_STR( Upright ) )
+	PORT_CONFSETTING(    0x01, DEF_STR( Cocktail ) )
+	PORT_BIT( 0xfe, IP_ACTIVE_HIGH, IPT_UNUSED )
+
+	/* fake ports for handling the various input ports based on cabinet type */
+	PORT_START(INVADERS_SW6_SW7_PORT_TAG)
+	PORT_DIPUNUSED_DIPLOC( 0x01, 0x00, "SW:7" )
+	PORT_DIPUNUSED_DIPLOC( 0x02, 0x00, "SW:6" )
+	PORT_BIT( 0xfc, IP_ACTIVE_HIGH, IPT_UNUSED )
+
+	PORT_START(INVADERS_SW5_PORT_TAG)
+	PORT_DIPUNUSED_DIPLOC( 0x01, 0x00, "SW:5" )
+	PORT_BIT( 0xfe, IP_ACTIVE_HIGH, IPT_UNUSED )
+
+	PORT_START(INVADERS_P1_CONTROL_PORT_TAG)
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_PLAYER(1)
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_2WAY PORT_PLAYER(1)
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_PLAYER(1)
+	PORT_BIT( 0xf8, IP_ACTIVE_HIGH, IPT_UNUSED )
+
+	PORT_START(INVADERS_P2_CONTROL_PORT_TAG)
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_PLAYER(2)
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_2WAY PORT_PLAYER(2)
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_PLAYER(2)
+	PORT_BIT( 0xf8, IP_ACTIVE_HIGH, IPT_UNUSED )
+INPUT_PORTS_END
+
+static ADDRESS_MAP_START( invmulti_map, AS_PROGRAM, 8, _8080bw_state )
+	AM_RANGE(0x0000, 0x1fff) AM_MIRROR(0x8000) AM_ROMBANK("bank1")
+	AM_RANGE(0x2000, 0x3fff) AM_MIRROR(0x8000) AM_RAM AM_SHARE("main_ram")
+	AM_RANGE(0x4000, 0x5fff) AM_MIRROR(0x8000) AM_ROMBANK("bank2")
+	AM_RANGE(0x6000, 0x6000) AM_MIRROR(0x1fff) AM_READWRITE(invmulti_eeprom_r, invmulti_eeprom_w)
+	AM_RANGE(0xe000, 0xe000) AM_MIRROR(0x1fff) AM_WRITE(invmulti_bank_w)
+ADDRESS_MAP_END
+
+READ8_MEMBER(_8080bw_state::invmulti_eeprom_r)
+{
+	eeprom_device *eeprom = machine().device<eeprom_device>("eeprom");
+	return eeprom->read_bit();
+}
+
+WRITE8_MEMBER(_8080bw_state::invmulti_eeprom_w)
+{
+	eeprom_device *eeprom = machine().device<eeprom_device>("eeprom");
+
+	// d0: latch bit
+	eeprom->write_bit(data & 1);
+
+	// d6: reset
+	eeprom->set_cs_line((data & 0x40) ? CLEAR_LINE : ASSERT_LINE);
+
+	// d4: write latch or select next bit to read
+	eeprom->set_clock_line((data & 0x10) ? ASSERT_LINE : CLEAR_LINE);
+}
+
+WRITE8_MEMBER(_8080bw_state::invmulti_bank_w)
+{
+	// d0, d4, d6: bank
+	int bank = (data & 1) | (data >> 3 & 2) | (data >> 4 & 4);
+	membank("bank1")->set_base(memregion("maincpu")->base() + bank * 0x4000 + 0x0000);
+	membank("bank2")->set_base(memregion("maincpu")->base() + bank * 0x4000 + 0x2000);
+}
+
+static MACHINE_RESET( invmulti )
+{
+	_8080bw_state *state = machine.driver_data<_8080bw_state>();
+
+	state->invmulti_bank_w(*state->m_maincpu->memory().space(AS_PROGRAM), 0, 0);
+
+	MACHINE_RESET_CALL(mw8080bw);
+}
+
+MACHINE_CONFIG_DERIVED_CLASS( invmulti, invaders, _8080bw_state )
+
+	/* basic machine hardware */
+	MCFG_CPU_MODIFY("maincpu")
+	MCFG_CPU_PROGRAM_MAP(invmulti_map)
+
+	MCFG_EEPROM_93C46_8BIT_ADD("eeprom")
+
+	MCFG_MACHINE_RESET(invmulti)
+
+MACHINE_CONFIG_END
+
+static DRIVER_INIT( invmulti )
+{
+	UINT8 *src = machine.root_device().memregion("user1")->base();
+	int len = machine.root_device().memregion("user1")->bytes();
+	UINT8 *dest = machine.root_device().memregion("maincpu")->base();
+
+	// decrypt rom
+	for (int i = 0; i < len; i++)
+		dest[i] = BITSWAP8(src[(i & 0x100ff) | (BITSWAP8(i >> 8 & 0xff, 7,3,4,5,0,6,1,2) << 8)],0,6,5,7,4,3,1,2);
+}
+
+
+
+/**************************************************************************************************************/
+
 ROM_START( searthin )
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "earthinv.h",   0x0000, 0x0800, CRC(58a750c8) SHA1(90bfa4ea06f38e67fe4286d37d151632439249d2) )
@@ -3127,6 +3281,77 @@
 ROM_END
 
 
+ROM_START( invmulti )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00 ) // decrypted rom goes here
+
+	ROM_REGION( 0x20000, "user1", 0 )
+	ROM_LOAD("m803d.bin", 0x00000, 0x20000, CRC(6a62cb3c) SHA1(eb7b567098ad596859f417dd5c59c2cf1ebf1154) )
+ROM_END
+
+ROM_START( invmultim3a )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00 )
+
+	ROM_REGION( 0x20000, "user1", 0 )
+	ROM_LOAD("m803a.bin", 0x00000, 0x20000, CRC(6d538828) SHA1(9a80c67abd32c4c8cd04320501a2aa4e2a308fc9) )
+ROM_END
+
+ROM_START( invmultim2c )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00 )
+
+	ROM_REGION( 0x20000, "user1", 0 )
+	ROM_LOAD("m802c.bin", 0x00000, 0x20000, CRC(5b537de5) SHA1(4d8a6b622b818e88383d011c25f8f34b7372db6d) )
+ROM_END
+
+ROM_START( invmultim2a )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00 )
+
+	ROM_REGION( 0x20000, "user1", 0 )
+	ROM_LOAD("m802a.bin", 0x00000, 0x20000, CRC(8079b1d0) SHA1(b13d910f314550eef468ee819b92788d2a002d82) )
+ROM_END
+
+ROM_START( invmultim1a )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00 )
+
+	ROM_REGION( 0x20000, "user1", 0 )
+	ROM_LOAD("m801a.bin", 0x00000, 0x20000, CRC(f28536d2) SHA1(08ef3ea3fac38c7a478f094bfa7c369ac39515c4) )
+ROM_END
+
+ROM_START( invmultit3d )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00 )
+
+	ROM_REGION( 0x20000, "user1", 0 )
+	ROM_LOAD("t803d.bin", 0x00000, 0x20000, CRC(4d53173c) SHA1(a9caf7fd8e2fea86ca1cf7edc104bdacf09203f8) )
+ROM_END
+
+ROM_START( invmultis3a )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00 )
+
+	ROM_REGION( 0x20000, "user1", 0 )
+	ROM_LOAD("s083a.bin", 0x00000, 0x20000, CRC(f426d43b) SHA1(a299472f1d65f356ec01ca7cc8d3039abac20019) )
+ROM_END
+
+ROM_START( invmultis2a )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00 )
+
+	ROM_REGION( 0x20000, "user1", 0 )
+	ROM_LOAD("s082a.bin", 0x00000, 0x20000, CRC(25f0f17e) SHA1(a3ccf823399e23dd9fdb38fd58c0acfe80b57fe3) )
+ROM_END
+
+ROM_START( invmultis1a )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00 )
+
+	ROM_REGION( 0x20000, "user1", 0 )
+	ROM_LOAD("s081a.bin", 0x00000, 0x20000, CRC(daa77345) SHA1(0fdc9c2a6d9c0aa3233c5d31433adb1ea4e5b250) )
+ROM_END
+
+ROM_START( invmultip )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00 )
+
+	ROM_REGION( 0x20000, "user1", 0 )
+	ROM_LOAD("s10.bin",  0x00000, 0x20000, CRC(1b43e4d3) SHA1(c50decd9caaec7f2d8b3ba74f718372d31bc1c3b) )
+ROM_END
+
+
 ROM_START( rollingc )
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "rc01.bin",     0x0000, 0x0400, CRC(66fa50bf) SHA1(7451d4ff8d3b351a324aaecdbdc5b46672f5fdd0) )
@@ -3508,7 +3733,6 @@
 GAME( 19??, spacmiss, galactic, invaders, galactic, 0, ROT270, "bootleg?", "Space Missile - Space Fighting Game", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
 
 /* Misc. manufacturers */
-
 GAMEL(1980, searthin, invaders, invaders, searthin, 0, ROT270, "bootleg", "Super Earth Invasion (set 1)", GAME_SUPPORTS_SAVE, layout_invaders )
 GAMEL(1980, searthina,invaders, invaders, searthin, 0, ROT270, "bootleg", "Super Earth Invasion (set 2)", GAME_SUPPORTS_SAVE, layout_invaders )
 GAMEL(1978, invadrmr, invaders, invaders, invadrmr, 0, ROT270, "bootleg? (Model Racing)", "Space Invaders (Model Racing)", GAME_SUPPORTS_SAVE, layout_invaders )
@@ -3554,3 +3778,14 @@
 GAMEL(1979, shuttlei, 0,        shuttlei, shuttlei, 0, ROT270, "Omori Electric Co., Ltd.", "Shuttle Invader", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND | GAME_NO_COCKTAIL, layout_shuttlei )
 GAMEL(1979, skylove,  0,        shuttlei, skylove,  0, ROT270, "Omori Electric Co., Ltd.", "Sky Love", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND | GAME_NO_COCKTAIL, layout_shuttlei )
 GAME (19??, modelr,   0,        modelr,   invadrmr, 0, ROT0,   "Model Racing", "unknown Model Racing gun game", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE ) // no titlescreen
+
+GAME( 2002, invmulti,    0,        invmulti, invmulti, invmulti, ROT270, "hack (Braze Technologies)", "Space Invaders Multigame (M8.03D)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 2002, invmultim3a, invmulti, invmulti, invmulti, invmulti, ROT270, "hack (Braze Technologies)", "Space Invaders Multigame (M8.03A)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 2002, invmultim2c, invmulti, invmulti, invmulti, invmulti, ROT270, "hack (Braze Technologies)", "Space Invaders Multigame (M8.02C)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 2002, invmultim2a, invmulti, invmulti, invmulti, invmulti, ROT270, "hack (Braze Technologies)", "Space Invaders Multigame (M8.02A)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 2002, invmultim1a, invmulti, invmulti, invmulti, invmulti, ROT270, "hack (Braze Technologies)", "Space Invaders Multigame (M8.01A)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 2002, invmultit3d, invmulti, invmulti, invmulti, invmulti, ROT270, "hack (Braze Technologies)", "Space Invaders Multigame (T8.03D)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 2002, invmultis3a, invmulti, invmulti, invmulti, invmulti, ROT270, "hack (Braze Technologies)", "Space Invaders Multigame (S0.83A)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 2002, invmultis2a, invmulti, invmulti, invmulti, invmulti, ROT270, "hack (Braze Technologies)", "Space Invaders Multigame (S0.82A)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 2002, invmultis1a, invmulti, invmulti, invmulti, invmulti, ROT270, "hack (Braze Technologies)", "Space Invaders Multigame (S0.81A)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 2002, invmultip,   invmulti, invmulti, invmulti, invmulti, ROT270, "hack (Braze Technologies)", "Space Invaders Multigame (prototype)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/arkanoid.c src/mame/drivers/arkanoid.c
--- src-old/mame/drivers/arkanoid.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/drivers/arkanoid.c	2012-06-28 04:23:20.000000000 +0200
@@ -1256,6 +1256,25 @@
 	ROM_LOAD( "68705p3.6i",   0x0000, 0x0800, CRC(389a8cfb) SHA1(9530c051b61b5bdec7018c6fdc1ea91288a406bd) ) // this has the 1986 by Yasu copyright like some of the new decaps loaded in the parent set!
 ROM_END
 
+ROM_START( arkanoidjb2 )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "1.ic81", 0x0000, 0x8000, CRC(9ff93dc2) SHA1(eee0975b799a8e6717f646dd40716dc454476106) )
+	ROM_LOAD( "2.ic82", 0x8000, 0x8000, CRC(bbc33ceb) SHA1(e9b6fef98d0d20e77c7a1c25eff8e9a8c668a258) ) /* == A75-02.IC16 */
+
+	ROM_REGION( 0x0800, "mcu", 0 )	/* 2k for the microcontroller */
+	ROM_LOAD( "a75-06.ic14",  0x0000, 0x0800, BAD_DUMP CRC(515d77b6) SHA1(a302937683d11f663abd56a2fd7c174374e4d7fb) ) /* Possible bootleg code??, need the decapped data here */
+
+	ROM_REGION( 0x18000, "gfx1", 0 )
+	ROM_LOAD( "a75-03.ic64",   0x00000, 0x8000, CRC(038b74ba) SHA1(ac053cc4908b4075f918748b89570e07a0ba5116) )
+	ROM_LOAD( "a75-04.ic63",   0x08000, 0x8000, CRC(71fae199) SHA1(5d253c46ccf4cd2976a5fb8b8713f0f345443d06) )
+	ROM_LOAD( "a75-05.ic62",   0x10000, 0x8000, CRC(c76374e2) SHA1(7520dd48de20db60a2038f134dcaa454988e7874) )
+
+	ROM_REGION( 0x0600, "proms", 0 ) /* BPROMs are silkscreened as 7621, actual BPROMs used are MMI 6306-1N */
+	ROM_LOAD( "a75-07.ic24",    0x0000, 0x0200, CRC(0af8b289) SHA1(6bc589e8a609b4cf450aebedc8ce02d5d45c970f) )	/* red component */
+	ROM_LOAD( "a75-08.ic23",    0x0200, 0x0200, CRC(abb002fb) SHA1(c14f56b8ef103600862e7930709d293b0aa97a73) )	/* green component */
+	ROM_LOAD( "a75-09.ic23",    0x0400, 0x0200, CRC(a7c6c277) SHA1(adaa003dcd981576ea1cc5f697d709b2d6b2ea29) )	/* blue component */
+ROM_END
+
 ROM_START( ark1ball ) /* This set requires a MCU. No MCU rom was supplied so we use current A75-06.IC14 for now */
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "a-1.7d",       0x0000, 0x8000, CRC(dd4f2b72) SHA1(399a8636030a702dafc1da926f115df6f045bef1) )
@@ -1682,7 +1701,8 @@
 GAME( 1986, arkanoiduo, arkanoid, arkanoid, arkanoid, 0,        ROT90, "Taito America Corporation (Romstar license)", "Arkanoid (US, older)", GAME_SUPPORTS_SAVE )
 GAME( 1986, arkanoidj,  arkanoid, arkanoid, arkanoidj,0,        ROT90, "Taito Corporation", "Arkanoid (Japan)", GAME_SUPPORTS_SAVE )
 GAME( 1986, arkanoidjo, arkanoid, arkanoid, arkanoidj,0,        ROT90, "Taito Corporation", "Arkanoid (Japan, older)", GAME_SUPPORTS_SAVE )
-GAME( 1986, arkanoidjb, arkanoid, arkanoid, arkanoidj,0,        ROT90, "bootleg", "Arkanoid (bootleg with MCU)", GAME_SUPPORTS_SAVE )
+GAME( 1986, arkanoidjb, arkanoid, arkanoid, arkanoidj,0,        ROT90, "bootleg", "Arkanoid (bootleg with MCU, set 1)", GAME_SUPPORTS_SAVE )
+GAME( 1986, arkanoidjb2,arkanoid, arkanoid, arkanoidj,0,        ROT90, "bootleg (Beta)", "Arkanoid (bootleg with MCU, set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1986, ark1ball,   arkanoid, arkanoid, ark1ball, 0,        ROT90, "bootleg", "Arkanoid (bootleg with MCU, harder)", GAME_SUPPORTS_SAVE )
 GAME( 1986, arkangc,    arkanoid, bootleg,  arkangc,  arkangc,  ROT90, "bootleg (Game Corporation)", "Arkanoid (Game Corporation bootleg, set 1)", GAME_SUPPORTS_SAVE )
 GAME( 1986, arkangc2,   arkanoid, bootleg,  arkangc2, arkangc2, ROT90, "bootleg (Game Corporation)", "Arkanoid (Game Corporation bootleg, set 2)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/atlantis.c src/mame/drivers/atlantis.c
--- src-old/mame/drivers/atlantis.c	1970-01-01 01:00:00.000000000 +0100
+++ src/mame/drivers/atlantis.c	2012-07-02 09:06:11.000000000 +0200
@@ -0,0 +1,210 @@
+/***************************************************************************
+
+    Midway "Atlantis" hardware
+
+    skeleton by R. Belmont
+
+    Games supported:
+        * Midway Skins Game
+        * Midway Skins Game Tournament Edition (not dumped)
+        * Midway Swingers Tour (not dumped)
+
+    Hardware overview:
+        * VR4310 CPU (similar to the N64's VR4300)
+        * VR4373 "Nile 3" system controller / PCI bridge
+        * CMD 646U2 Ultra DMA IDE controller
+        * M4T28-8R128H1 TimeKeeper RTC/CMOS
+        * PLX PCI9050 Bus Target Interface Chip (interfaces ISA-style designs to PCI)
+        * Midway Zeus-series custom video
+        * TL16c552 dual UART
+        * ADSP-2181 based DCS2 audio (unclear which variant)
+
+    TODO:
+        * Proper VR4373 implementation
+        * Proper PCI bus implementation
+        * PCI peripherals
+
+***************************************************************************/
+
+#include "emu.h"
+#include "cpu/mips/mips3.h"
+#include "cpu/adsp2100/adsp2100.h"
+#include "machine/idectrl.h"
+#include "machine/midwayic.h"
+#include "audio/dcs.h"
+
+
+class atlantis_state : public driver_device
+{
+public:
+	atlantis_state(const machine_config &mconfig, device_type type, const char *tag)
+		: driver_device(mconfig, type, tag) {}
+};
+
+
+/*************************************
+ *
+ *  Machine start
+ *
+ *************************************/
+
+static MACHINE_START( mwskins )
+{
+//  atlantis_state *state = machine.driver_data<atlantis_state>();
+	/* set the fastest DRC options */
+	mips3drc_set_options(machine.device("maincpu"), MIPS3DRC_FASTEST_OPTIONS);
+}
+
+
+
+/*************************************
+ *
+ *  Machine init
+ *
+ *************************************/
+
+static MACHINE_RESET( mwskins )
+{
+    dcs_reset_w(machine, 1);
+    dcs_reset_w(machine, 0);
+}
+
+
+
+/*************************************
+ *
+ *  Video refresh
+ *
+ *************************************/
+
+static SCREEN_UPDATE_IND16( mwskins )
+{
+	return 0;
+}
+
+
+
+/*************************************
+ *
+ *  Interrupt handling
+ *
+ *************************************/
+
+static void ide_interrupt(device_t *device, int state)
+{
+}
+
+/*************************************
+ *
+ *  Main CPU memory handlers
+ *
+ *************************************/
+
+static ADDRESS_MAP_START( main_map, AS_PROGRAM, 32, atlantis_state )
+	ADDRESS_MAP_UNMAP_HIGH
+    AM_RANGE(0x00000000, 0x007fffff) AM_RAM // 8 MB main RAM
+    // 04000000 - PCI slot (ActionTec modem, ROM dump TBD)
+    // 08000000 - PLX9050 chip (Zeus interface?)
+    // 0F000000 - VR4373 ("Nile 3") registers
+	AM_RANGE(0x1fc00000, 0x1fc7ffff) AM_ROM AM_REGION("user1", 0) AM_SHARE("rombase")
+ADDRESS_MAP_END
+
+
+
+
+/*************************************
+ *
+ *  Port definitions
+ *
+ *************************************/
+
+static INPUT_PORTS_START( mwskins )
+INPUT_PORTS_END
+
+/*************************************
+ *
+ *  Machine driver
+ *
+ *************************************/
+
+static const mips3_config r4310_config =
+{
+	16384,				/* code cache size */
+	16384				/* data cache size */
+};
+
+
+static MACHINE_CONFIG_START( mwskins, atlantis_state )
+
+	/* basic machine hardware */
+	MCFG_CPU_ADD("maincpu", VR4310LE, 166666666)    // clock is TRUSTED
+	MCFG_CPU_CONFIG(r4310_config)
+	MCFG_CPU_PROGRAM_MAP(main_map)
+
+	MCFG_MACHINE_START(mwskins)
+	MCFG_MACHINE_RESET(mwskins)
+
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL, true)
+
+	/* video hardware */
+	MCFG_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK)
+
+	MCFG_SCREEN_ADD("screen", RASTER)
+	MCFG_SCREEN_REFRESH_RATE(60)
+	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
+	MCFG_SCREEN_SIZE(320, 240)
+	MCFG_SCREEN_VISIBLE_AREA(0, 319, 0, 239)
+	MCFG_SCREEN_UPDATE_STATIC(mwskins)
+
+	MCFG_PALETTE_INIT(BBBBB_GGGGG_RRRRR)
+	MCFG_PALETTE_LENGTH(32768)
+
+	/* sound hardware */
+	MCFG_FRAGMENT_ADD(dcs2_audio_denver)
+MACHINE_CONFIG_END
+
+
+
+/*************************************
+ *
+ *  ROM definition(s)
+ *
+ *************************************/
+
+ROM_START( mwskins )
+	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* 512k for R4310 code */
+    ROM_LOAD( "skins_game_u4_boot_1.00.u4", 0x000000, 0x080000, CRC(0fe87720) SHA1(4b24abbe662a2d7b61e6a3f079e28b73605ba19f) )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE( "mwskins", 0, SHA1(5cb293a6fdb2478293f48ddfc93cdd018acb2bb5) )
+ROM_END
+
+ROM_START( mwskinsa )
+	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* 512k for R4310 code */
+    ROM_LOAD( "skins_game_u4_boot_1.00.u4", 0x000000, 0x080000, CRC(0fe87720) SHA1(4b24abbe662a2d7b61e6a3f079e28b73605ba19f) )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE( "mwskinsa", 0, SHA1(72497917b31156eb11a46bbcc6f22a254dcec044) )
+ROM_END
+
+
+/*************************************
+ *
+ *  Driver initialization
+ *
+ *************************************/
+
+static DRIVER_INIT( mwskins )
+{
+	dcs2_init(machine, 8, 0);
+}
+
+/*************************************
+ *
+ *  Game driver(s)
+ *
+ *************************************/
+
+GAME( 2000, mwskins,    0,      mwskins, mwskins,  mwskins,   ROT0, "Midway", "Skins Game (1.06)", GAME_NOT_WORKING | GAME_NO_SOUND )
+GAME( 2000, mwskinsa, mwskins,  mwskins, mwskins,  mwskins,   ROT0, "Midway", "Skins Game (unknown alt. version)", GAME_NOT_WORKING | GAME_NO_SOUND )
+
diff -Nru src-old/mame/drivers/balsente.c src/mame/drivers/balsente.c
--- src-old/mame/drivers/balsente.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/drivers/balsente.c	2012-07-01 23:49:51.000000000 +0200
@@ -2234,7 +2234,7 @@
 
 /* Board: 006-8003-01-0D Rev D */
 GAME( 1984, hattrick, 0,        balsente, hattrick, hattrick, ROT0, "Bally/Sente",  "Hat Trick", GAME_SUPPORTS_SAVE )
-GAME( 1984, trivia12, 0,        balsente, triviag1, triviag1, ROT0, "Bally/Sente",  "Trivial Pursuit (Genus I) (12/14/84)", GAME_SUPPORTS_SAVE )
+GAME( 1984, trivia12, triviag1, balsente, triviag1, triviag1, ROT0, "Bally/Sente",  "Trivial Pursuit (Think Tank - Genus Edition) (12/14/84)", GAME_SUPPORTS_SAVE )
 
 /* Board: Unknown (From a picture on eBay Snacks'n Jaxson does not match any documented types here.) */
 GAME( 1984, otwalls,  0,        balsente, otwalls,  otwalls,  ROT0, "Bally/Sente",  "Off the Wall (Sente)", GAME_SUPPORTS_SAVE )
@@ -2249,13 +2249,13 @@
 GAME( 1984, triviabb, 0,        balsente, triviag1, triviag2, ROT0, "Bally/Sente",  "Trivial Pursuit (Baby Boomer Edition) (3/20/85)", GAME_SUPPORTS_SAVE )
 
 /* Board: Unknown  */
-GAME( 1984, triviag1, 0,        balsente, triviag1, triviag1, ROT0, "Bally/Sente",  "Trivial Pursuit (Genus I) (set 1)", GAME_SUPPORTS_SAVE )
-GAME( 1984, triviag2, 0,        balsente, triviag1, triviag2, ROT0, "Bally/Sente",  "Trivial Pursuit (Genus II)", GAME_SUPPORTS_SAVE )
+GAME( 1984, triviag1, 0,        balsente, triviag1, triviag1, ROT0, "Bally/Sente",  "Trivial Pursuit (Think Tank - Genus Edition) (set 1)", GAME_SUPPORTS_SAVE )
+GAME( 1984, triviag2, 0,        balsente, triviag1, triviag2, ROT0, "Bally/Sente",  "Trivial Pursuit (Genus II Edition)", GAME_SUPPORTS_SAVE )
 GAME( 1984, triviasp, 0,        balsente, triviag1, triviag2, ROT0, "Bally/Sente",  "Trivial Pursuit (All Star Sports Edition)", GAME_SUPPORTS_SAVE )
 GAME( 1984, triviayp, 0,        balsente, triviag1, triviag2, ROT0, "Bally/Sente",  "Trivial Pursuit (Young Players Edition)", GAME_SUPPORTS_SAVE )
-GAME( 1987, triviaes, 0,        balsente, triviaes, triviaes, ROT0, "Bally/Sente",  "Trivial Pursuit (Spanish Edition)", GAME_SUPPORTS_SAVE )
+GAME( 1987, triviaes, 0,        balsente, triviaes, triviaes, ROT0, "Bally/Sente",  "Trivial Pursuit (Spanish)", GAME_SUPPORTS_SAVE )
 GAME( 1985, toggle,   0,        balsente, toggle,   toggle,   ROT0, "Bally/Sente",  "Toggle (prototype)", GAME_SUPPORTS_SAVE )
-GAME( 1986, nametune, 0,        balsente, nametune, nametune, ROT0, "Bally/Sente",  "Name That Tune", GAME_SUPPORTS_SAVE )
+GAME( 1986, nametune, 0,        balsente, nametune, nametune, ROT0, "Bally/Sente",  "Name That Tune (set 1)", GAME_SUPPORTS_SAVE )
 
 /* Board: 006-8030-01-0A Rev A */
 GAME( 1986, nametune2,nametune, balsente, nametune, nametune, ROT0, "Bally/Sente",  "Name That Tune (3/23/86)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/bfm_sc2.c src/mame/drivers/bfm_sc2.c
--- src-old/mame/drivers/bfm_sc2.c	2012-06-11 10:00:48.000000000 +0200
+++ src/mame/drivers/bfm_sc2.c	2012-06-15 06:45:58.000000000 +0200
@@ -2147,6 +2147,7 @@
 	MCFG_WATCHDOG_TIME_INIT(PERIOD_OF_555_MONOSTABLE(120000,100e-9))
 
 	MCFG_BFMBD1_ADD("vfd0",0)
+	MCFG_BFMBD1_ADD("vfd1",1)
 
 	MCFG_NVRAM_ADD_0FILL("nvram")
 	MCFG_NVRAM_HANDLER(bfm_sc2)
@@ -3720,6 +3721,9 @@
 	MCFG_CPU_PERIODIC_INT(timer_irq, 1000 )
 	MCFG_WATCHDOG_TIME_INIT(PERIOD_OF_555_MONOSTABLE(120000,100e-9))
 
+	MCFG_BFMBD1_ADD("vfd0",0)
+	MCFG_BFMBD1_ADD("vfd1",1)
+
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 	MCFG_SOUND_ADD("ymsnd",YM2413, XTAL_3_579545MHz)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
diff -Nru src-old/mame/drivers/bfm_sc4h.c src/mame/drivers/bfm_sc4h.c
--- src-old/mame/drivers/bfm_sc4h.c	2012-06-11 10:00:48.000000000 +0200
+++ src/mame/drivers/bfm_sc4h.c	2012-06-15 06:45:58.000000000 +0200
@@ -801,14 +801,12 @@
 MACHINE_CONFIG_DERIVED_CLASS( sc4_adder4, sc4, sc4_adder4_state )
 	MCFG_CPU_ADD("adder4", M68340, 25175000)	 // 68340 (CPU32 core)
 	MCFG_CPU_PROGRAM_MAP(sc4_adder4_map)
-	MCFG_BFMBD1_ADD("vfd0",0)
 
 	MCFG_MACHINE_START( adder4 )
 MACHINE_CONFIG_END
 
 MACHINE_CONFIG_DERIVED_CLASS( sc4dmd, sc4, sc4_state )
 	/* video hardware */
-	MCFG_BFMBD1_REMOVE("vfd0")
 
 	MCFG_DEFAULT_LAYOUT(layout_sc4_dmd)
 	MCFG_CPU_ADD("matrix", M6809, 2000000 )				/* matrix board 6809 CPU at 2 Mhz ?? I don't know the exact freq.*/
diff -Nru src-old/mame/drivers/blitz68k.c src/mame/drivers/blitz68k.c
--- src-old/mame/drivers/blitz68k.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/blitz68k.c	2012-07-02 09:06:11.000000000 +0200
@@ -5,11 +5,21 @@
 
 Preliminary driver by David Haywood, Angelo Salese, Tomasz Slanina, Luca Elia
 
-Games:
-
-Il Pagliaccio (c) 19?? unknown
-Strip Teaser  (c) 1993 unknown
-Funny Fruit   (c) 1998 Cadillac Jack
+----------------------------------------------------------------------
+Year  Game                        Manufacturer
+----------------------------------------------------------------------
+1990  Mega Double Poker           Blitz Systems Inc.
+1990  Mega Double Poker Jackpot   Blitz Systems Inc.
+1993  Bank Robbery                Entertainment Technology Corp.
+1993? Poker 52                    Blitz Systems Inc.
+1993  Strip Teaser                <unknown>
+1995  Dual Games (proto)          Labtronix Technologies
+1995  The Hermit                  Dugamex
+1997  Deuces Wild 2               <unknown>
+1998  Funny Fruit                 Cadillac Jack
+1998  Triple Play                 Cadillac Jack
+199?  Il Pagliaccio               <unknown>
+----------------------------------------------------------------------
 
 Notes:
 
@@ -17,6 +27,8 @@
   reset with F3 for doing it.
 - cjffruit: at start-up a "need coin adjustment" pops up. Press menu, go to page 1 with start, move to
   "price coin #1" with big, and set it with small, then exit with menu.
+- "I/O TEST" is available among the statistics pages.
+- ilpag: based on pSOS+ S68000 V1.2.3 (Integrated Systems).
 
 To Do:
 
@@ -2124,8 +2136,70 @@
 
 /*************************************************************************************************************
 
+Triple Play
+(c) 1997-1998 Cadillac Jack
+(FEBRUARY 24TH, 1999 in the ROMS)
+
+Board:
+  CJ-8L REV-B LEV-1 (USA)
+
+CPUs:
+  MC68EC000FN12 (Main CPU)
+  Osc. 22.1184 MHz
+  MC68HC705C8A (Sound MCU, internal ROM not dumped)
+  Osc. 4.000 MHz
+
+Video:
+  R6545AP (CRT Controller)
+  Bt476KPJ50 (RAMDAC)
+
+ROMs:
+  6 x 27C040 (JP6-9 configure the rom sizes for program, sound and graphics)
+  5 x GAL16V8d-15LP (read protected?)
+
+Other:
+  DSW8
+  DS14C232CN (Serial)
+  RS-232 (4 pin)
+  CDP68HC68T1E (Real-Time clock plus RAM with serial interface)
+  3.6V Lithium battery
+  36/72 pin edge connector
+  10/20 pin edge connector
+
+Note:
+  Game supports a Centronics iDP-3541 printer (and many others)
+
+*************************************************************************************************************/
+
+ROM_START( cj3play )
+	ROM_REGION( 0x80000, "maincpu", 0 ) // 68000 code
+	ROM_LOAD16_WORD( "cjtripleply-cj_1.10-a.u65", 0x00000, 0x80000, CRC(69ae3fd3) SHA1(50eed5130905b710f48b2086173448e999dc96e8) )
+
+	ROM_REGION( 0x2000, "mcu", 0 )	// 68HC705C8A code
+	ROM_LOAD( "cj-tripleplay_2.4.c8", 0x0000, 0x2000, NO_DUMP )
+
+	ROM_REGION( 0x200000, "blitter", 0 ) // data for the blitter
+	ROM_LOAD16_BYTE( "cjtripleply-cj_1.10-d.u68", 0x000000, 0x80000, CRC(8bbcf296) SHA1(e7e6e88f5f3065e7df7fff45429fdda1404418d6) )
+	ROM_LOAD16_BYTE( "cjtripleply-cj_1.10-c.u75", 0x000001, 0x80000, CRC(3dd101e0) SHA1(01241a880e72834282dd7447273ffc332a105ad1) )
+	ROM_LOAD16_BYTE( "cjtripleply-cj_1.10-f.u51", 0x100000, 0x80000, CRC(c8ccf1a7) SHA1(7a7b0f68d6ed5894fb4deb93fbf8053aff4fdb35) )
+	ROM_LOAD16_BYTE( "cjtripleply-cj_1.10-e.u61", 0x100001, 0x80000, CRC(ff59f0ae) SHA1(b9f9cdc90f44f75ace079ec08ab5d71b21ce98dd) )
+
+	ROM_REGION( 0x80000, "samples", 0 )	// 8 bit unsigned
+	ROM_LOAD( "cjtripleply-cj_1.10-g.u50", 0x00000, 0x80000, CRC(8129f700) SHA1(fc09e1e4694757b08570cc46c9536340fbce0ded) )
+
+	ROM_REGION( 0x117, "plds", 0 )
+	ROM_LOAD( "gal16v8d_vdp.u15", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_vdo.u53", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_ck2.u64", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_ck1.u69", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_dec.u70", 0x000, 0x117, NO_DUMP )
+ROM_END
+
+/*************************************************************************************************************
+
 Funny Fruit
 (c) 1997-1998 Cadillac Jack
+(APRIL 21ST, 1999 in the ROMs)
 
 Board:
   CJ-8L REV-D
@@ -2173,12 +2247,12 @@
 	ROM_REGION( 0x80000, "samples", 0 )	// 8 bit unsigned
 	ROM_LOAD( "cjfunfruit-cj_1.13-g.u50", 0x00000, 0x80000, CRC(5fb53d3e) SHA1(f4a37b00a9417440685d198f1375b615848e7fb6) )
 
-    ROM_REGION( 0x117, "plds", 0 )
-    ROM_LOAD( "gal16v8d_vdp.u15", 0x000, 0x117, NO_DUMP )
-    ROM_LOAD( "gal16v8d_vdo.u53", 0x000, 0x117, NO_DUMP )
-    ROM_LOAD( "gal16v8d_ck2.u64", 0x000, 0x117, NO_DUMP )
-    ROM_LOAD( "gal16v8d_ck1.u69", 0x000, 0x117, NO_DUMP )
-    ROM_LOAD( "gal16v8d_dec.u70", 0x000, 0x117, NO_DUMP )
+	ROM_REGION( 0x117, "plds", 0 )
+	ROM_LOAD( "gal16v8d_vdp.u15", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_vdo.u53", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_ck2.u64", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_ck1.u69", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_dec.u70", 0x000, 0x117, NO_DUMP )
 ROM_END
 
 /*************************************************************************************************************
@@ -2236,14 +2310,14 @@
 	ROM_REGION( 0x20000, "samples", 0 )	// 8 bit unsigned
 	ROM_LOAD( "cb2wild-ah-2.02f-k.u54", 0x00000, 0x20000, CRC(1eea618b) SHA1(65f3513d1a93a8afbfaeff27ebea5f0b5348e54b) )
 
-    ROM_REGION( 0x117, "plds", 0 )
-    ROM_LOAD( "gal16v8d_vdp.u23", 0x000, 0x117, NO_DUMP )
-    ROM_LOAD( "gal16v8d_ck2.u62", 0x000, 0x117, NO_DUMP )
-    ROM_LOAD( "gal16v8d_vdo.u65", 0x000, 0x117, NO_DUMP )
-    ROM_LOAD( "gal16v8d_ck1.u70", 0x000, 0x117, NO_DUMP )
-    ROM_LOAD( "gal16v8d_irq.u80", 0x000, 0x117, NO_DUMP )
-    ROM_LOAD( "gal16v8d_dec.u83", 0x000, 0x117, NO_DUMP )
-    ROM_LOAD( "gal16v8d_pia.u86", 0x000, 0x117, NO_DUMP )
+	ROM_REGION( 0x117, "plds", 0 )
+	ROM_LOAD( "gal16v8d_vdp.u23", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_ck2.u62", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_vdo.u65", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_ck1.u70", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_irq.u80", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_dec.u83", 0x000, 0x117, NO_DUMP )
+	ROM_LOAD( "gal16v8d_pia.u86", 0x000, 0x117, NO_DUMP )
 ROM_END
 
 /*************************************************************************************************************
@@ -2723,6 +2797,22 @@
 	ROM[0x178ec/2] = 0x4e71;
 }
 
+static DRIVER_INIT( cj3play )
+{
+	UINT16 *ROM = (UINT16 *)machine.root_device().memregion("maincpu")->base();
+
+	// WRONG C8 #1
+	ROM[0x7064/2] = 0x6028;
+	ROM[0xa0d2/2] = 0x6024;
+
+	// loop
+	ROM[0x2773c/2] = 0x4e71;
+//  ROM[0x3491a/2] = 0x4e71;
+
+	// ERROR CHECKSUM ROM PROGRAM
+	ROM[0x20ab0/2] = 0x6050;
+}
+
 static DRIVER_INIT( cjffruit )
 {
 	UINT16 *ROM = (UINT16 *)machine.root_device().memregion("maincpu")->base();
@@ -2811,12 +2901,13 @@
 GAME( 1992,  maxidbl,  0,       maxidbl,  maxidbl,  maxidbl,  ROT0,  "Blitz Systems Inc.",             "Maxi Double Poker (Ver. 1.10)",                  GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND | GAME_WRONG_COLORS )
 GAME( 1990,  megadblj, 0,       maxidbl,  maxidbl,  megadblj, ROT0,  "Blitz Systems Inc.",             "Mega Double Poker Jackpot (Ver. 1.26)",          GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )	                 // JUNE 28TH, 1993
 GAME( 1990,  megadble, 0,       maxidbl,  maxidbl,  megadble, ROT0,  "Blitz Systems Inc.",             "Mega Double Poker (Ver. 1.63 Espagnol)",         GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND | GAME_WRONG_COLORS ) // NOVEMBER 1994
-GAME( 1993,  steaser,  0,       steaser,  steaser,  0,        ROT0,  "<unknown>",                      "Strip Teaser (Italy, Version 1.22)",             GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )                     // In-game strings are in Italian but service mode is half English / half French?
+GAME( 1993,  steaser,  0,       steaser,  steaser,  0,        ROT0,  "<unknown>",                      "Strip Teaser (Italy, Ver. 1.22)",                GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )                     // In-game strings are in Italian but service mode is half English / half French?
 GAME( 1993,  bankrob,  0,       bankrob,  bankrob,  bankrob,  ROT0,  "Entertainment Technology Corp.", "Bank Robbery (Ver. 3.32)",                       GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )	                 // BLITZ SYSTEM INC APRIL 1995
 GAME( 1993,  bankroba, bankrob, bankroba, bankrob,  bankroba, ROT0,  "Entertainment Technology Corp.", "Bank Robbery (Ver. 2.00)",                       GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )	                 // BLITZ SYSTEM INC MAY 10TH, 1993
 GAME( 1993?, poker52,  0,       maxidbl,  maxidbl,  0,        ROT0,  "Blitz Systems Inc.",             "Poker 52 (Ver. 1.2)",                            GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )	                 // MARCH 10TH, 1994
 GAME( 1995,  dualgame, 0,       dualgame, dualgame, dualgame, ROT0,  "Labtronix Technologies",         "Dual Games (prototype)",                         GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )                     // SEPTEMBER 5TH, 1995
 GAME( 1995,  hermit,   0,       hermit,   hermit,   hermit,   ROT0,  "Dugamex",                        "The Hermit (Ver. 1.14)",                         GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )	                 // APRIL 1995
 GAME( 1997,  deucesw2, 0,       deucesw2, deucesw2, deucesw2, ROT0,  "<unknown>",                      "Deuces Wild 2 - American Heritage (Ver. 2.02F)", GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )	                 // APRIL 10TH, 1997
-GAME( 1998,  cjffruit, 0,       cjffruit, cjffruit, cjffruit, ROT0,  "Cadillac Jack",                  "Funny Fruit (Version 1.13)",                     GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )
-GAME( 199?,  ilpag,    0,       ilpag,    ilpag,    0,        ROT0,  "<unknown>",                      "Il Pagliaccio (Italy, Version 2.7C)",            GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )
+GAME( 1998,  cj3play,  0,       cjffruit, cjffruit, cj3play,  ROT0,  "Cadillac Jack",                  "Triple Play (Ver. 1.10)",                        GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )                     // FEBRUARY 24TH, 1999
+GAME( 1998,  cjffruit, 0,       cjffruit, cjffruit, cjffruit, ROT0,  "Cadillac Jack",                  "Funny Fruit (Ver. 1.13)",                        GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )                     // APRIL 21ST, 1999
+GAME( 199?,  ilpag,    0,       ilpag,    ilpag,    0,        ROT0,  "<unknown>",                      "Il Pagliaccio (Italy, Ver. 2.7C)",               GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND )
diff -Nru src-old/mame/drivers/calchase.c src/mame/drivers/calchase.c
--- src-old/mame/drivers/calchase.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/calchase.c	2012-07-02 08:20:21.000000000 +0200
@@ -603,7 +603,7 @@
 	AM_RANGE(0x03f0, 0x03f7) AM_READWRITE(fdc_r, fdc_w)
 	AM_RANGE(0x03f8, 0x03ff) AM_NOP // To debug Serial Port COM1:
 	AM_RANGE(0x0a78, 0x0a7b) AM_WRITENOP//AM_WRITE_LEGACY(pnp_data_w)
-	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE_LEGACY("pcibus", pci_32le_r,	pci_32le_w)
+	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_bus_legacy_device, read, write)
 	AM_RANGE(0x42e8, 0x43ef) AM_NOP //To debug
 	AM_RANGE(0x43c0, 0x43cf) AM_RAM AM_SHARE("share1")
 	AM_RANGE(0x46e8, 0x46ef) AM_NOP //To debug
@@ -932,9 +932,9 @@
 	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL, true)
 
 	MCFG_MC146818_ADD( "rtc", MC146818_STANDARD )
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
-	MCFG_PCI_BUS_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
 
 	/* video hardware */
 	MCFG_FRAGMENT_ADD( pcvideo_vga )
diff -Nru src-old/mame/drivers/cclimber.c src/mame/drivers/cclimber.c
--- src-old/mame/drivers/cclimber.c	2012-04-19 22:59:50.000000000 +0200
+++ src/mame/drivers/cclimber.c	2012-07-02 01:16:16.000000000 +0200
@@ -1254,22 +1254,22 @@
 
 ROM_START( ckongpt2 )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "d05-07.bin",   0x0000, 0x1000, CRC(b27df032) SHA1(57f9be139c610405e3c2fddd7093dfb1277e450e) )
-	ROM_LOAD( "f05-08.bin",   0x1000, 0x1000, CRC(5dc1aaba) SHA1(42b9e5946ffce7c156d114bde68f37c2c34853c4) )
-	ROM_LOAD( "h05-09.bin",   0x2000, 0x1000, CRC(c9054c94) SHA1(1aa08d2501ee620759fd5c111e12f6d432c25294) )
-	ROM_LOAD( "k05-10.bin",   0x3000, 0x1000, CRC(069c4797) SHA1(03be185e6914ec7f3770ce3da4eb49cdb97adc85) )
-	ROM_LOAD( "l05-11.bin",   0x4000, 0x1000, CRC(ae159192) SHA1(d467256a3a366e246243e7828ff4a45d4c146e2c) )
-	ROM_LOAD( "n05-12.bin",   0x5000, 0x1000, CRC(966bc9ab) SHA1(4434fc620169ffea1b1f227b61674e1daf79b54b) )
-
-	ROM_REGION( 0x4000, "gfx1", 0 )
-	ROM_LOAD( "n11-06.bin",   0x0000, 0x1000, CRC(2dcedd12) SHA1(dfdcfc21bcba7c8e148ee54daae511ca78c58e70) )
-	ROM_LOAD( "l11-05.bin",   0x1000, 0x1000, CRC(fa7cbd91) SHA1(0208d2ebc59f3600005476b6987472685bc99d67) )
-	ROM_LOAD( "k11-04.bin",   0x2000, 0x1000, CRC(3375b3bd) SHA1(a00b3c31cff123aab6ac0833aabfdd663302971a) )
-	ROM_LOAD( "h11-03.bin",   0x3000, 0x1000, CRC(5655cc11) SHA1(5195e9b2a60c54280b48b32ee8248090904dbc51) )
+	ROM_LOAD( "7.5d",         0x0000, 0x1000, CRC(b27df032) SHA1(57f9be139c610405e3c2fddd7093dfb1277e450e) )
+	ROM_LOAD( "8.5e",         0x1000, 0x1000, CRC(5dc1aaba) SHA1(42b9e5946ffce7c156d114bde68f37c2c34853c4) )
+	ROM_LOAD( "9.5h",         0x2000, 0x1000, CRC(c9054c94) SHA1(1aa08d2501ee620759fd5c111e12f6d432c25294) )
+	ROM_LOAD( "10.5k",        0x3000, 0x1000, CRC(069c4797) SHA1(03be185e6914ec7f3770ce3da4eb49cdb97adc85) )
+	ROM_LOAD( "11.5l",        0x4000, 0x1000, CRC(ae159192) SHA1(d467256a3a366e246243e7828ff4a45d4c146e2c) )
+	ROM_LOAD( "12.5n",        0x5000, 0x1000, CRC(966bc9ab) SHA1(4434fc620169ffea1b1f227b61674e1daf79b54b) )
+
+	ROM_REGION( 0x4000, "gfx1", 0 )
+	ROM_LOAD( "6.11n",        0x0000, 0x1000, CRC(2dcedd12) SHA1(dfdcfc21bcba7c8e148ee54daae511ca78c58e70) )
+	ROM_LOAD( "5.11l",        0x1000, 0x1000, CRC(fa7cbd91) SHA1(0208d2ebc59f3600005476b6987472685bc99d67) )
+	ROM_LOAD( "4.11k",        0x2000, 0x1000, CRC(3375b3bd) SHA1(a00b3c31cff123aab6ac0833aabfdd663302971a) )
+	ROM_LOAD( "3.11h",        0x3000, 0x1000, CRC(5655cc11) SHA1(5195e9b2a60c54280b48b32ee8248090904dbc51) )
 
 	ROM_REGION( 0x1000, "gfx2", 0 )
-	ROM_LOAD( "c11-02.bin",   0x0000, 0x0800, CRC(d1352c31) SHA1(da726a63a8be830d695afeddc1717749af8c9d47) )
-	ROM_LOAD( "a11-01.bin",   0x0800, 0x0800, CRC(a7a2fdbd) SHA1(529865f8bbfbdbbf34ac39c70ef17e6d5bd0f845) )
+	ROM_LOAD( "2.11c",        0x0000, 0x0800, CRC(d1352c31) SHA1(da726a63a8be830d695afeddc1717749af8c9d47) )
+	ROM_LOAD( "1.11a",        0x0800, 0x0800, CRC(a7a2fdbd) SHA1(529865f8bbfbdbbf34ac39c70ef17e6d5bd0f845) )
 
 	ROM_REGION( 0x0060, "proms", 0 )
 	ROM_LOAD( "prom.v6",      0x0000, 0x0020, CRC(b3fc1505) SHA1(5b94adde0428a26b815c7eb9b3f3716470d349c7) )
@@ -1277,28 +1277,28 @@
 	ROM_LOAD( "prom.t6",      0x0040, 0x0020, CRC(676b3166) SHA1(29b9434cd34d43ea5664e436e2a24b54f8d88aac) )
 
 	ROM_REGION( 0x2000, "samples", 0 )	/* samples */
-	ROM_LOAD( "cc13j.bin",    0x0000, 0x1000, CRC(5f0bcdfb) SHA1(7f79bf6de117348f606696ed7ea1937bbf926612) )
-	ROM_LOAD( "cc12j.bin",    0x1000, 0x1000, CRC(9003ffbd) SHA1(fd016056aabc23957643f37230f03842294f795e) )
+	ROM_LOAD( "14.5s",        0x0000, 0x1000, CRC(5f0bcdfb) SHA1(7f79bf6de117348f606696ed7ea1937bbf926612) )
+	ROM_LOAD( "13.5p",        0x1000, 0x1000, CRC(9003ffbd) SHA1(fd016056aabc23957643f37230f03842294f795e) )
 ROM_END
 
 ROM_START( ckongpt2a )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "d05-07.bin",   0x0000, 0x1000, CRC(b27df032) SHA1(57f9be139c610405e3c2fddd7093dfb1277e450e) )
-	ROM_LOAD( "f05-08.bin",   0x1000, 0x1000, CRC(5dc1aaba) SHA1(42b9e5946ffce7c156d114bde68f37c2c34853c4) )
-	ROM_LOAD( "h05-09.bin",   0x2000, 0x1000, CRC(c9054c94) SHA1(1aa08d2501ee620759fd5c111e12f6d432c25294) )
+	ROM_LOAD( "7.5d",         0x0000, 0x1000, CRC(b27df032) SHA1(57f9be139c610405e3c2fddd7093dfb1277e450e) )
+	ROM_LOAD( "8.5e",         0x1000, 0x1000, CRC(5dc1aaba) SHA1(42b9e5946ffce7c156d114bde68f37c2c34853c4) )
+	ROM_LOAD( "9.5h",         0x2000, 0x1000, CRC(c9054c94) SHA1(1aa08d2501ee620759fd5c111e12f6d432c25294) )
 	ROM_LOAD( "10.dat",       0x3000, 0x1000, CRC(c3beb501) SHA1(14f49c45fc7c91799034c5a51fca310f0a66b1d7) )
-	ROM_LOAD( "l05-11.bin",   0x4000, 0x1000, CRC(ae159192) SHA1(d467256a3a366e246243e7828ff4a45d4c146e2c) )
-	ROM_LOAD( "n05-12.bin",   0x5000, 0x1000, CRC(966bc9ab) SHA1(4434fc620169ffea1b1f227b61674e1daf79b54b) )
+	ROM_LOAD( "11.5l",        0x4000, 0x1000, CRC(ae159192) SHA1(d467256a3a366e246243e7828ff4a45d4c146e2c) )
+	ROM_LOAD( "12.5n",        0x5000, 0x1000, CRC(966bc9ab) SHA1(4434fc620169ffea1b1f227b61674e1daf79b54b) )
 
 	ROM_REGION( 0x4000, "gfx1", 0 )
-	ROM_LOAD( "n11-06.bin",   0x0000, 0x1000, CRC(2dcedd12) SHA1(dfdcfc21bcba7c8e148ee54daae511ca78c58e70) )
-	ROM_LOAD( "l11-05.bin",   0x1000, 0x1000, CRC(fa7cbd91) SHA1(0208d2ebc59f3600005476b6987472685bc99d67) )
-	ROM_LOAD( "k11-04.bin",   0x2000, 0x1000, CRC(3375b3bd) SHA1(a00b3c31cff123aab6ac0833aabfdd663302971a) )
-	ROM_LOAD( "h11-03.bin",   0x3000, 0x1000, CRC(5655cc11) SHA1(5195e9b2a60c54280b48b32ee8248090904dbc51) )
+	ROM_LOAD( "6.11n",        0x0000, 0x1000, CRC(2dcedd12) SHA1(dfdcfc21bcba7c8e148ee54daae511ca78c58e70) )
+	ROM_LOAD( "5.11l",        0x1000, 0x1000, CRC(fa7cbd91) SHA1(0208d2ebc59f3600005476b6987472685bc99d67) )
+	ROM_LOAD( "4.11k",        0x2000, 0x1000, CRC(3375b3bd) SHA1(a00b3c31cff123aab6ac0833aabfdd663302971a) )
+	ROM_LOAD( "3.11h",        0x3000, 0x1000, CRC(5655cc11) SHA1(5195e9b2a60c54280b48b32ee8248090904dbc51) )
 
 	ROM_REGION( 0x1000, "gfx2", 0 )
-	ROM_LOAD( "c11-02.bin",   0x0000, 0x0800, CRC(d1352c31) SHA1(da726a63a8be830d695afeddc1717749af8c9d47) )
-	ROM_LOAD( "a11-01.bin",   0x0800, 0x0800, CRC(a7a2fdbd) SHA1(529865f8bbfbdbbf34ac39c70ef17e6d5bd0f845) )
+	ROM_LOAD( "2.11c",        0x0000, 0x0800, CRC(d1352c31) SHA1(da726a63a8be830d695afeddc1717749af8c9d47) )
+	ROM_LOAD( "1.11a",        0x0800, 0x0800, CRC(a7a2fdbd) SHA1(529865f8bbfbdbbf34ac39c70ef17e6d5bd0f845) )
 
 	ROM_REGION( 0x0060, "proms", 0 )
 	ROM_LOAD( "prom.v6",      0x0000, 0x0020, CRC(b3fc1505) SHA1(5b94adde0428a26b815c7eb9b3f3716470d349c7) )
@@ -1306,28 +1306,28 @@
 	ROM_LOAD( "prom.t6",      0x0040, 0x0020, CRC(676b3166) SHA1(29b9434cd34d43ea5664e436e2a24b54f8d88aac) )
 
 	ROM_REGION( 0x2000, "samples", 0 )	/* samples */
-	ROM_LOAD( "cc13j.bin",    0x0000, 0x1000, CRC(5f0bcdfb) SHA1(7f79bf6de117348f606696ed7ea1937bbf926612) )
-	ROM_LOAD( "cc12j.bin",    0x1000, 0x1000, CRC(9003ffbd) SHA1(fd016056aabc23957643f37230f03842294f795e) )
+	ROM_LOAD( "14.5s",        0x0000, 0x1000, CRC(5f0bcdfb) SHA1(7f79bf6de117348f606696ed7ea1937bbf926612) )
+	ROM_LOAD( "13.5p",        0x1000, 0x1000, CRC(9003ffbd) SHA1(fd016056aabc23957643f37230f03842294f795e) )
 ROM_END
 
 ROM_START( ckongpt2j )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "d05-07.bin",   0x0000, 0x1000, CRC(b27df032) SHA1(57f9be139c610405e3c2fddd7093dfb1277e450e) )
-	ROM_LOAD( "f05-08.bin",   0x1000, 0x1000, CRC(5dc1aaba) SHA1(42b9e5946ffce7c156d114bde68f37c2c34853c4) )
-	ROM_LOAD( "h05-09.bin",   0x2000, 0x1000, CRC(c9054c94) SHA1(1aa08d2501ee620759fd5c111e12f6d432c25294) )
+	ROM_LOAD( "7.5d",         0x0000, 0x1000, CRC(b27df032) SHA1(57f9be139c610405e3c2fddd7093dfb1277e450e) )
+	ROM_LOAD( "8.5e",         0x1000, 0x1000, CRC(5dc1aaba) SHA1(42b9e5946ffce7c156d114bde68f37c2c34853c4) )
+	ROM_LOAD( "9.5h",         0x2000, 0x1000, CRC(c9054c94) SHA1(1aa08d2501ee620759fd5c111e12f6d432c25294) )
 	ROM_LOAD( "10.dat",       0x3000, 0x1000, CRC(c3beb501) SHA1(14f49c45fc7c91799034c5a51fca310f0a66b1d7) )
-	ROM_LOAD( "11.5l",        0x4000, 0x1000, CRC(4164eb4d) SHA1(ec95f913820375c3f6dd24776b4d3fd04163f5de) )
-	ROM_LOAD( "n05-12.bin",   0x5000, 0x1000, CRC(966bc9ab) SHA1(4434fc620169ffea1b1f227b61674e1daf79b54b) )
+	ROM_LOAD( "11.5l(__jp)",  0x4000, 0x1000, CRC(4164eb4d) SHA1(ec95f913820375c3f6dd24776b4d3fd04163f5de) )
+	ROM_LOAD( "12.5n",        0x5000, 0x1000, CRC(966bc9ab) SHA1(4434fc620169ffea1b1f227b61674e1daf79b54b) )
 
 	ROM_REGION( 0x4000, "gfx1", 0 )
-	ROM_LOAD( "n11-06.bin",   0x0000, 0x1000, CRC(2dcedd12) SHA1(dfdcfc21bcba7c8e148ee54daae511ca78c58e70) )
-	ROM_LOAD( "l11-05.bin",   0x1000, 0x1000, CRC(fa7cbd91) SHA1(0208d2ebc59f3600005476b6987472685bc99d67) )
-	ROM_LOAD( "k11-04.bin",   0x2000, 0x1000, CRC(3375b3bd) SHA1(a00b3c31cff123aab6ac0833aabfdd663302971a) )
-	ROM_LOAD( "h11-03.bin",   0x3000, 0x1000, CRC(5655cc11) SHA1(5195e9b2a60c54280b48b32ee8248090904dbc51) )
+	ROM_LOAD( "6.11n",        0x0000, 0x1000, CRC(2dcedd12) SHA1(dfdcfc21bcba7c8e148ee54daae511ca78c58e70) )
+	ROM_LOAD( "5.11l",        0x1000, 0x1000, CRC(fa7cbd91) SHA1(0208d2ebc59f3600005476b6987472685bc99d67) )
+	ROM_LOAD( "4.11k",        0x2000, 0x1000, CRC(3375b3bd) SHA1(a00b3c31cff123aab6ac0833aabfdd663302971a) )
+	ROM_LOAD( "3.11h",        0x3000, 0x1000, CRC(5655cc11) SHA1(5195e9b2a60c54280b48b32ee8248090904dbc51) )
 
 	ROM_REGION( 0x1000, "gfx2", 0 )
-	ROM_LOAD( "c11-02.bin",   0x0000, 0x0800, CRC(d1352c31) SHA1(da726a63a8be830d695afeddc1717749af8c9d47) )
-	ROM_LOAD( "a11-01.bin",   0x0800, 0x0800, CRC(a7a2fdbd) SHA1(529865f8bbfbdbbf34ac39c70ef17e6d5bd0f845) )
+	ROM_LOAD( "2.11c",        0x0000, 0x0800, CRC(d1352c31) SHA1(da726a63a8be830d695afeddc1717749af8c9d47) )
+	ROM_LOAD( "1.11a",        0x0800, 0x0800, CRC(a7a2fdbd) SHA1(529865f8bbfbdbbf34ac39c70ef17e6d5bd0f845) )
 
 	ROM_REGION( 0x0060, "proms", 0 )
 	ROM_LOAD( "prom.v6",      0x0000, 0x0020, CRC(b3fc1505) SHA1(5b94adde0428a26b815c7eb9b3f3716470d349c7) )
@@ -1335,28 +1335,28 @@
 	ROM_LOAD( "prom.t6",      0x0040, 0x0020, CRC(676b3166) SHA1(29b9434cd34d43ea5664e436e2a24b54f8d88aac) )
 
 	ROM_REGION( 0x2000, "samples", 0 )	/* samples */
-	ROM_LOAD( "cc13j.bin",    0x0000, 0x1000, CRC(5f0bcdfb) SHA1(7f79bf6de117348f606696ed7ea1937bbf926612) )
-	ROM_LOAD( "cc12j.bin",    0x1000, 0x1000, CRC(9003ffbd) SHA1(fd016056aabc23957643f37230f03842294f795e) )
+	ROM_LOAD( "14.5s",        0x0000, 0x1000, CRC(5f0bcdfb) SHA1(7f79bf6de117348f606696ed7ea1937bbf926612) )
+	ROM_LOAD( "13.5p",        0x1000, 0x1000, CRC(9003ffbd) SHA1(fd016056aabc23957643f37230f03842294f795e) )
 ROM_END
 
 ROM_START( ckongpt2jeu )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "d05-07.bin",   0x0000, 0x1000, CRC(b27df032) SHA1(57f9be139c610405e3c2fddd7093dfb1277e450e) )
-	ROM_LOAD( "f05-08.bin",   0x1000, 0x1000, CRC(5dc1aaba) SHA1(42b9e5946ffce7c156d114bde68f37c2c34853c4) )
-	ROM_LOAD( "h05-09.bin",   0x2000, 0x1000, CRC(c9054c94) SHA1(1aa08d2501ee620759fd5c111e12f6d432c25294) )
+	ROM_LOAD( "7.5d",         0x0000, 0x1000, CRC(b27df032) SHA1(57f9be139c610405e3c2fddd7093dfb1277e450e) )
+	ROM_LOAD( "8.5e",         0x1000, 0x1000, CRC(5dc1aaba) SHA1(42b9e5946ffce7c156d114bde68f37c2c34853c4) )
+	ROM_LOAD( "9.5h",         0x2000, 0x1000, CRC(c9054c94) SHA1(1aa08d2501ee620759fd5c111e12f6d432c25294) )
 	ROM_LOAD( "ckjeu10.dat",  0x3000, 0x1000, CRC(7e6eeec4) SHA1(98b283ea22bedc46710a24e65cfae48b87a57605) )
-	ROM_LOAD( "l05-11.bin",   0x4000, 0x1000, CRC(ae159192) SHA1(d467256a3a366e246243e7828ff4a45d4c146e2c) )
+	ROM_LOAD( "11.5l",        0x4000, 0x1000, CRC(ae159192) SHA1(d467256a3a366e246243e7828ff4a45d4c146e2c) )
 	ROM_LOAD( "ckjeu12.dat",  0x5000, 0x1000, CRC(0532f270) SHA1(a73680bd7939097bd821fb6834e8763cf1572b55) )
 
 	ROM_REGION( 0x4000, "gfx1", 0 )
-	ROM_LOAD( "n11-06.bin",   0x0000, 0x1000, CRC(2dcedd12) SHA1(dfdcfc21bcba7c8e148ee54daae511ca78c58e70) )
-	ROM_LOAD( "l11-05.bin",   0x1000, 0x1000, CRC(fa7cbd91) SHA1(0208d2ebc59f3600005476b6987472685bc99d67) )
-	ROM_LOAD( "k11-04.bin",   0x2000, 0x1000, CRC(3375b3bd) SHA1(a00b3c31cff123aab6ac0833aabfdd663302971a) )
-	ROM_LOAD( "h11-03.bin",   0x3000, 0x1000, CRC(5655cc11) SHA1(5195e9b2a60c54280b48b32ee8248090904dbc51) )
+	ROM_LOAD( "6.11n",        0x0000, 0x1000, CRC(2dcedd12) SHA1(dfdcfc21bcba7c8e148ee54daae511ca78c58e70) )
+	ROM_LOAD( "5.11l",        0x1000, 0x1000, CRC(fa7cbd91) SHA1(0208d2ebc59f3600005476b6987472685bc99d67) )
+	ROM_LOAD( "4.11k",        0x2000, 0x1000, CRC(3375b3bd) SHA1(a00b3c31cff123aab6ac0833aabfdd663302971a) )
+	ROM_LOAD( "3.11h",        0x3000, 0x1000, CRC(5655cc11) SHA1(5195e9b2a60c54280b48b32ee8248090904dbc51) )
 
 	ROM_REGION( 0x1000, "gfx2", 0 )
-	ROM_LOAD( "c11-02.bin",   0x0000, 0x0800, CRC(d1352c31) SHA1(da726a63a8be830d695afeddc1717749af8c9d47) )
-	ROM_LOAD( "a11-01.bin",   0x0800, 0x0800, CRC(a7a2fdbd) SHA1(529865f8bbfbdbbf34ac39c70ef17e6d5bd0f845) )
+	ROM_LOAD( "2.11c",        0x0000, 0x0800, CRC(d1352c31) SHA1(da726a63a8be830d695afeddc1717749af8c9d47) )
+	ROM_LOAD( "1.11a",        0x0800, 0x0800, CRC(a7a2fdbd) SHA1(529865f8bbfbdbbf34ac39c70ef17e6d5bd0f845) )
 
 	ROM_REGION( 0x0060, "proms", 0 )
 	ROM_LOAD( "prom.v6",      0x0000, 0x0020, CRC(b3fc1505) SHA1(5b94adde0428a26b815c7eb9b3f3716470d349c7) )
@@ -1364,8 +1364,8 @@
 	ROM_LOAD( "prom.t6",      0x0040, 0x0020, CRC(676b3166) SHA1(29b9434cd34d43ea5664e436e2a24b54f8d88aac) )
 
 	ROM_REGION( 0x2000, "samples", 0 )	/* samples */
-	ROM_LOAD( "cc13j.bin",    0x0000, 0x1000, CRC(5f0bcdfb) SHA1(7f79bf6de117348f606696ed7ea1937bbf926612) )
-	ROM_LOAD( "cc12j.bin",    0x1000, 0x1000, CRC(9003ffbd) SHA1(fd016056aabc23957643f37230f03842294f795e) )
+	ROM_LOAD( "14.5s",        0x0000, 0x1000, CRC(5f0bcdfb) SHA1(7f79bf6de117348f606696ed7ea1937bbf926612) )
+	ROM_LOAD( "13.5p",        0x1000, 0x1000, CRC(9003ffbd) SHA1(fd016056aabc23957643f37230f03842294f795e) )
 ROM_END
 
 
@@ -1379,23 +1379,23 @@
 	ROM_LOAD( "n05-12.rom",   0x5000, 0x1000, CRC(151de90a) SHA1(5d063c4fe6767727d051815120d692818a30ee81) )
 
 	ROM_REGION( 0x4000, "gfx1", 0 )
-	ROM_LOAD( "n11-6.bin",    0x0000, 0x1000, CRC(2dcedd12) SHA1(dfdcfc21bcba7c8e148ee54daae511ca78c58e70) )
-	ROM_LOAD( "l11-5.bin",    0x1000, 0x1000, CRC(fa7cbd91) SHA1(0208d2ebc59f3600005476b6987472685bc99d67) )
-	ROM_LOAD( "k11-4.bin",    0x2000, 0x1000, CRC(3375b3bd) SHA1(a00b3c31cff123aab6ac0833aabfdd663302971a) )
-	ROM_LOAD( "h11-3.bin",    0x3000, 0x1000, CRC(5655cc11) SHA1(5195e9b2a60c54280b48b32ee8248090904dbc51) )
+	ROM_LOAD( "6.11n",        0x0000, 0x1000, CRC(2dcedd12) SHA1(dfdcfc21bcba7c8e148ee54daae511ca78c58e70) )
+	ROM_LOAD( "5.11l",        0x1000, 0x1000, CRC(fa7cbd91) SHA1(0208d2ebc59f3600005476b6987472685bc99d67) )
+	ROM_LOAD( "4.11k",        0x2000, 0x1000, CRC(3375b3bd) SHA1(a00b3c31cff123aab6ac0833aabfdd663302971a) )
+	ROM_LOAD( "3.11h",        0x3000, 0x1000, CRC(5655cc11) SHA1(5195e9b2a60c54280b48b32ee8248090904dbc51) )
 
 	ROM_REGION( 0x1000, "gfx2", 0 )
-	ROM_LOAD( "c11-2.bin",    0x0000, 0x0800, CRC(d1352c31) SHA1(da726a63a8be830d695afeddc1717749af8c9d47) )
-	ROM_LOAD( "a11-1.bin",    0x0800, 0x0800, CRC(a7a2fdbd) SHA1(529865f8bbfbdbbf34ac39c70ef17e6d5bd0f845) )
+	ROM_LOAD( "2.11c",        0x0000, 0x0800, CRC(d1352c31) SHA1(da726a63a8be830d695afeddc1717749af8c9d47) )
+	ROM_LOAD( "1.11a",        0x0800, 0x0800, CRC(a7a2fdbd) SHA1(529865f8bbfbdbbf34ac39c70ef17e6d5bd0f845) )
 
 	ROM_REGION( 0x0060, "proms", 0 )
 	ROM_LOAD( "prom.v6",      0x0000, 0x0020, CRC(b3fc1505) SHA1(5b94adde0428a26b815c7eb9b3f3716470d349c7) )
 	ROM_LOAD( "prom.u6",      0x0020, 0x0020, CRC(26aada9e) SHA1(f59645e606ea4f0dd0fc4ea47dd03f526c534941) )
 	ROM_LOAD( "prom.t6",      0x0040, 0x0020, CRC(676b3166) SHA1(29b9434cd34d43ea5664e436e2a24b54f8d88aac) )
 
-	ROM_REGION( 0x2000, "samples", 0 )  /* samples */
-	ROM_LOAD( "s05-14.bin",   0x0000, 0x1000, CRC(5f0bcdfb) SHA1(7f79bf6de117348f606696ed7ea1937bbf926612) )
-	ROM_LOAD( "r05-13.bin",   0x1000, 0x1000, CRC(9003ffbd) SHA1(fd016056aabc23957643f37230f03842294f795e) )
+	ROM_REGION( 0x2000, "samples", 0 )	/* samples */
+	ROM_LOAD( "14.5s",        0x0000, 0x1000, CRC(5f0bcdfb) SHA1(7f79bf6de117348f606696ed7ea1937bbf926612) )
+	ROM_LOAD( "13.5p",        0x1000, 0x1000, CRC(9003ffbd) SHA1(fd016056aabc23957643f37230f03842294f795e) )
 ROM_END
 
 /* Sets below are 'Crazy Kong' without the extra Falcon screen or Pt. 2 subtitle, they also have worse colours */
diff -Nru src-old/mame/drivers/centiped.c src/mame/drivers/centiped.c
--- src-old/mame/drivers/centiped.c	2012-06-02 00:40:15.000000000 +0200
+++ src/mame/drivers/centiped.c	2012-07-02 09:06:11.000000000 +0200
@@ -22,7 +22,7 @@
       136001-305.fh1
       136001-306.j1
 
-    Milipede:
+    Millipede:
       136013-109.5p
       136013-110.5r
 
@@ -428,6 +428,7 @@
 #include "emu.h"
 #include "cpu/m6502/m6502.h"
 #include "cpu/s2650/s2650.h"
+#include "machine/eeprom.h"
 #include "machine/atari_vg.h"
 #include "includes/centiped.h"
 #include "sound/ay8910.h"
@@ -460,6 +461,7 @@
 	state->save_item(NAME(state->m_oldpos));
 	state->save_item(NAME(state->m_sign));
 	state->save_item(NAME(state->m_dsw_select));
+	state->save_item(NAME(state->m_prg_bank));
 }
 
 
@@ -470,6 +472,7 @@
 	cputag_set_input_line(machine, "maincpu", 0, CLEAR_LINE);
 	state->m_dsw_select = 0;
 	state->m_control_select = 0;
+	state->m_prg_bank = 0;
 }
 
 
@@ -571,7 +574,8 @@
      * the inputs, and has the good side effect of disabling
      * the actual Joy1 inputs while control_select is no zero.
      */
-	if (0 != m_control_select) {
+	if (m_control_select != 0)
+	{
 		/* Bottom 4 bits is our joystick inputs */
 		UINT8 joy2data = ioport("IN3")->read() & 0x0f;
 		data = data & 0xf0; /* Keep the top 4 bits */
@@ -583,14 +587,12 @@
 
 WRITE8_MEMBER(centiped_state::input_select_w)
 {
-
 	m_dsw_select = (~data >> 7) & 1;
 }
 
 /* used P2 controls if 1, P1 controls if 0 */
 WRITE8_MEMBER(centiped_state::control_select_w)
 {
-
 	m_control_select = (data >> 7) & 1;
 }
 
@@ -605,7 +607,6 @@
 
 WRITE8_MEMBER(centiped_state::mazeinv_input_select_w)
 {
-
 	m_control_select = offset & 3;
 }
 
@@ -616,6 +617,9 @@
 		case 0x0033:
 		case 0x6b19:
 			return 0x01;
+
+		default:
+			break;
 	}
 
 	return 0;
@@ -656,29 +660,6 @@
 
 /*************************************
  *
- *  Bootleg sound
- *
- *************************************/
-
-WRITE8_MEMBER(centiped_state::caterplr_AY8910_w)
-{
-	device_t *device = machine().device("pokey");
-	ay8910_address_w(device, 0, offset);
-	ay8910_data_w(device, 0, data);
-}
-
-
-READ8_MEMBER(centiped_state::caterplr_AY8910_r)
-{
-	device_t *device = machine().device("pokey");
-	ay8910_address_w(device, 0, offset);
-	return ay8910_r(device, 0);
-}
-
-
-
-/*************************************
- *
  *  Centipede CPU memory handlers
  *
  *************************************/
@@ -706,23 +687,14 @@
 	AM_RANGE(0x2000, 0x3fff) AM_ROM
 ADDRESS_MAP_END
 
+
 static ADDRESS_MAP_START( centiped_map, AS_PROGRAM, 8, centiped_state )
 	AM_IMPORT_FROM(centiped_base_map)
 	AM_RANGE(0x1000, 0x100f) AM_DEVREADWRITE("pokey", pokey_device, read, write)
 ADDRESS_MAP_END
 
-static ADDRESS_MAP_START( magworm_map, AS_PROGRAM, 8, centiped_state )
-	AM_IMPORT_FROM(centiped_base_map)
-	AM_RANGE(0x1001, 0x1001) AM_DEVWRITE_LEGACY("pokey", ay8910_address_w)
-	AM_RANGE(0x1003, 0x1003) AM_DEVREADWRITE_LEGACY("pokey", ay8910_r, ay8910_data_w)
-ADDRESS_MAP_END
-
-static ADDRESS_MAP_START( caterplr_map, AS_PROGRAM, 8, centiped_state )
-	AM_IMPORT_FROM(centiped_base_map)
-	AM_RANGE(0x1780, 0x1780) AM_READ(caterplr_rand_r)
-	AM_RANGE(0x1000, 0x100f) AM_READWRITE(caterplr_AY8910_r, caterplr_AY8910_w)
-ADDRESS_MAP_END
 
+//// Centipede bootlegs ////
 
 static ADDRESS_MAP_START( centipdb_map, AS_PROGRAM, 8, centiped_state )
 	ADDRESS_MAP_GLOBAL_MASK(0x7fff)
@@ -751,6 +723,34 @@
 ADDRESS_MAP_END
 
 
+static ADDRESS_MAP_START( magworm_map, AS_PROGRAM, 8, centiped_state )
+	AM_IMPORT_FROM(centiped_base_map)
+	AM_RANGE(0x1001, 0x1001) AM_DEVWRITE_LEGACY("pokey", ay8910_address_w)
+	AM_RANGE(0x1003, 0x1003) AM_DEVREADWRITE_LEGACY("pokey", ay8910_r, ay8910_data_w)
+ADDRESS_MAP_END
+
+
+static ADDRESS_MAP_START( caterplr_map, AS_PROGRAM, 8, centiped_state )
+	AM_IMPORT_FROM(centiped_base_map)
+	AM_RANGE(0x1780, 0x1780) AM_READ(caterplr_rand_r)
+	AM_RANGE(0x1000, 0x100f) AM_READWRITE(caterplr_AY8910_r, caterplr_AY8910_w)
+ADDRESS_MAP_END
+
+WRITE8_MEMBER(centiped_state::caterplr_AY8910_w)
+{
+	device_t *device = machine().device("pokey");
+	ay8910_address_w(device, 0, offset);
+	ay8910_data_w(device, 0, data);
+}
+
+READ8_MEMBER(centiped_state::caterplr_AY8910_r)
+{
+	device_t *device = machine().device("pokey");
+	ay8910_address_w(device, 0, offset);
+	return ay8910_r(device, 0);
+}
+
+
 
 /*************************************
  *
@@ -787,6 +787,101 @@
 
 /*************************************
  *
+ *  Multipede CPU memory handlers
+ *
+ *************************************/
+
+/*
+ Multipede is a daughterboard kit produced by Braze Technologies
+ from 2002(1st version) to 2004(1.2a). It allows users to play
+ Centipede and Millipede on one board.
+ The game can be switched at any time with P1+P2 start.
+
+ - M6502 CPU (from main pcb)
+ - 27C512 64KB EPROM
+ - 93C46P E2PROM for saving highscore/settings
+ - PALCE22V10H-25PC/4
+ - 74LS245
+ - 2*8KB gfx roms, on a separate smaller daughterboard
+
+ TODO: centiped does not work yet, the game reconfigures the memorymap
+*/
+
+static ADDRESS_MAP_START( multiped_map, AS_PROGRAM, 8, centiped_state )
+	AM_RANGE(0x0000, 0x03ff) AM_RAM
+	AM_RANGE(0x0400, 0x040f) AM_DEVREADWRITE("pokey", pokey_device, read, write)
+	AM_RANGE(0x0800, 0x080f) AM_DEVREADWRITE("pokey2", pokey_device, read, write)
+	AM_RANGE(0x1000, 0x13bf) AM_RAM_WRITE(centiped_videoram_w) AM_SHARE("videoram")
+	AM_RANGE(0x13c0, 0x13ff) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x2000, 0x2000) AM_READ(centiped_IN0_r)
+	AM_RANGE(0x2001, 0x2001) AM_READ(milliped_IN1_r)
+	AM_RANGE(0x2010, 0x2010) AM_READ(milliped_IN2_r)
+	AM_RANGE(0x2011, 0x2011) AM_READ_PORT("IN3")
+	AM_RANGE(0x2030, 0x2030) AM_READNOP
+	AM_RANGE(0x2480, 0x249f) AM_WRITE(milliped_paletteram_w) AM_SHARE("paletteram")
+	AM_RANGE(0x2500, 0x2502) AM_WRITE(coin_count_w)
+	AM_RANGE(0x2503, 0x2504) AM_WRITE(led_w)
+	AM_RANGE(0x2505, 0x2505) AM_WRITE(input_select_w)
+	AM_RANGE(0x2506, 0x2506) AM_WRITE(centiped_flip_screen_w)
+	AM_RANGE(0x2507, 0x2507) AM_WRITE(control_select_w)
+	AM_RANGE(0x2600, 0x2600) AM_WRITE(irq_ack_w)
+	AM_RANGE(0x2680, 0x2680) AM_WRITE(watchdog_reset_w)
+	AM_RANGE(0x2700, 0x2700) AM_WRITENOP
+	AM_RANGE(0x2780, 0x27bf) AM_WRITENOP
+	AM_RANGE(0x4000, 0x5fff) AM_ROM
+	AM_RANGE(0x6000, 0x7fff) AM_MIRROR(0x8000) AM_ROM
+	AM_RANGE(0x8000, 0xbfff) AM_ROM
+	AM_RANGE(0xd000, 0xd7ff) AM_WRITE(multiped_eeprom_w)
+	AM_RANGE(0xd800, 0xd800) AM_MIRROR(0x03ff) AM_READWRITE(multiped_eeprom_r, multiped_prgbank_w)
+	AM_RANGE(0xdc00, 0xdc00) AM_MIRROR(0x03ff) AM_WRITE(multiped_gfxbank_w)
+ADDRESS_MAP_END
+
+READ8_MEMBER(centiped_state::multiped_eeprom_r)
+{
+	eeprom_device *eeprom = machine().device<eeprom_device>("eeprom");
+	return eeprom->read_bit() ? 0x80 : 0;
+}
+
+WRITE8_MEMBER(centiped_state::multiped_eeprom_w)
+{
+	eeprom_device *eeprom = machine().device<eeprom_device>("eeprom");
+
+	// a0: always high
+	// a3-a7: always low
+	// a8-a10: same as a0-a2
+	// d0-d6: N/C?
+
+	// a1 low: latch bit
+	if (~offset & 2)
+		eeprom->write_bit((data & 0x80) ? 1 : 0);
+
+	// a2 low: write latch or select next bit to read
+	if (~offset & 4)
+		eeprom->set_clock_line((~data & 0x80) ? ASSERT_LINE : CLEAR_LINE);
+
+	// both high: reset
+	else if (offset & 2)
+		eeprom->set_cs_line((data & 0x80) ? CLEAR_LINE : ASSERT_LINE);
+}
+
+WRITE8_MEMBER(centiped_state::multiped_prgbank_w)
+{
+	// d0-d6: N/C?
+	// d7: prg (and gfx) rom bank
+	int bank = (data & 0x80) ? 1 : 0;
+	if (bank != m_prg_bank)
+	{
+		m_prg_bank = bank;
+		multiped_gfxbank_w(space, 0, m_gfx_bank << 6);
+
+		// TODO: prg bankswitch and alt memory map layout for centiped
+	}
+}
+
+
+
+/*************************************
+ *
  *  Warlords CPU memory handlers
  *
  *************************************/
@@ -1235,6 +1330,42 @@
 INPUT_PORTS_END
 
 
+static INPUT_PORTS_START( multiped )
+	// milliped board, but hard-dips are not used
+	PORT_INCLUDE( milliped )
+
+	PORT_MODIFY("IN0")
+	PORT_DIPUNUSED_DIPLOC( 0x01, 0x00, "P8:!1" )
+	PORT_DIPUNUSED_DIPLOC( 0x02, 0x00, "P8:!2" )
+	PORT_DIPUNUSED_DIPLOC( 0x04, 0x00, "P8:!3" )
+	PORT_DIPUNUSED_DIPLOC( 0x08, 0x00, "P8:!4" )
+
+	PORT_MODIFY("IN1")
+	PORT_DIPUNUSED_DIPLOC( 0x04, 0x00, "P8:!7" )
+	PORT_DIPUNUSED_DIPLOC( 0x08, 0x00, "P8:!8" )
+
+	PORT_MODIFY("DSW1")
+	PORT_DIPUNUSED_DIPLOC( 0x01, 0x00, "D5:!1" )
+	PORT_DIPUNUSED_DIPLOC( 0x02, 0x00, "D5:!2" )
+	PORT_DIPUNUSED_DIPLOC( 0x04, 0x00, "D5:!3" )
+	PORT_DIPUNUSED_DIPLOC( 0x08, 0x00, "D5:!4" )
+	PORT_DIPUNUSED_DIPLOC( 0x10, 0x00, "D5:!5" )
+	PORT_DIPUNUSED_DIPLOC( 0x20, 0x00, "D5:!6" )
+	PORT_DIPUNUSED_DIPLOC( 0x40, 0x00, "D5:!7" )
+	PORT_DIPUNUSED_DIPLOC( 0x80, 0x00, "D5:!8" )
+
+	PORT_MODIFY("DSW2")
+	PORT_DIPUNUSED_DIPLOC( 0x01, 0x00, "B5:!1" )
+	PORT_DIPUNUSED_DIPLOC( 0x02, 0x00, "B5:!2" )
+	PORT_DIPUNUSED_DIPLOC( 0x04, 0x00, "B5:!3" )
+	PORT_DIPUNUSED_DIPLOC( 0x08, 0x00, "B5:!4" )
+	PORT_DIPUNUSED_DIPLOC( 0x10, 0x00, "B5:!5" )
+	PORT_DIPUNUSED_DIPLOC( 0x20, 0x00, "B5:!6" )
+	PORT_DIPUNUSED_DIPLOC( 0x40, 0x00, "B5:!7" )
+	PORT_DIPUNUSED_DIPLOC( 0x80, 0x00, "B5:!8" )
+INPUT_PORTS_END
+
+
 static INPUT_PORTS_START( warlords )
 	PORT_START("IN0")
 	PORT_BIT( 0x0f, IP_ACTIVE_HIGH, IPT_UNUSED )
@@ -1722,6 +1853,17 @@
 MACHINE_CONFIG_END
 
 
+static MACHINE_CONFIG_DERIVED( multiped, milliped )
+
+	/* basic machine hardware */
+	MCFG_CPU_MODIFY("maincpu")
+	MCFG_CPU_PROGRAM_MAP(multiped_map)
+
+	MCFG_DEVICE_REMOVE("earom")
+	MCFG_EEPROM_93C46_8BIT_ADD("eeprom")
+MACHINE_CONFIG_END
+
+
 static MACHINE_CONFIG_DERIVED( warlords, centiped )
 
 	/* basic machine hardware */
@@ -1806,7 +1948,7 @@
 ROM_END
 
 
-ROM_START( centipdd ) /* Centipede "Dux" graphics hack by Two Bit Score */
+ROM_START( centipdd ) /* Centipede "Dux" graphics hack by Two-Bit Score in 1989 */
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "136001-307.d1",  0x2000, 0x0800, CRC(5ab0d9de) SHA1(8ea6e3304202831aabaf31dbd0f970a7b3bfe421) )
 	ROM_LOAD( "136001-308.e1",  0x2800, 0x0800, CRC(4c07fd3e) SHA1(af4fdbf32c23b1864819d620a874e7f205da3cdb) )
@@ -1933,7 +2075,7 @@
 ROM_END
 
 
-ROM_START( millipdd ) /* Millipede "Dux" graphics hack by Two Bit Score */
+ROM_START( millipdd ) /* Millipede "Dux" graphics hack by Two-Bit Score in 1989 */
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "136013-104.1mn", 0x4000, 0x1000, CRC(40711675) SHA1(b595d6a0f5d3c611ade1b83a94c3b909d2124dc4) )
 	ROM_LOAD( "136013-103.1l",  0x5000, 0x1000, CRC(fb01baf2) SHA1(9c1d0bbc20bf25dd21761a311fd1ed80aa029241) )
@@ -1949,6 +2091,21 @@
 ROM_END
 
 
+ROM_START( multiped )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00 ) // banked, decrypted rom goes here
+
+	ROM_REGION( 0x10000, "user1", 0 )
+	ROM_LOAD("cm_12a.bin", 0x00000, 0x10000, CRC(8248d42c) SHA1(613f449de99659714abdf86d1be4d9d68f624da2) )
+
+	ROM_REGION( 0x4000, "gfx1", 0 )
+	ROM_LOAD( "cm_5r.bin", 0x0000, 0x2000, CRC(45613f22) SHA1(5d512a286ca9e008bd2f0fdbc2f8cb9c006e3ac7) )
+	ROM_LOAD( "cm_5p.bin", 0x2000, 0x2000, CRC(cfbc3622) SHA1(a22da8f9b28effcd90794cb87ebc2afdf3fc4282) )
+
+	ROM_REGION( 0x0100, "proms", 0 )
+	ROM_LOAD( "136001-213.7e", 0x0000, 0x0100, CRC(6fa3093a) SHA1(2b7aeca74c1ae4156bf1878453a047330f96f0a8) ) /* not used */
+ROM_END
+
+
 ROM_START( mazeinv )
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "005.011",      0x3000, 0x1000, CRC(37129536) SHA1(356cb986a40b332100e00fb72194fd4dade2cba7) )
@@ -2019,6 +2176,21 @@
 }
 
 
+static DRIVER_INIT( multiped )
+{
+	UINT8 *src = machine.root_device().memregion("user1")->base();
+	UINT8 *dest = machine.root_device().memregion("maincpu")->base();
+
+	// descramble rom and put in maincpu region
+	for (int i = 0; i < 0x10000; i++)
+		dest[0x10000 + (i ^ (~i << 4 & 0x1000) ^ (~i >> 3 & 0x400))] = BITSWAP8(src[BITSWAP16(i,15,14,13,1,8,11,4,7,10,5,6,9,12,0,3,2)],0,2,1,3,4,5,6,7);
+
+	// (this can be removed when prg bankswitch is implemented)
+	memmove(dest+0x0000, dest+0x10000, 0x8000);
+	memmove(dest+0x8000, dest+0x10000, 0x8000);
+}
+
+
 
 /*************************************
  *
@@ -2030,12 +2202,13 @@
 GAME( 1980, centiped2,centiped, centiped, centiped, 0,        ROT270, "Atari",   "Centipede (revision 2)", GAME_SUPPORTS_SAVE )
 GAME( 1980, centtime, centiped, centiped, centtime, 0,        ROT270, "Atari",   "Centipede (1 player, timed)", GAME_SUPPORTS_SAVE )
 GAME( 1980, centipdb, centiped, centipdb, centiped, 0,        ROT270, "bootleg", "Centipede (bootleg)", GAME_SUPPORTS_SAVE )
-GAME( 1980, centipdd, centiped, centiped, centiped, 0,        ROT270, "hack",    "Centipede Dux (hack)", GAME_SUPPORTS_SAVE )
-GAME( 1980, caterplr, centiped, caterplr, caterplr, 0,        ROT270, "bootleg", "Caterpillar", GAME_SUPPORTS_SAVE )
-GAME( 1980, millpac,  centiped, centipdb, centiped, 0,        ROT270, "bootleg? (Valadon Automation)", "Millpac", GAME_SUPPORTS_SAVE )
-GAME( 1980, magworm,  centiped, magworm,  magworm,  0,        ROT270, "bootleg", "Magic Worm (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1989, centipdd, centiped, centiped, centiped, 0,        ROT270, "hack (Two-Bit Score)", "Centipede Dux (hack)", GAME_SUPPORTS_SAVE )
+GAME( 1980, caterplr, centiped, caterplr, caterplr, 0,        ROT270, "bootleg", "Caterpillar (bootleg of Centipede)", GAME_SUPPORTS_SAVE )
+GAME( 1980, millpac,  centiped, centipdb, centiped, 0,        ROT270, "bootleg? (Valadon Automation)", "Millpac (bootleg of Centipede)", GAME_SUPPORTS_SAVE )
+GAME( 1980, magworm,  centiped, magworm,  magworm,  0,        ROT270, "bootleg", "Magic Worm (bootleg of Centipede)", GAME_SUPPORTS_SAVE )
 GAME( 1982, milliped, 0,        milliped, milliped, 0,        ROT270, "Atari",   "Millipede", GAME_SUPPORTS_SAVE )
-GAME( 1982, millipdd, milliped, milliped, milliped, 0,        ROT270, "hack",    "Millipede Dux (hack)", GAME_SUPPORTS_SAVE )
+GAME( 1989, millipdd, milliped, milliped, milliped, 0,        ROT270, "hack (Two-Bit Score)", "Millipede Dux (hack)", GAME_SUPPORTS_SAVE )
+GAME( 2002, multiped, 0,        multiped, multiped, multiped, ROT270, "hack (Braze Technologies)", "Multipede (Centipede/Millipede multigame kit)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
 
 GAME( 1980, warlords, 0,        warlords, warlords, 0,        ROT0,   "Atari",   "Warlords", GAME_SUPPORTS_SAVE )
 GAME( 1981, mazeinv,  0,        mazeinv,  mazeinv,  0,        ROT270, "Atari",   "Maze Invaders (prototype)", 0 )
diff -Nru src-old/mame/drivers/champbwl.c src/mame/drivers/champbwl.c
--- src-old/mame/drivers/champbwl.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/drivers/champbwl.c	2012-06-13 15:58:02.000000000 +0200
@@ -534,7 +534,7 @@
 	machine.root_device().membank("bank1")->configure_entries(0, 4, &ROM[0x10000], 0x4000);
 }
 
-static MACHINE_CONFIG_START( doraemon, tnzs_state )
+static MACHINE_CONFIG_START( doraemon, champbwl_state )
 
 	/* basic machine hardware */
 	MCFG_CPU_ADD("maincpu", Z80, XTAL_14_31818MHz/4)
diff -Nru src-old/mame/drivers/chihiro.c src/mame/drivers/chihiro.c
--- src-old/mame/drivers/chihiro.c	2012-05-23 09:50:33.000000000 +0200
+++ src/mame/drivers/chihiro.c	2012-07-02 08:20:21.000000000 +0200
@@ -1124,7 +1124,7 @@
 	AM_RANGE(0x0040, 0x0043) AM_DEVREADWRITE8_LEGACY("pit8254", pit8253_r, pit8253_w, 0xffffffff)
 	AM_RANGE(0x00a0, 0x00a3) AM_DEVREADWRITE8_LEGACY("pic8259_2", pic8259_r, pic8259_w, 0xffffffff)
 	AM_RANGE(0x01f0, 0x01f7) AM_READWRITE_LEGACY(ide_r, ide_w)
-	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE_LEGACY("pcibus", pci_32le_r, pci_32le_w)
+	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_bus_legacy_device, read, write)
 	AM_RANGE(0x8000, 0x80ff) AM_READWRITE_LEGACY(dummy_r, dummy_w)
 	AM_RANGE(0xc000, 0xc0ff) AM_READWRITE_LEGACY(smbus_r, smbus_w)
 	AM_RANGE(0xff60, 0xff67) AM_DEVREADWRITE_LEGACY("ide", ide_bus_master32_r, ide_bus_master32_w)
@@ -1167,15 +1167,15 @@
 
 	MCFG_QUANTUM_TIME(attotime::from_hz(6000))
 
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(0, "PCI Bridge Device - Host Bridge", dummy_pci_r, dummy_pci_w)
-	MCFG_PCI_BUS_DEVICE(1, "HUB Interface - ISA Bridge", dummy_pci_r, dummy_pci_w)
-	MCFG_PCI_BUS_DEVICE(2, "OHCI USB Controller 1", dummy_pci_r, dummy_pci_w)
-	MCFG_PCI_BUS_DEVICE(3, "OHCI USB Controller 2", dummy_pci_r, dummy_pci_w)
-	MCFG_PCI_BUS_DEVICE(30, "AGP Host to PCI Bridge", dummy_pci_r, dummy_pci_w)
-	MCFG_PCI_BUS_ADD("agpbus", 1)
-	MCFG_PCI_BUS_SIBLING("pcibus")
-	MCFG_PCI_BUS_DEVICE(0, "NV2A GeForce 3MX Integrated GPU/Northbridge", geforce_pci_r, geforce_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(0, "PCI Bridge Device - Host Bridge", dummy_pci_r, dummy_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(1, "HUB Interface - ISA Bridge", dummy_pci_r, dummy_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(2, "OHCI USB Controller 1", dummy_pci_r, dummy_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(3, "OHCI USB Controller 2", dummy_pci_r, dummy_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(30, "AGP Host to PCI Bridge", dummy_pci_r, dummy_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("agpbus", 1)
+	MCFG_PCI_BUS_LEGACY_SIBLING("pcibus")
+	MCFG_PCI_BUS_LEGACY_DEVICE(0, "NV2A GeForce 3MX Integrated GPU/Northbridge", geforce_pci_r, geforce_pci_w)
 	MCFG_PIC8259_ADD( "pic8259_1", chihiro_pic8259_1_config )
 	MCFG_PIC8259_ADD( "pic8259_2", chihiro_pic8259_2_config )
 	MCFG_PIT8254_ADD( "pit8254", chihiro_pit8254_config )
diff -Nru src-old/mame/drivers/cmmb.c src/mame/drivers/cmmb.c
--- src-old/mame/drivers/cmmb.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/drivers/cmmb.c	2012-07-02 09:06:11.000000000 +0200
@@ -7,6 +7,8 @@
 
 Earlier revisions of this cabinet did not include the bowling game.
  Known to exist "CMM Rev 1.03" (without Let's Go Bowling)
+ Let's Go Bowling is actually a completely new game by Cosmodog, not
+ a port or prototype of an old Atari game.
 
 TODO:
 - program banking;
@@ -31,12 +33,13 @@
 
 Multipede 1.00 PCB by CosmoDog
 
-Flash ROM AT29C020
+U1  = WDC 65C02S8P-14
+U2  = Flash ROM AT29C020 (256KB)
+U4  = ISSI IS62LV256-45J (32KB)
+U5  = CY39100V208B (Cypress CPLD)
+U9  = CY37128-P100 (Cypress CPLD)
+U10 = CYC1399 (?)
 
-Cypress CY39100V208B
-CPU WDC 65C02S8P-14
-CY37128-P100
-CYC1399
 OSC @ 72.576MHz
 
 ***************************************************************************/
@@ -49,8 +52,9 @@
 {
 public:
 	cmmb_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) ,
-		m_videoram(*this, "videoram"){ }
+		: driver_device(mconfig, type, tag),
+		m_videoram(*this, "videoram")
+	{ }
 
 	required_shared_ptr<UINT8> m_videoram;
 	UINT8 m_irq_mask;
@@ -298,7 +302,8 @@
 static INTERRUPT_GEN( cmmb_irq )
 {
 	//if(device->machine().input().code_pressed_once(KEYCODE_Z))
-	//  device_set_input_line(device, 0, HOLD_LINE);
+	//if(device->machine().input().code_pressed(KEYCODE_Z))
+//      device_set_input_line(device, 0, HOLD_LINE);
 }
 
 static MACHINE_RESET( cmmb )
@@ -308,7 +313,7 @@
 static MACHINE_CONFIG_START( cmmb, cmmb_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu",M65SC02,XTAL_72_576MHz/5) // Unknown clock, but chip rated for 14MHz
+	MCFG_CPU_ADD("maincpu", M65SC02, XTAL_72_576MHz/5) // Unknown clock, but chip rated for 14MHz
 	MCFG_CPU_PROGRAM_MAP(cmmb_map)
 	MCFG_CPU_VBLANK_INT("screen",cmmb_irq)
 
@@ -347,4 +352,4 @@
 	ROM_REGION( 0x1000, "gfx", ROMREGION_ERASE00 )
 ROM_END
 
-GAME( 2002, cmmb162,  0,       cmmb,  cmmb,  0, ROT270, "Infogrames / Cosmodog", "Multipede (rev 1.62)", GAME_NO_SOUND|GAME_NOT_WORKING )
+GAME( 2002, cmmb162,  0,       cmmb,  cmmb,  0, ROT270, "Cosmodog / Team Play (Licensed from Infogrames via Midway Games West)", "Multipede (rev 1.62)", GAME_NO_SOUND|GAME_NOT_WORKING )
diff -Nru src-old/mame/drivers/cobra.c src/mame/drivers/cobra.c
--- src-old/mame/drivers/cobra.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/cobra.c	2012-07-02 08:20:21.000000000 +0200
@@ -288,7 +288,7 @@
 			printf("    ");
 			for (i=0; i < 4; i++)
 			{
-				UINT64 val;
+				UINT64 val = 0;
 				fifo_pop(cpu, id, &val);
 				printf("%08X ", (UINT32)(val));
 			}
@@ -368,7 +368,7 @@
 
 static int fifo_pop_float(const device_t *cpu, int id, float *result)
 {
-	UINT64 value;
+	UINT64 value = 0;
 	int status = fifo_pop(cpu, id, &value);
 	*result = u2f((UINT32)(value));
 	return status;
@@ -469,7 +469,7 @@
 static int s2mfifo_unk_flag = 0;
 
 static UINT32 mpc106_regs[256/4];
-static UINT32 mpc106_pci_r(int function, int reg, UINT32 mem_mask)
+static UINT32 mpc106_pci_r(device_t *busdevice, device_t *device, int function, int reg, UINT32 mem_mask)
 {
 	//printf("MPC106: PCI read %d, %02X, %08X\n", function, reg, mem_mask);
 
@@ -480,7 +480,7 @@
 	return mpc106_regs[reg/4];
 }
 
-static void mpc106_pci_w(int function, int reg, UINT32 data, UINT32 mem_mask)
+static void mpc106_pci_w(device_t *busdevice, device_t *device, int function, int reg, UINT32 data, UINT32 mem_mask)
 {
 	//printf("MPC106: PCI write %d, %02X, %08X, %08X\n", function, reg, data, mem_mask);
 	COMBINE_DATA(mpc106_regs + (reg/4));
@@ -488,16 +488,16 @@
 
 READ64_MEMBER(cobra_state::main_mpc106_r)
 {
-	device_t *device = machine().device("pcibus");
+	pci_bus_legacy_device *device = machine().device<pci_bus_legacy_device>("pcibus");
 	//return pci_64be_r(offset, mem_mask);
-	return pci_64be_r(device, offset, mem_mask);
+	return device->read_64be(space, offset, mem_mask);
 }
 
 WRITE64_MEMBER(cobra_state::main_mpc106_w)
 {
-	device_t *device = machine().device("pcibus");
+	pci_bus_legacy_device *device = machine().device<pci_bus_legacy_device>("pcibus");
 	//pci_64be_w(offset, data, mem_mask);
-	pci_64be_w(device, offset, data, mem_mask);
+	device->write_64be(space, offset, data, mem_mask);
 }
 
 READ64_MEMBER(cobra_state::main_fifo_r)
@@ -1063,7 +1063,7 @@
 
 	while (fifo_current_num(GFXFIFO_IN) >= 2)
 	{
-		UINT64 in1, in2;
+		UINT64 in1, in2 = 0;
 		UINT32 w1, w2;
 
 		if (gfx_re_status == RE_STATUS_IDLE)
@@ -1104,6 +1104,8 @@
 				if (fifo_current_num(GFXFIFO_IN) < 6)
 				{
 					// wait until there's enough data in FIFO
+                    memset(param, 0, sizeof(param));
+                    memset(w, 0, sizeof(w));
 					return;
 				}
 
@@ -1151,7 +1153,7 @@
 			case 0x0f:
 			case 0xf0:
 			{
-				UINT64 in3, in4, ignore;
+				UINT64 in3 = 0, in4 = 0, ignore;
 
 				// check_mergebus_self(): 0x0F600000 0x10520C00
 
@@ -1346,7 +1348,7 @@
 
 					for (i=0; i < 3; i++)
 					{
-						UINT64 in;
+						UINT64 in = 0;
 						fifo_pop(NULL, GFXFIFO_IN, &in);
 
 						fifo_pop(NULL, GFXFIFO_IN, &in);
@@ -1374,7 +1376,7 @@
 				{
 					for (i=0; i < num; i+=2)
 					{
-						UINT64 in3, in4;
+						UINT64 in3 = 0, in4 = 0;
 						fifo_pop(NULL, GFXFIFO_IN, &in3);
 						fifo_pop(NULL, GFXFIFO_IN, &in4);
 						printf("                        %08X %08X (%f, %f)\n", (UINT32)(in3), (UINT32)(in4), u2f((UINT32)(in3)), u2f((UINT32)(in4)));
@@ -1501,7 +1503,7 @@
 				// writes to n ram location starting from x?
 				for (i = 0; i < num; i++)
 				{
-					UINT64 value;
+					UINT64 value = 0;
 					fifo_pop(NULL, GFXFIFO_IN, &value);
 
 					gfx_gram[reg + (i*4) + 0] = (value >> 24) & 0xff;
@@ -1633,7 +1635,7 @@
 
 					for (i=0; i < num_left; i++)
 					{
-						UINT64 param;
+						UINT64 param = 0;
 						fifo_pop(NULL, GFXFIFO_IN, &param);
 						gfx_re_word_count++;
 
@@ -2025,8 +2027,8 @@
 
 	MCFG_MACHINE_RESET( cobra )
 
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(0, NULL, mpc106_pci_r, mpc106_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(0, NULL, mpc106_pci_r, mpc106_pci_w)
 
 	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL, true)
 
diff -Nru src-old/mame/drivers/crospang.c src/mame/drivers/crospang.c
--- src-old/mame/drivers/crospang.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/crospang.c	2012-06-27 07:38:17.000000000 +0200
@@ -141,7 +141,7 @@
 	PORT_DIPSETTING(      0x000c, DEF_STR( Medium ) )       /* table at 0x02e88c */
 	PORT_DIPSETTING(      0x0000, DEF_STR( Hard ) )         /* table at 0x02f96c */
 	PORT_DIPSETTING(      0x0004, DEF_STR( Hardest ) )      /* table at 0x02f3cc */
-	PORT_DIPNAME( 0x0010, 0x0010, "Bonus Power (Points)" )  PORT_DIPLOCATION("SW1:6")
+	PORT_DIPNAME( 0x0010, 0x0010, "Bonus Power (Points)" )  PORT_DIPLOCATION("SW1:5")
 	PORT_DIPSETTING(      0x0010, "5k 20k 15k+" )
 	PORT_DIPSETTING(      0x0000, "8k 23k 15k+" )
 	PORT_DIPNAME( 0x0020, 0x0020, "Number of Powers" )      PORT_DIPLOCATION("SW1:6")
diff -Nru src-old/mame/drivers/ddenlovr.c src/mame/drivers/ddenlovr.c
--- src-old/mame/drivers/ddenlovr.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/drivers/ddenlovr.c	2012-07-02 09:06:11.000000000 +0200
@@ -9,37 +9,40 @@
 Sound: (AY-3-8910) + YM2413 + MSM6295
 Other: Real Time Clock (Oki MSM6242B or 72421B)
 
-------------------------------------------------------------------------------------------------------------------
-Year + Game              Board              CPU   Sound              Custom                                 Other
-------------------------------------------------------------------------------------------------------------------
-92 Monkey Mole Panic                        2xZ80 AY8910 YM2413 M6295 NL-001 1108(x2)   1427(x2)            8251
-93 Animalandia Jr.                          2xZ80 AY8910 YM2413 M6295 NL-001 NL-003(x2) NL-004(x2)          8251
-93 Quiz Channel Question N7311208L1-2       Z80          YM2413 M6295 NL-002 1108F0405  1427F0071
-93 First Funky Fighter   N7403208L-2        2xZ80 YM2149 YM2413 M6295 NL-001 NL-002     NL-005
-94 Mysterious World      D7107058L1-1       Z80   YM2149 YM2413 M6295 NL-002 1108F0405  1427F0071 4L02?
-94 Mysterious Universe   D7107058L1-1       Z80   YM2149 YM2413 M6295 NL-002 1108F0405  1427F0071
-94 Mysterious Orient     D7107058L1-1       Z80   YM2149 YM2413 M6295 NL-002 1108F0405  1427F0071
-94 Quiz 365                                 68000 AY8910 YM2413 M6295
-94 Rong Rong (J)         N8010178L1         Z80          YM2413 M6295 NL-002 1108F0405  1427F0071 4L02F2637
-94 Hana Ginga            D8102048L1         Z80   YM2149 YM2413 M6295 NL-002 1108F0405  1427F0071 4L02?
-94 Super Hana Paradise   N8010178L1+N73RSUB Z80          YM2413 M6295 NL-002 1108F0406  1427F0071 4L02F2637
-95 Dai Chuuka Ken        D11107218L1        Z80   AY8910 YM2413 M6295 70C160F009
-95 Hana Gokou            N83061581L1        Z80   AY8910 YM2413 M6295 NL-002 1108?      1427?     4L02?
-95 Hana Gokou Bangaihen  N10805078L1        Z80   AY8910 YM2413 M6295 NL-002 1108?      1427?     4L02?
-95 Nettoh Quiz Champion                     68000 AY8910 YM2413 M6295
-95 Don Den Lover (J)     D1120901L8         68000 YMZ284 YM2413 M6295 NL-005
-96 Don Den Lover (HK)    D11309208L1        68000 YMZ284 YM2413 M6295 NL-005
-96 Panel&Variety Akamaru                    68000 YMZ284 YM2413 M6295 NL-005
-96 Fantasic Love         NS5000101+?        Z80   YMZ284 YM2413 M6295 NL-005
-96 Hana Kanzashi                            Z80          YM2413 M6295 70C160F011?
-96 Mj Seiryu Densetsu    NM5020403          Z80   YMZ284 YM2413 M6295 70C160F011?
-97 Hana Kagerou                             Z80          YM2413 M6295 70C160F011
-98 Chuukanejyo           D11107218L1        Z80   AY8910 YM2413 M6295 70C160F009
-98 Reach Ippatsu                            Z80          YM2413 M6295 70C160F011
-99 Jong-Tei              NM532-9902         Z80          YM2413 M6295 4L10FXXXX?
-02 Mj Daimyojin          TSM015-0111        Z80          YM2413 M6295 70C160F011
-04 Mj Momotarou          TSM015-0111?       Z80          YM2413 M6295 70C160F011?
-------------------------------------------------------------------------------------------------------------------
+-------------------------------------------------------------------------------------------------------------------
+Year + Game                Board              CPU   Sound               Custom                                Other
+-------------------------------------------------------------------------------------------------------------------
+92 Monkey Mole Panic                          2xZ80 AY8910 YM2413 M6295 NL-001 1108(x2)   1427(x2)            8251
+93 Animalandia Jr.                            2xZ80 AY8910 YM2413 M6295 NL-001 NL-003(x2) NL-004(x2)          8251
+93 Quiz Channel Question   N7311208L1-2       Z80          YM2413 M6295 NL-002 1108F0405  1427F0071
+93 First Funky Fighter     N7403208L-2        2xZ80 YM2149 YM2413 M6295 NL-001 NL-002     NL-005
+94 Mj Mysterious World     D7107058L1-1       Z80   YM2149 YM2413 M6295 NL-002 1108F0405  1427F0071 4L02?
+94 Mj Mysterious Universe  D7107058L1-1       Z80   YM2149 YM2413 M6295 NL-002 1108F0405  1427F0071
+94 Mj Mysterious Orient    D7107058L1-1       Z80   YM2149 YM2413 M6295 NL-002 1108F0405  1427F0071
+94 Quiz 365                                   68000 AY8910 YM2413 M6295
+94 Rong Rong (J)           N8010178L1         Z80          YM2413 M6295 NL-002 1108F0405  1427F0071 4L02F2637
+94 Hf Hana Ginga           D8102048L1         Z80   YM2149 YM2413 M6295 NL-002 1108F0405  1427F0071 4L02?
+94 Super Hana Paradise     N8010178L1+N73RSUB Z80          YM2413 M6295 NL-002 1108F0406  1427F0071 4L02F2637
+95 Mj Dai Chuuka Ken       D11107218L1        Z80   AY8910 YM2413 M6295 70C160F009
+95 Hf Hana Gokou           N83061581L1        Z80   AY8910 YM2413 M6295 NL-002 1108?      1427?     4L02?
+95 Hf Hana Gokou Bangaihen N10805078L1        Z80   AY8910 YM2413 M6295 NL-002 1108?      1427?     4L02?
+95 Nettoh Quiz Champion                       68000 AY8910 YM2413 M6295
+95 Don Den Lover (J)       D1120901L8         68000 YMZ284 YM2413 M6295 NL-005
+96 Don Den Lover (HK)      D11309208L1        68000 YMZ284 YM2413 M6295 NL-005
+96 Panel&Variety Akamaru                      68000 YMZ284 YM2413 M6295 NL-005
+96 Mj Fantasic Love        NS5000101+?        Z80   YMZ284 YM2413 M6295 NL-005
+96 Hana Kanzashi                              Z80          YM2413 M6295 70C160F011?
+96 Mj Seiryu Densetsu      NM5020403          Z80   YMZ284 YM2413 M6295 70C160F011?
+96 Mj Janshin Plus         NM7001004          Z80   YMZ284 YM2413 M6295 TZ-2053P
+96 Mj Dai Touyouken        NM7001004          Z80   YMZ284 YM2413 M6295 TZ-2053P
+96 Return Of Sel Jan II    NM504-2            Z80   YM2149 YM2413 M6295 TZ-2053P?
+97 Hana Kagerou                               Z80          YM2413 M6295 70C160F011
+98 Mj Chuukanejyo          D11107218L1        Z80   AY8910 YM2413 M6295 70C160F009
+98 Mj Reach Ippatsu                           Z80          YM2413 M6295 70C160F011
+99 Mj Jong-Tei             NM532-9902         Z80          YM2413 M6295 4L10FXXXX?
+02 Mj Daimyojin            TSM015-0111        Z80          YM2413 M6295 70C160F011
+04 Mj Momotarou            TSM015-0111?       Z80          YM2413 M6295 70C160F011?
+-------------------------------------------------------------------------------------------------------------------
 
 TODO:
 
@@ -89,6 +92,8 @@
 - sryudens: Transparency problems (Test->Option->Gal, Bonus Game during Demo mode).
   e.g. in the latter, transparency pen is set to ff instead of 0 (I/O address 2b)
 
+- implement palette RAM enable in most games. Done for seljan2 (in a convoluted way).
+
 Notes:
 
 - daimyojn: In Test->Option, press "N Ron Ron N" to access more options
@@ -955,7 +960,6 @@
 
 			switch (data)
 			{
-
 				case 0x84:	// same as 04?
 				case 0x04:	blit_fill_xy(machine, 0, 0);
 							break;
@@ -1217,7 +1221,6 @@
 
 WRITE16_MEMBER(dynax_state::ddenlovr_blitter_irq_ack_w)
 {
-
 	if (ACCESSING_BITS_0_7)
 	{
 		if (data & 1)
@@ -1484,28 +1487,24 @@
 
 WRITE16_MEMBER(dynax_state::ddenlovr16_palette_base_w)
 {
-
 	if (ACCESSING_BITS_0_7)
 		m_ddenlovr_palette_base[offset] = data & 0xff;
 }
 
 WRITE16_MEMBER(dynax_state::ddenlovr16_palette_mask_w)
 {
-
 	if (ACCESSING_BITS_0_7)
 		m_ddenlovr_palette_mask[offset] = data & 0xff;
 }
 
 WRITE16_MEMBER(dynax_state::ddenlovr16_transparency_pen_w)
 {
-
 	if (ACCESSING_BITS_0_7)
 		m_ddenlovr_transparency_pen[offset] = data & 0xff;
 }
 
 WRITE16_MEMBER(dynax_state::ddenlovr16_transparency_mask_w)
 {
-
 	if (ACCESSING_BITS_0_7)
 		m_ddenlovr_transparency_mask[offset] = data & 0xff;
 }
@@ -1573,7 +1572,6 @@
 
 WRITE16_MEMBER(dynax_state::ddenlovr_select_16_w)
 {
-
 	if (ACCESSING_BITS_0_7)
 		m_dsw_sel = data;
 }
@@ -1585,14 +1583,12 @@
 
 WRITE16_MEMBER(dynax_state::ddenlovr_select2_16_w)
 {
-
 	if (ACCESSING_BITS_0_7)
 		m_input_sel = data;
 }
 
 READ8_MEMBER(dynax_state::rongrong_input2_r)
 {
-
 //  logerror("%04x: input2_r offset %d select %x\n", cpu_get_pc(&space.device()), offset, m_input_sel);
 	/* 0 and 1 are read from offset 1, 2 from offset 0... */
 	switch (m_input_sel)
@@ -1619,7 +1615,6 @@
 
 READ16_MEMBER(dynax_state::quiz365_input2_r)
 {
-
 //  logerror("%04x: input2_r offset %d select %x\n",cpu_get_pc(&space.device()), offset, m_input_sel);
 	/* 0 and 1 are read from offset 1, 2 from offset 0... */
 	switch (m_input_sel)
@@ -1642,7 +1637,6 @@
 
 READ8_MEMBER(dynax_state::rongrong_blitter_busy_r)
 {
-
 	switch (m_rongrong_blitter_busy_select)
 	{
 		case 0x18:	return 0;	// bit 5 = blitter busy
@@ -1656,7 +1650,6 @@
 
 WRITE16_MEMBER(dynax_state::quiz365_coincounter_w)
 {
-
 	if (ACCESSING_BITS_0_7)
 	{
 		if (m_input_sel == 0x1c)
@@ -1673,7 +1666,6 @@
 */
 READ16_MEMBER(dynax_state::quiz365_protection_r)
 {
-
 	switch (m_quiz365_protection[0])
 	{
 		case 0x3a:
@@ -1800,7 +1792,6 @@
 }
 WRITE16_MEMBER(dynax_state::ddenlovrk_protection2_w)
 {
-
 	COMBINE_DATA(m_protection2);
 	m_oki->set_bank_base(((*m_protection2) & 0x7) * 0x40000);
 }
@@ -1887,7 +1878,6 @@
 
 READ16_MEMBER(dynax_state::nettoqc_input_r)
 {
-
 	if (!BIT(m_dsw_sel, 0))	return ioport("DSW1")->read();
 	if (!BIT(m_dsw_sel, 1))	return ioport("DSW2")->read();
 	if (!BIT(m_dsw_sel, 2))	return ioport("DSW3")->read();
@@ -1903,7 +1893,6 @@
 
 READ16_MEMBER(dynax_state::nettoqc_protection_r)
 {
-
 	switch (m_protection1[0] & 0xff)
 	{
 		case 0x3a:	return 0x0051;
@@ -1970,7 +1959,6 @@
 
 READ8_MEMBER(dynax_state::rongrong_input_r)
 {
-
 	if (!BIT(m_dsw_sel, 0))	return ioport("DSW1")->read();
 	if (!BIT(m_dsw_sel, 1))	return ioport("DSW2")->read();
 	if (!BIT(m_dsw_sel, 2))	return 0xff;//machine().rand();
@@ -1981,7 +1969,6 @@
 
 WRITE8_MEMBER(dynax_state::rongrong_select_w)
 {
-
 //logerror("%04x: rongrong_select_w %02x\n",cpu_get_pc(&space.device()),data);
 
 	/* bits 0-4 = **both** ROM bank **AND** input select */
@@ -1994,10 +1981,10 @@
 
 
 static ADDRESS_MAP_START( quizchq_map, AS_PROGRAM, 8, dynax_state )
-	AM_RANGE(0x0000, 0x5fff) AM_ROM											// ROM
-	AM_RANGE(0x6000, 0x6fff) AM_RAM											// RAM
-	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")									// RAM (Banked)
-	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1") AM_WRITE(rongrong_palette_w)		// ROM (Banked)
+	AM_RANGE(0x0000, 0x5fff) AM_ROM												// ROM
+	AM_RANGE(0x6000, 0x6fff) AM_RAM												// RAM
+	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")								// RAM (Banked)
+	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1") AM_WRITE(rongrong_palette_w)	// ROM (Banked)
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( quizchq_portmap, AS_IO, 8, dynax_state )
@@ -2031,10 +2018,10 @@
 
 
 static ADDRESS_MAP_START( rongrong_map, AS_PROGRAM, 8, dynax_state )
-	AM_RANGE(0x0000, 0x5fff) AM_ROM											// ROM
-	AM_RANGE(0x6000, 0x6fff) AM_RAM											// RAM
-	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")									// RAM (Banked)
-	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1") AM_WRITE(rongrong_palette_w)		// ROM (Banked)
+	AM_RANGE(0x0000, 0x5fff) AM_ROM												// ROM
+	AM_RANGE(0x6000, 0x6fff) AM_RAM												// RAM
+	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")								// RAM (Banked)
+	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1") AM_WRITE(rongrong_palette_w)	// ROM (Banked)
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( rongrong_portmap, AS_IO, 8, dynax_state )
@@ -2089,7 +2076,6 @@
 
 WRITE8_MEMBER(dynax_state::mmpanic_soundlatch_w)
 {
-
 	soundlatch_byte_w(space, 0, data);
 	device_set_input_line(m_soundcpu, INPUT_LINE_NMI, PULSE_LINE);
 }
@@ -2125,7 +2111,6 @@
 
 WRITE8_MEMBER(dynax_state::mmpanic_lockout_w)
 {
-
 	if (m_dsw_sel == 0x0c)
 	{
 		coin_counter_w(machine(), 0, (~data) & 0x01);
@@ -2139,11 +2124,11 @@
 /* Main CPU */
 
 static ADDRESS_MAP_START( mmpanic_map, AS_PROGRAM, 8, dynax_state )
-	AM_RANGE(0x0051, 0x0051) AM_READ(magic_r)								// ?
-	AM_RANGE(0x0000, 0x5fff) AM_ROM											// ROM
-	AM_RANGE(0x6000, 0x6fff) AM_RAM											// RAM
-	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")									// RAM (Banked)
-	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1") AM_WRITE(rongrong_palette_w)		// ROM (Banked)
+	AM_RANGE(0x0051, 0x0051) AM_READ(magic_r)									// ?
+	AM_RANGE(0x0000, 0x5fff) AM_ROM												// ROM
+	AM_RANGE(0x6000, 0x6fff) AM_RAM												// RAM
+	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")								// RAM (Banked)
+	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1") AM_WRITE(rongrong_palette_w)	// ROM (Banked)
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( mmpanic_portmap, AS_IO, 8, dynax_state )
@@ -2193,9 +2178,9 @@
 /* Sound CPU */
 
 static ADDRESS_MAP_START( mmpanic_sound_map, AS_PROGRAM, 8, dynax_state )
-	AM_RANGE(0x0000, 0x5fff) AM_ROM	// ROM
-	AM_RANGE(0x6000, 0x66ff) AM_RAM	// RAM
-	AM_RANGE(0x8000, 0xffff) AM_ROM	// ROM
+	AM_RANGE(0x0000, 0x5fff) AM_ROM		// ROM
+	AM_RANGE(0x6000, 0x66ff) AM_RAM		// RAM
+	AM_RANGE(0x8000, 0xffff) AM_ROM		// ROM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( mmpanic_sound_portmap, AS_IO, 8, dynax_state )
@@ -2241,7 +2226,6 @@
 
 WRITE8_MEMBER(dynax_state::funkyfig_rombank_w)
 {
-
 	m_dsw_sel = data;
 
 	membank("bank1")->set_entry(data & 0x0f);
@@ -2251,7 +2235,6 @@
 
 READ8_MEMBER(dynax_state::funkyfig_dsw_r)
 {
-
 	if (!BIT(m_dsw_sel, 0))  return ioport("DSW1")->read();
 	if (!BIT(m_dsw_sel, 1))  return ioport("DSW2")->read();
 	if (!BIT(m_dsw_sel, 2))  return ioport("DSW3")->read();
@@ -2261,7 +2244,6 @@
 
 READ8_MEMBER(dynax_state::funkyfig_coin_r)
 {
-
 	switch (m_input_sel)
 	{
 		case 0x22:	return ioport("IN2")->read();
@@ -2273,7 +2255,6 @@
 
 READ8_MEMBER(dynax_state::funkyfig_key_r)
 {
-
 	switch (m_input_sel)
 	{
 		case 0x20:	return ioport("IN0")->read();
@@ -2285,7 +2266,6 @@
 
 WRITE8_MEMBER(dynax_state::funkyfig_lockout_w)
 {
-
 	switch (m_input_sel)
 	{
 		case 0x2c:
@@ -2357,10 +2337,10 @@
 }
 
 static ADDRESS_MAP_START( hanakanz_map, AS_PROGRAM, 8, dynax_state )
-	AM_RANGE(0x0000, 0x5fff) AM_ROM								// ROM
-	AM_RANGE(0x6000, 0x6fff) AM_RAM								// RAM
-	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")						// RAM (Banked)
-	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")						// ROM (Banked)
+	AM_RANGE(0x0000, 0x5fff) AM_ROM					// ROM
+	AM_RANGE(0x6000, 0x6fff) AM_RAM					// RAM
+	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")	// RAM (Banked)
+	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")	// ROM (Banked)
 ADDRESS_MAP_END
 
 
@@ -2376,7 +2356,6 @@
 
 READ8_MEMBER(dynax_state::hanakanz_keyb_r)
 {
-
 	UINT8 val = 0xff;
 
 	if      (!BIT(m_keyb, 0))   val = ioport(offset ? "KEY5" : "KEY0")->read();
@@ -2391,7 +2370,6 @@
 
 READ8_MEMBER(dynax_state::hanakanz_dsw_r)
 {
-
 	if (!BIT(m_dsw_sel, 0))   return ioport("DSW1")->read();
 	if (!BIT(m_dsw_sel, 1))   return ioport("DSW2")->read();
 	if (!BIT(m_dsw_sel, 2))   return ioport("DSW3")->read();
@@ -2437,10 +2415,11 @@
 {
 	// bit 0 = coin counter
 	// bit 1 = out counter
-	// bit 2 = 1 if bet on
+	// bit 2 = hopper (if bet on)
 	// bit 3 = 1 if bet off
 
 	coin_counter_w(machine(), 0, data & 1);
+	coin_counter_w(machine(), 1, data & 2);
 
 	if (data & 0xf0)
 		logerror("%04x: warning, coin counter = %02x\n", cpu_get_pc(&space.device()), data);
@@ -2452,7 +2431,6 @@
 
 WRITE8_MEMBER(dynax_state::hanakanz_palette_w)
 {
-
 	if (m_ddenlovr_blit_latch & 0x80)
 	{
 		m_palette_index = data | ((m_ddenlovr_blit_latch & 1) << 8);
@@ -2689,12 +2667,12 @@
 ***************************************************************************/
 
 static ADDRESS_MAP_START( mjmyster_map, AS_PROGRAM, 8, dynax_state )
-	AM_RANGE(0x0000, 0x5fff) AM_ROM				// ROM
-	AM_RANGE(0x6000, 0x6fff) AM_RAM				// RAM
-	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")		// RAM (Banked)
-	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")		// ROM/RAM (Banked)
+	AM_RANGE(0x0000, 0x5fff) AM_ROM							// ROM
+	AM_RANGE(0x6000, 0x6fff) AM_RAM							// RAM
+	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")			// RAM (Banked)
+	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")			// ROM/RAM (Banked)
 	AM_RANGE(0xf000, 0xf1ff) AM_WRITE(rongrong_palette_w)	// RAM enabled by bit 4 of rombank
-	AM_RANGE(0xf200, 0xffff) AM_WRITENOP		// ""
+	AM_RANGE(0xf200, 0xffff) AM_WRITENOP					// ""
 ADDRESS_MAP_END
 
 WRITE8_MEMBER(dynax_state::mjmyster_rambank_w)
@@ -2713,7 +2691,6 @@
 
 READ8_MEMBER(dynax_state::mjmyster_coins_r)
 {
-
 	switch (m_input_sel)
 	{
 		case 0x00:	return ioport("SYSTEM")->read();
@@ -2745,7 +2722,6 @@
 
 READ8_MEMBER(dynax_state::mjmyster_dsw_r)
 {
-
 	if (!BIT(m_dsw_sel, 0))   return ioport("DSW4")->read();
 	if (!BIT(m_dsw_sel, 1))   return ioport("DSW3")->read();
 	if (!BIT(m_dsw_sel, 2))   return ioport("DSW2")->read();
@@ -2757,7 +2733,6 @@
 
 WRITE8_MEMBER(dynax_state::mjmyster_coincounter_w)
 {
-
 	switch (m_input_sel)
 	{
 		case 0x0c:
@@ -2828,11 +2803,11 @@
 }
 
 static ADDRESS_MAP_START( hginga_map, AS_PROGRAM, 8, dynax_state )
-	AM_RANGE(0x0000, 0x5fff) AM_ROM								// ROM
-	AM_RANGE(0x6000, 0x6fff) AM_RAM								// RAM
-	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")						// RAM (Banked)
+	AM_RANGE(0x0000, 0x5fff) AM_ROM							// ROM
+	AM_RANGE(0x6000, 0x6fff) AM_RAM							// RAM
+	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")			// RAM (Banked)
 	AM_RANGE(0xf601, 0xf601) AM_READ(hginga_protection_r)
-	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")						// ROM/RAM (Banked)
+	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")			// ROM/RAM (Banked)
 	AM_RANGE(0xf000, 0xf1ff) AM_WRITE(rongrong_palette_w)	// RAM enabled by bit 4 of rombank
 	AM_RANGE(0xf700, 0xf706) AM_WRITENOP
 ADDRESS_MAP_END
@@ -2859,7 +2834,6 @@
 
 READ8_MEMBER(dynax_state::hginga_coins_r)
 {
-
 	switch (m_input_sel)
 	{
 		case 0x20:	return ioport("SYSTEM")->read();
@@ -2878,7 +2852,6 @@
 
 WRITE8_MEMBER(dynax_state::hginga_coins_w)
 {
-
 	switch (m_input_sel)
 	{
 		case 0x2d:
@@ -2886,10 +2859,11 @@
 		case 0x2c:
 			// bit 0 = coin counter
 			// bit 1 = out counter
-			// bit 2 = 1 if bet on
+			// bit 2 = hopper (if bet on)
 			// bit 3 = 1 if bet on
 			// bit 7?
 			coin_counter_w(machine(), 0, data & 1);
+			coin_counter_w(machine(), 1, data & 2);
 #ifdef MAME_DEBUG
 //          popmessage("COINS %02x", data);
 #endif
@@ -3004,7 +2978,6 @@
 
 READ8_MEMBER(dynax_state::hgokou_input_r)
 {
-
 	switch (m_dsw_sel)
 	{
 		case 0x20:	return ioport("SYSTEM")->read();
@@ -3018,7 +2991,6 @@
 
 WRITE8_MEMBER(dynax_state::hgokou_input_w)
 {
-
 	switch (m_dsw_sel)
 	{
 		case 0x2c:
@@ -3027,6 +2999,7 @@
 			// bit 2 = hopper
 			// bit 7 = ?
 			coin_counter_w(machine(), 0, data & 1);
+			coin_counter_w(machine(), 1, data & 2);
 			m_hopper = data & 0x04;
 #ifdef MAME_DEBUG
 //          popmessage("COINS %02x",data);
@@ -3054,11 +3027,11 @@
 }
 
 static ADDRESS_MAP_START( hgokou_map, AS_PROGRAM, 8, dynax_state )
-	AM_RANGE(0x0000, 0x5fff) AM_ROM								// ROM
-	AM_RANGE(0x6000, 0x6fff) AM_RAM								// RAM
-	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")						// RAM (Banked)
+	AM_RANGE(0x0000, 0x5fff) AM_ROM							// ROM
+	AM_RANGE(0x6000, 0x6fff) AM_RAM							// RAM
+	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")			// RAM (Banked)
 	AM_RANGE(0xe601, 0xe601) AM_READ(hgokou_protection_r)
-	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")						// ROM (Banked)
+	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")			// ROM (Banked)
 	AM_RANGE(0xe000, 0xe1ff) AM_WRITE(rongrong_palette_w)
 	AM_RANGE(0xe700, 0xe706) AM_WRITENOP
 ADDRESS_MAP_END
@@ -3097,7 +3070,6 @@
 
 READ8_MEMBER(dynax_state::hgokbang_input_r)
 {
-
 	UINT8 ret;
 	switch (m_dsw_sel)
 	{
@@ -3154,7 +3126,6 @@
 
 WRITE8_MEMBER(dynax_state::hparadis_select_w)
 {
-
 	m_dsw_sel = data;
 	m_keyb = 0;
 
@@ -3183,7 +3154,6 @@
 
 READ8_MEMBER(dynax_state::hparadis_dsw_r)
 {
-
 	if (!BIT(m_dsw_sel, 0))	return ioport("DSW1")->read();
 	if (!BIT(m_dsw_sel, 1))	return ioport("DSW2")->read();
 	if (!BIT(m_dsw_sel, 2))	return 0xff;
@@ -3194,7 +3164,6 @@
 
 WRITE8_MEMBER(dynax_state::hparadis_coin_w)
 {
-
 	switch (m_input_sel)
 	{
 		case 0x0c:	coin_counter_w(machine(), 0, data & 1);	break;
@@ -3205,10 +3174,10 @@
 }
 
 static ADDRESS_MAP_START( hparadis_map, AS_PROGRAM, 8, dynax_state )
-	AM_RANGE(0x0000, 0x5fff) AM_ROM								// ROM
-	AM_RANGE(0x6000, 0x6fff) AM_RAM								// RAM
-	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")						// RAM (Banked)
-	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")						// ROM (Banked)
+	AM_RANGE(0x0000, 0x5fff) AM_ROM							// ROM
+	AM_RANGE(0x6000, 0x6fff) AM_RAM							// RAM
+	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")			// RAM (Banked)
+	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")			// ROM (Banked)
 	AM_RANGE(0xc000, 0xc1ff) AM_WRITE(rongrong_palette_w)
 ADDRESS_MAP_END
 
@@ -3243,7 +3212,6 @@
 
 READ8_MEMBER(dynax_state::mjmywrld_coins_r)
 {
-
 	switch (m_input_sel)
 	{
 		case 0x80:	return ioport("SYSTEM")->read();
@@ -3384,6 +3352,7 @@
 WRITE8_MEMBER(dynax_state::mjflove_rombank_w)
 {
 	membank("bank1")->set_entry(data & 0xf);
+	// bit 4 enables palette ram
 }
 
 static WRITE8_DEVICE_HANDLER( mjflove_okibank_w )
@@ -3413,7 +3382,6 @@
 
 CUSTOM_INPUT_MEMBER(dynax_state::mjflove_blitter_r)
 {
-
 	// bit 7 = 1 -> blitter busy
 	// bit 6 = 0 -> VBLANK?
 	// bit 5 = 0 -> RTC?
@@ -3513,10 +3481,10 @@
 ***************************************************************************/
 
 static ADDRESS_MAP_START( sryudens_map, AS_PROGRAM, 8, dynax_state )
-	AM_RANGE(0x0000, 0x5fff) AM_ROM								// ROM
-	AM_RANGE(0x6000, 0x6fff) AM_RAM								// RAM
-	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")						// RAM (Banked)
-	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")						// ROM (Banked)
+	AM_RANGE(0x0000, 0x5fff) AM_ROM							// ROM
+	AM_RANGE(0x6000, 0x6fff) AM_RAM							// RAM
+	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")			// RAM (Banked)
+	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")			// ROM (Banked)
 	AM_RANGE(0xe000, 0xe1ff) AM_WRITE(rongrong_palette_w)
 ADDRESS_MAP_END
 
@@ -3540,11 +3508,13 @@
 {
 	// bit 0 = coin counter
 	// bit 1 = out counter
-	// bit 2
-	// bit 4
+	// bit 2 = hopper (if bet on)
+	// bit 4 = ? on except during boot or test mode
 	// bit 7 = ? mostly on
 
 	coin_counter_w(machine(), 0, data & 1);
+	coin_counter_w(machine(), 1, data & 2);
+	m_hopper = data & 0x04;
 
 	if (data & 0x68)
 		logerror("%04x: warning, coin counter = %02x\n", cpu_get_pc(&space.device()), data);
@@ -3593,6 +3563,152 @@
 
 
 /***************************************************************************
+                            Mahjong Janshin Plus
+***************************************************************************/
+
+WRITE8_MEMBER(dynax_state::janshinp_coincounter_w)
+{
+	// bit 0 = coin counter
+	// bit 1 = out counter
+	// bit 3 = ? on except during boot or test mode
+	// bit 7 = ? mostly on
+
+	coin_counter_w(machine(), 0, data & 1);
+	coin_counter_w(machine(), 1, data & 2);
+
+	if (data & ~0x8b)
+		logerror("%04x: warning, coin counter = %02x\n", cpu_get_pc(&space.device()), data);
+
+#ifdef MAME_DEBUG
+//  popmessage("COIN = %02x", data);
+#endif
+}
+
+static ADDRESS_MAP_START( janshinp_map, AS_PROGRAM, 8, dynax_state )
+	AM_RANGE(0x0000, 0x5fff) AM_ROM							// ROM
+	AM_RANGE(0x6000, 0x6fff) AM_RAM							// RAM
+	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")			// RAM (Banked)
+	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")			// ROM (Banked)
+	AM_RANGE(0xe000, 0xe1ff) AM_WRITE(rongrong_palette_w)
+ADDRESS_MAP_END
+
+static ADDRESS_MAP_START( janshinp_portmap, AS_IO, 8, dynax_state )
+	ADDRESS_MAP_GLOBAL_MASK(0xff)
+	AM_RANGE(0x00, 0x00) AM_READ_PORT("DSW1")
+	AM_RANGE(0x01, 0x01) AM_READ_PORT("DSW2")
+	AM_RANGE(0x02, 0x02) AM_READ_PORT("DSW4")
+	AM_RANGE(0x03, 0x03) AM_READ_PORT("DSW3")
+	AM_RANGE(0x04, 0x04) AM_READ_PORT("DSWTOP")
+	AM_RANGE(0x08, 0x08) AM_WRITE(janshinp_coincounter_w)
+	AM_RANGE(0x09, 0x09) AM_WRITE(hanakanz_keyb_w)
+	AM_RANGE(0x0a, 0x0a) AM_READ_PORT("SYSTEM")
+	AM_RANGE(0x0b, 0x0c) AM_READ(sryudens_keyb_r)
+	AM_RANGE(0x1c, 0x1c) AM_READNOP AM_WRITE(sryudens_rambank_w)	// ? ack on RTC int
+	AM_RANGE(0x1e, 0x1e) AM_WRITE(mjflove_rombank_w)
+	AM_RANGE(0x20, 0x23) AM_WRITE(ddenlovr_palette_base_w)
+	AM_RANGE(0x24, 0x27) AM_WRITE(ddenlovr_palette_mask_w)
+	AM_RANGE(0x28, 0x2b) AM_WRITE(ddenlovr_transparency_pen_w)
+	AM_RANGE(0x2c, 0x2f) AM_WRITE(ddenlovr_transparency_mask_w)
+	AM_RANGE(0x34, 0x34) AM_WRITE(ddenlovr_bgcolor_w)
+	AM_RANGE(0x35, 0x35) AM_WRITE(ddenlovr_priority_w)
+	AM_RANGE(0x36, 0x36) AM_WRITE(ddenlovr_layer_enable_w)
+	AM_RANGE(0x38, 0x38) AM_READNOP			// ? ack or watchdog
+	AM_RANGE(0x40, 0x41) AM_WRITE(mjflove_blitter_w)
+	AM_RANGE(0x43, 0x43) AM_READ(rongrong_gfxrom_r)
+	AM_RANGE(0x50, 0x5f) AM_DEVREADWRITE("rtc", msm6242_device, read, write)
+	AM_RANGE(0x60, 0x60) AM_READ(hanakanz_rand_r)
+	AM_RANGE(0x70, 0x70) AM_DEVWRITE_LEGACY("oki", quizchq_oki_bank_w)
+	AM_RANGE(0x80, 0x80) AM_RAM
+	AM_RANGE(0x90, 0x90) AM_DEVREADWRITE("oki", okim6295_device, read, write)
+	AM_RANGE(0x92, 0x93) AM_DEVWRITE_LEGACY("ymsnd", ym2413_w)
+	AM_RANGE(0x94, 0x95) AM_DEVWRITE_LEGACY("aysnd", ay8910_address_data_w)
+ADDRESS_MAP_END
+
+
+/***************************************************************************
+                             Return Of Sel Jan II
+***************************************************************************/
+
+READ8_MEMBER(dynax_state::seljan2_busy_r)
+{
+	return 0x00;	// bit 7 = blitter busy
+}
+
+WRITE8_MEMBER(dynax_state::seljan2_rombank_w)
+{
+	membank("bank1")->set_entry(data & 0x0f);	// disable palette?
+}
+
+WRITE8_MEMBER(dynax_state::seljan2_palette_enab_w)
+{
+	membank("bank1")->set_entry((membank("bank1")->entry() & 0x0f) | ((data & 0x01) << 4));
+	if (data & ~0x01)
+		logerror("%s: warning, unknown palette_enab bits written = %02x\n", machine().describe_context(), data);
+}
+
+WRITE8_MEMBER(dynax_state::seljan2_palette_w)
+{
+	if ((membank("bank1")->entry() & 0x10) && offset >= 0xb000-0x8000 && offset <= 0xb1ff-0x8000)
+	{
+		rongrong_palette_w(space, offset - (0xb000-0x8000), data);
+		memregion("maincpu")->base()[0x90000 + offset] = data;
+	}
+	else
+		logerror("%s: warning, palette_w with palette disabled, %04x <- %02x\n", machine().describe_context(), offset, data);
+}
+
+static READ8_DEVICE_HANDLER( seljan2_dsw_r )
+{
+	dynax_state *state = device->machine().driver_data<dynax_state>();
+
+	if (!BIT(state->m_dsw_sel, 0))   return state->ioport("DSW1")->read();
+	if (!BIT(state->m_dsw_sel, 1))   return state->ioport("DSW2")->read();
+	if (!BIT(state->m_dsw_sel, 2))   return state->ioport("DSW3")->read();
+	if (!BIT(state->m_dsw_sel, 3))   return state->ioport("DSW4")->read();
+	if (!BIT(state->m_dsw_sel, 4))   return state->ioport("DSWTOP")->read();
+
+	logerror("%s: warning, unknown bits read, ddenlovr_select = %02x\n", device->machine().describe_context(), state->m_dsw_sel);
+	return 0xff;
+}
+
+static ADDRESS_MAP_START( seljan2_map, AS_PROGRAM, 8, dynax_state )
+	AM_RANGE(0x0000, 0x5fff) AM_ROM							// ROM
+	AM_RANGE(0x6000, 0x6fff) AM_RAM							// RAM
+	AM_RANGE(0x7000, 0x7fff) AM_RAMBANK("bank2")			// RAM (Banked)
+	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")			// ROM (Banked)
+	AM_RANGE(0x8000, 0xffff) AM_WRITE(seljan2_palette_w)
+ADDRESS_MAP_END
+
+static ADDRESS_MAP_START( seljan2_portmap, AS_IO, 8, dynax_state )
+	ADDRESS_MAP_GLOBAL_MASK(0xff)
+	AM_RANGE(0x00, 0x0f) AM_DEVREADWRITE("rtc", msm6242_device, read, write)
+	AM_RANGE(0x1c, 0x1c) AM_READ(seljan2_busy_r) AM_WRITE(hanakanz_keyb_w)
+	AM_RANGE(0x1e, 0x1e) AM_WRITE(sryudens_coincounter_w)
+	AM_RANGE(0x20, 0x23) AM_WRITE(ddenlovr_palette_base_w)
+	AM_RANGE(0x24, 0x27) AM_WRITE(ddenlovr_palette_mask_w)
+	AM_RANGE(0x28, 0x2b) AM_WRITE(ddenlovr_transparency_pen_w)
+	AM_RANGE(0x2c, 0x2f) AM_WRITE(ddenlovr_transparency_mask_w)
+	AM_RANGE(0x34, 0x34) AM_WRITE(ddenlovr_bgcolor_w)
+	AM_RANGE(0x35, 0x35) AM_WRITE(ddenlovr_priority_w)
+	AM_RANGE(0x36, 0x36) AM_WRITE(ddenlovr_layer_enable_w)
+	AM_RANGE(0x38, 0x38) AM_READNOP			// ? ack or watchdog
+	AM_RANGE(0x40, 0x41) AM_WRITE(mjflove_blitter_w)
+	AM_RANGE(0x43, 0x43) AM_READ(rongrong_gfxrom_r)
+	AM_RANGE(0x50, 0x51) AM_DEVWRITE_LEGACY("ymsnd", ym2413_w)
+	AM_RANGE(0x54, 0x54) AM_DEVREADWRITE("oki", okim6295_device, read, write)
+	AM_RANGE(0x58, 0x58) AM_DEVWRITE_LEGACY("aysnd", ay8910_address_w)
+	AM_RANGE(0x5c, 0x5c) AM_DEVREADWRITE_LEGACY("aysnd", ay8910_r, ay8910_data_w)	// dsw
+	AM_RANGE(0x60, 0x60) AM_READNOP AM_WRITE(sryudens_rambank_w)	// ? ack on RTC int
+	AM_RANGE(0x70, 0x70) AM_WRITE(seljan2_rombank_w)
+	AM_RANGE(0x80, 0x80) AM_READ_PORT("SYSTEM")	AM_WRITE(seljan2_palette_enab_w)	// writes: 1 = palette RAM at b000, 0 = ROM
+	AM_RANGE(0x84, 0x84) AM_READ(daimyojn_keyb1_r)
+	AM_RANGE(0x88, 0x88) AM_READ(daimyojn_keyb2_r)
+	AM_RANGE(0x90, 0x90) AM_DEVWRITE_LEGACY("oki", quizchq_oki_bank_w)
+	AM_RANGE(0xa0, 0xa0) AM_READ(hanakanz_rand_r)
+ADDRESS_MAP_END
+
+
+/***************************************************************************
                             Mahjong Daimyojin
 ***************************************************************************/
 
@@ -3600,13 +3716,15 @@
 {
 	UINT8 val = 0x3f;
 
-	if      (!BIT(m_keyb, 0))  val = ioport("KEY0")->read();
-	else if (!BIT(m_keyb, 1))  val = ioport("KEY1")->read();
-	else if (!BIT(m_keyb, 2))  val = ioport("KEY2")->read();
-	else if (!BIT(m_keyb, 3))  val = ioport("KEY3")->read();
-	else if (!BIT(m_keyb, 4))  val = ioport("KEY4")->read();
+	UINT8 hopper_bit = ((m_hopper && !(machine().primary_screen->frame_number() % 10)) ? 0 : (1 << 6));
 
-	val |= ioport("BET")->read();
+	if      (!BIT(m_keyb, 0))  val = ioport("KEY0")->read() | hopper_bit;
+	else if (!BIT(m_keyb, 1))  val = ioport("KEY1")->read() | hopper_bit;
+	else if (!BIT(m_keyb, 2))  val = ioport("KEY2")->read() | hopper_bit;
+	else if (!BIT(m_keyb, 3))  val = ioport("KEY3")->read() | hopper_bit;
+	else if (!BIT(m_keyb, 4))  val = ioport("KEY4")->read() | hopper_bit;
+
+//  val |= ioport("BET")->read();
 	return val;
 }
 
@@ -3650,7 +3768,6 @@
 
 READ8_MEMBER(dynax_state::momotaro_protection_r)
 {
-
 	switch (m_prot_val)
 	{
 		case 0xd4: return 0xd9;
@@ -3676,7 +3793,6 @@
 
 WRITE8_MEMBER(dynax_state::daimyojn_blitter_data_palette_w)
 {
-
 	if (m_daimyojn_palette_sel & 0x01)
 		hanakanz_palette_w(space, offset, data);
 	else
@@ -7181,7 +7297,6 @@
 	PORT_DIPSETTING(    0x00, "1 2 3 5 8 15 30 50" )
 	PORT_DIPSETTING(    0x20, "2 3 6 8 12 15 30 50" )
 	PORT_DIPSETTING(    0x10, "1 2 3 5 10 25 50 100" )
-//  PORT_DIPSETTING(    0xxx, "1 2 3 4 5 6 8 10" )
 	PORT_DIPNAME( 0xc0, 0xc0, "Max Bet" )
 	PORT_DIPSETTING(    0xc0, "1" )
 	PORT_DIPSETTING(    0x80, "5" )
@@ -7189,11 +7304,6 @@
 	PORT_DIPSETTING(    0x00, "20" )
 
 	PORT_START("DSW2")
-//  PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
-//  PORT_DIPSETTING(    0x02, DEF_STR( 2C_1C ) )
-//  PORT_DIPSETTING(    0x01, DEF_STR( 2C_2C ) )
-//  PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
-//  PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) )
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
@@ -7289,9 +7399,9 @@
 	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Controls ) )	// only if BET is 1
+	PORT_DIPSETTING(    0x80, "Keyboard" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Joystick ) )
 
 	PORT_START("BET")
 	PORT_DIPNAME( 0x40, 0x40, "Bets?" )
@@ -7305,12 +7415,12 @@
 
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( daimyojn )
+static INPUT_PORTS_START( seljan2 )
 
 	PORT_START("SYSTEM")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SERVICE3 )	// medal out
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN  )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE  ) PORT_NAME(DEF_STR( Test )) PORT_CODE(KEYCODE_F1) PORT_TOGGLE
+	PORT_SERVICE( 0x04, IP_ACTIVE_LOW )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_SERVICE1 )	// analyzer
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE2 )	// data clear
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN2 )		// note
@@ -7415,13 +7525,12 @@
 	PORT_DIPSETTING(    0x0d, "90" )
 	PORT_DIPSETTING(    0x0e, "93" )
 	PORT_DIPSETTING(    0x0f, "96" )
-	PORT_DIPNAME( 0x30, 0x30, "Odds Rate" )
+	PORT_DIPNAME( 0x30, 0x00, "Odds Rate" )
 	PORT_DIPSETTING(    0x30, "1 2 4 8 12 16 24 32" )
-//  PORT_DIPSETTING(    0x00, "1 2 3 5 8 15 30 50" )
-//  PORT_DIPSETTING(    0x10, "1 2 3 5 10 25 50 100" )
-//  PORT_DIPSETTING(    0x20, "2 3 6 8 12 15 30 50" )
-//  PORT_DIPSETTING(    0x30, "2 3 6 8 12 15 30 50" )
-	PORT_DIPNAME( 0xc0, 0xc0, "Max Bet" )
+	PORT_DIPSETTING(    0x00, "1 2 3 5 8 15 30 50" )
+	PORT_DIPSETTING(    0x20, "2 3 6 8 12 15 30 50" )
+	PORT_DIPSETTING(    0x10, "1 2 3 5 10 25 50 100" )
+	PORT_DIPNAME( 0xc0, 0x40, "Max Bet" )
 	PORT_DIPSETTING(    0xc0, "1" )
 	PORT_DIPSETTING(    0x80, "5" )
 	PORT_DIPSETTING(    0x40, "10" )
@@ -7433,23 +7542,22 @@
 	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x38, 0x38, "Multiplier" )
-	PORT_DIPSETTING(    0x38, "1" )
-	PORT_DIPSETTING(    0x30, "2" )
-	PORT_DIPSETTING(    0x28, "3" )
-	PORT_DIPSETTING(    0x20, "4" )
-	PORT_DIPSETTING(    0x18, "5" )
-	PORT_DIPSETTING(    0x10, "6" )
-	PORT_DIPSETTING(    0x08, "7" )
-	PORT_DIPSETTING(    0x00, "8" )
-	PORT_DIPNAME( 0xc0, 0xc0, "Payout" )
-	PORT_DIPSETTING(    0xc0, "300" )
-	PORT_DIPSETTING(    0x80, "500" )
-	PORT_DIPSETTING(    0x40, "700" )
+	PORT_DIPNAME( 0x0c, 0x0c, "Min Rate To Play" )
+	PORT_DIPSETTING(    0x0c, "1" )
+	PORT_DIPSETTING(    0x08, "2" )
+	PORT_DIPSETTING(    0x04, "3" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x30, 0x00, "Payout" )
+	PORT_DIPSETTING(    0x30, "300" )
+	PORT_DIPSETTING(    0x20, "500" )
+	PORT_DIPSETTING(    0x10, "700" )
 	PORT_DIPSETTING(    0x00, "1000" )
+	PORT_DIPNAME( 0x40, 0x00, "W-Bet" )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, "Last Chance" )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
 	PORT_START("DSW3")
 	PORT_DIPNAME( 0x07, 0x07, "YAKUMAN Bonus" )
@@ -7461,62 +7569,63 @@
 	PORT_DIPSETTING(    0x02, "1000" )
 //  PORT_DIPSETTING(    0x01, "1000" )
 //  PORT_DIPSETTING(    0x00, "1000" )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x08, 0x00, "YAKUMAN Times" )
+	PORT_DIPSETTING(    0x00, "1" )
+	PORT_DIPSETTING(    0x08, "2" )
+	PORT_DIPNAME( 0x10, 0x10, "Auto Tsumo" )
 	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x20, 0x00, "DonDen Key" )
+	PORT_DIPSETTING(    0x20, "Start" )
+	PORT_DIPSETTING(    0x00, "Flip Flop" )
+	PORT_DIPNAME( 0x40, 0x40, "Digital Clock" )
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Game Style" )
+	PORT_DIPSETTING(    0x80, "Credit" )
+	PORT_DIPSETTING(    0x00, "Credit Time" )
 
 	PORT_START("DSW4")
-	PORT_SERVICE( 0x01, IP_ACTIVE_LOW )
-	PORT_DIPNAME( 0x02, 0x02, "DonDen Key" )
-	PORT_DIPSETTING(    0x02, "Start" )
-	PORT_DIPSETTING(    0x00, "Flip Flop" )
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Demo_Sounds ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x00, "In Game Music" )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )	// used
 	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )	// used
 	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )	// used
 	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )	// 3
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )	// used
 	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )	// used
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	// used
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
-	PORT_START("DSW5")
-	PORT_DIPNAME( 0x01, 0x01, "Credits Per Note" )
+	PORT_START("DSWTOP")
+	PORT_DIPNAME( 0x01, 0x00, "Credits Per Note" )
 	PORT_DIPSETTING(    0x01, "5" )
 	PORT_DIPSETTING(    0x00, "10" )
 	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Flip_Screen ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x0c, 0x04, "Computer Strength" )
+	PORT_DIPSETTING(    0x00, "Weak" )
+	PORT_DIPSETTING(    0x04, DEF_STR( Normal ))
+	PORT_DIPSETTING(    0x0c, "Strong" )
+	PORT_DIPSETTING(    0x08, "Very Strong" )
+	PORT_DIPNAME( 0x10, 0x10, "Timer Speed?" )
+	PORT_DIPSETTING(    0x10, "Normal?" )
+	PORT_DIPSETTING(    0x00, "Variable Rate?" )
 	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
@@ -7539,17 +7648,716 @@
 
 INPUT_PORTS_END
 
+static INPUT_PORTS_START( janshinp )
 
-/***************************************************************************
-
+	PORT_START("SYSTEM")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SERVICE3 )	// medal out
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN  )
+	PORT_SERVICE(0x04, IP_ACTIVE_LOW)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_SERVICE1 )	// analyzer
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE2 )	// data clear
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN2 )		// note
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN3 )		// service coin (test mode)
 
-                                Machine Drivers
+	PORT_START("KEY0")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_A ) PORT_PLAYER(2)	// A
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_E ) PORT_PLAYER(2)	// E
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_I ) PORT_PLAYER(2)	// I
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_M ) PORT_PLAYER(2)	// M
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_KAN ) PORT_PLAYER(2)	// Kan
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START2 )	// Start 2
 
+	PORT_START("KEY1")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_B ) PORT_PLAYER(2)	// B
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_F ) PORT_PLAYER(2)	// F
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_J ) PORT_PLAYER(2)	// J
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_N ) PORT_PLAYER(2)	// N
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_REACH ) PORT_PLAYER(2)	// Reach
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_BET ) PORT_PLAYER(2)	// BET
 
-***************************************************************************/
+	PORT_START("KEY2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_C ) PORT_PLAYER(2)	// C
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_G ) PORT_PLAYER(2)	// G
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_K ) PORT_PLAYER(2)	// K
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_CHI ) PORT_PLAYER(2)	// Chi
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_RON ) PORT_PLAYER(2)	// Ron
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
 
-static MACHINE_START( ddenlovr )
-{
+	PORT_START("KEY3")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_D ) PORT_PLAYER(2)	// D
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_H ) PORT_PLAYER(2)	// H
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_L ) PORT_PLAYER(2)	// L
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_PON ) PORT_PLAYER(2)	// Pon
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+
+	PORT_START("KEY4")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_LAST_CHANCE ) PORT_PLAYER(2)	// "l"
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_SCORE ) PORT_PLAYER(2)	// "t"
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_DOUBLE_UP ) PORT_PLAYER(2)	// "w"
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_FLIP_FLOP ) PORT_PLAYER(2)	// Flip Flop
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_BIG	 ) PORT_PLAYER(2)	// "b"
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_SMALL ) PORT_PLAYER(2)	// "s"
+
+	PORT_START("KEY5")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_A )	// A
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_E )	// E
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_I )	// I
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_M )	// M
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_KAN )	// Kan
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )	// Start 1
+
+	PORT_START("KEY6")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_B )	// B
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_F )	// F
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_J )	// J
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_N )	// N
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_REACH )	// Reach
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_BET )	// BET
+
+	PORT_START("KEY7")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_C )	// C
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_G )	// G
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_K )	// K
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_CHI )	// Chi
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_RON )	// Ron
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+
+	PORT_START("KEY8")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_D )	// D
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_H )	// H
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_L )	// L
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_PON )	// Pon
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+
+	PORT_START("KEY9")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_LAST_CHANCE )	// "l"
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_SCORE )	// "t"
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_DOUBLE_UP )	// "w"
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_FLIP_FLOP )	// Flip Flop
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_BIG )	// "b"
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_SMALL )	// "s"
+
+	PORT_START("DSW1")
+	PORT_DIPNAME( 0x0f, 0x07, "Pay Out Rate (%)" )
+	PORT_DIPSETTING(    0x00, "50" )
+	PORT_DIPSETTING(    0x01, "53" )
+	PORT_DIPSETTING(    0x02, "56" )
+	PORT_DIPSETTING(    0x03, "59" )
+	PORT_DIPSETTING(    0x04, "62" )
+	PORT_DIPSETTING(    0x05, "65" )
+	PORT_DIPSETTING(    0x06, "68" )
+	PORT_DIPSETTING(    0x07, "71" )
+	PORT_DIPSETTING(    0x08, "75" )
+	PORT_DIPSETTING(    0x09, "78" )
+	PORT_DIPSETTING(    0x0a, "81" )
+	PORT_DIPSETTING(    0x0b, "84" )
+	PORT_DIPSETTING(    0x0c, "87" )
+	PORT_DIPSETTING(    0x0d, "90" )
+	PORT_DIPSETTING(    0x0e, "93" )
+	PORT_DIPSETTING(    0x0f, "96" )
+	PORT_DIPNAME( 0x30, 0x00, "Odds Rate" )
+	PORT_DIPSETTING(    0x30, "1 2 4 8 12 16 24 32" )
+	PORT_DIPSETTING(    0x00, "1 2 3 5 8 15 30 50" )
+	PORT_DIPSETTING(    0x20, "2 3 6 8 12 15 30 50" )
+	PORT_DIPSETTING(    0x10, "1 2 3 5 10 25 50 100" )
+	PORT_DIPNAME( 0xc0, 0x40, "Max Bet" )
+	PORT_DIPSETTING(    0xc0, "1" )
+	PORT_DIPSETTING(    0x80, "5" )
+	PORT_DIPSETTING(    0x40, "10" )
+	PORT_DIPSETTING(    0x00, "20" )
+
+	PORT_START("DSW2")
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_5C ) )
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )
+	PORT_DIPNAME( 0x0c, 0x0c, "Min Rate To Play" )
+	PORT_DIPSETTING(    0x0c, "1" )
+	PORT_DIPSETTING(    0x08, "2" )
+	PORT_DIPSETTING(    0x04, "3" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x30, 0x00, "Payout" )
+	PORT_DIPSETTING(    0x30, "300" )
+	PORT_DIPSETTING(    0x20, "500" )
+	PORT_DIPSETTING(    0x10, "700" )
+	PORT_DIPSETTING(    0x00, "1000" )
+	PORT_DIPNAME( 0x40, 0x00, "W-Bet" )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, "Last Chance" )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW3")
+	PORT_DIPNAME( 0x07, 0x07, "YAKUMAN Bonus" )
+	PORT_DIPSETTING(    0x07, "Cut" )
+	PORT_DIPSETTING(    0x06, "1 T" )
+	PORT_DIPSETTING(    0x05, "300" )
+	PORT_DIPSETTING(    0x04, "500" )
+	PORT_DIPSETTING(    0x03, "700" )
+	PORT_DIPSETTING(    0x02, "1000" )
+//  PORT_DIPSETTING(    0x01, "1000" )
+//  PORT_DIPSETTING(    0x00, "1000" )
+	PORT_DIPNAME( 0x08, 0x00, "YAKUMAN Times" )
+	PORT_DIPSETTING(    0x00, "1" )
+	PORT_DIPSETTING(    0x08, "2" )
+	PORT_DIPNAME( 0x30, 0x00, "Fever Chance" )
+	PORT_DIPSETTING(    0x30, "0" )
+	PORT_DIPSETTING(    0x20, "None?" )
+	PORT_DIPSETTING(    0x10, "Many?" )
+	PORT_DIPSETTING(    0x00, "Only One?" )
+	PORT_DIPNAME( 0x40, 0x40, "Auto Tsumo" )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "DonDen Key" )
+	PORT_DIPSETTING(    0x80, "Start" )
+	PORT_DIPSETTING(    0x00, "Flip Flop" )
+
+	PORT_START("DSW4")
+	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Demo_Sounds ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x00, "In Game Music" )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x00, "Girls In Demo Mode" )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x00, "Select Girl" )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSWTOP")
+	PORT_DIPNAME( 0x01, 0x00, "Credits Per Note" )
+	PORT_DIPSETTING(    0x01, "5" )
+	PORT_DIPSETTING(    0x00, "10" )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Flip_Screen ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x0c, 0x04, "Computer Strength" )
+	PORT_DIPSETTING(    0x00, "Weak" )
+	PORT_DIPSETTING(    0x04, DEF_STR( Normal ))
+	PORT_DIPSETTING(    0x0c, "Strong" )
+	PORT_DIPSETTING(    0x08, "Very Strong" )
+	PORT_DIPNAME( 0x10, 0x00, "Action Game" )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, "Debug After Bet" )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Adjust Clock" )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("BET")
+	PORT_DIPNAME( 0x40, 0x40, "Bets?" )
+	PORT_DIPSETTING(    0x40, "0" )
+	PORT_DIPSETTING(    0x00, "1" )
+
+	PORT_START("HOPPER")
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+INPUT_PORTS_END
+
+static INPUT_PORTS_START( dtoyoken )
+
+	PORT_START("SYSTEM")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SERVICE3 )	// medal out
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN  )
+	PORT_SERVICE(0x04, IP_ACTIVE_LOW)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_SERVICE1 )	// analyzer
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE2 )	// data clear
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN2 )		// note
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN3 )		// service coin (test mode)
+
+	PORT_START("KEY0")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_A ) PORT_PLAYER(2)	// A
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_E ) PORT_PLAYER(2)	// E
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_I ) PORT_PLAYER(2)	// I
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_M ) PORT_PLAYER(2)	// M
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_KAN ) PORT_PLAYER(2)	// Kan
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START2 )	// Start 2
+
+	PORT_START("KEY1")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_B ) PORT_PLAYER(2)	// B
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_F ) PORT_PLAYER(2)	// F
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_J ) PORT_PLAYER(2)	// J
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_N ) PORT_PLAYER(2)	// N
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_REACH ) PORT_PLAYER(2)	// Reach
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_BET ) PORT_PLAYER(2)	// BET
+
+	PORT_START("KEY2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_C ) PORT_PLAYER(2)	// C
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_G ) PORT_PLAYER(2)	// G
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_K ) PORT_PLAYER(2)	// K
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_CHI ) PORT_PLAYER(2)	// Chi
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_RON ) PORT_PLAYER(2)	// Ron
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+
+	PORT_START("KEY3")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_D ) PORT_PLAYER(2)	// D
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_H ) PORT_PLAYER(2)	// H
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_L ) PORT_PLAYER(2)	// L
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_PON ) PORT_PLAYER(2)	// Pon
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+
+	PORT_START("KEY4")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_LAST_CHANCE ) PORT_PLAYER(2)	// "l"
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_SCORE ) PORT_PLAYER(2)	// "t"
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_DOUBLE_UP ) PORT_PLAYER(2)	// "w"
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_FLIP_FLOP ) PORT_PLAYER(2)	// Flip Flop
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_BIG	 ) PORT_PLAYER(2)	// "b"
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_SMALL ) PORT_PLAYER(2)	// "s"
+
+	PORT_START("KEY5")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_A )	// A
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_E )	// E
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_I )	// I
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_M )	// M
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_KAN )	// Kan
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )	// Start 1
+
+	PORT_START("KEY6")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_B )	// B
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_F )	// F
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_J )	// J
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_N )	// N
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_REACH )	// Reach
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_BET )	// BET
+
+	PORT_START("KEY7")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_C )	// C
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_G )	// G
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_K )	// K
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_CHI )	// Chi
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_RON )	// Ron
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+
+	PORT_START("KEY8")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_D )	// D
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_H )	// H
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_L )	// L
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_PON )	// Pon
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+
+	PORT_START("KEY9")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_LAST_CHANCE )	// "l"
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_SCORE )	// "t"
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_DOUBLE_UP )	// "w"
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_FLIP_FLOP )	// Flip Flop
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_BIG )	// "b"
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_SMALL )	// "s"
+
+	PORT_START("DSW1")
+	PORT_DIPNAME( 0x0f, 0x07, "Pay Out Rate (%)" )
+	PORT_DIPSETTING(    0x00, "50" )
+	PORT_DIPSETTING(    0x01, "53" )
+	PORT_DIPSETTING(    0x02, "56" )
+	PORT_DIPSETTING(    0x03, "59" )
+	PORT_DIPSETTING(    0x04, "62" )
+	PORT_DIPSETTING(    0x05, "65" )
+	PORT_DIPSETTING(    0x06, "68" )
+	PORT_DIPSETTING(    0x07, "71" )
+	PORT_DIPSETTING(    0x08, "75" )
+	PORT_DIPSETTING(    0x09, "78" )
+	PORT_DIPSETTING(    0x0a, "81" )
+	PORT_DIPSETTING(    0x0b, "84" )
+	PORT_DIPSETTING(    0x0c, "87" )
+	PORT_DIPSETTING(    0x0d, "90" )
+	PORT_DIPSETTING(    0x0e, "93" )
+	PORT_DIPSETTING(    0x0f, "96" )
+	PORT_DIPNAME( 0x30, 0x00, "Odds Rate" )
+	PORT_DIPSETTING(    0x30, "1 2 4 8 12 16 24 32" )
+	PORT_DIPSETTING(    0x00, "1 2 3 5 8 15 30 50" )
+	PORT_DIPSETTING(    0x20, "2 3 6 8 12 15 30 50" )
+	PORT_DIPSETTING(    0x10, "1 2 3 5 10 25 50 100" )
+	PORT_DIPNAME( 0xc0, 0x40, "Max Bet" )
+	PORT_DIPSETTING(    0xc0, "1" )
+	PORT_DIPSETTING(    0x80, "5" )
+	PORT_DIPSETTING(    0x40, "10" )
+	PORT_DIPSETTING(    0x00, "20" )
+
+	PORT_START("DSW2")
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_5C ) )
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )
+	PORT_DIPNAME( 0x0c, 0x0c, "Min Rate To Play" )
+	PORT_DIPSETTING(    0x0c, "1" )
+	PORT_DIPSETTING(    0x08, "2" )
+	PORT_DIPSETTING(    0x04, "3" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x30, 0x00, "Payout" )
+	PORT_DIPSETTING(    0x30, "300" )
+	PORT_DIPSETTING(    0x20, "500" )
+	PORT_DIPSETTING(    0x10, "700" )
+	PORT_DIPSETTING(    0x00, "1000" )
+	PORT_DIPNAME( 0x40, 0x00, "W-Bet" )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, "Last Chance" )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW3")
+	PORT_DIPNAME( 0x07, 0x07, "YAKUMAN Bonus" )
+	PORT_DIPSETTING(    0x07, "Cut" )
+	PORT_DIPSETTING(    0x06, "1 T" )
+	PORT_DIPSETTING(    0x05, "300" )
+	PORT_DIPSETTING(    0x04, "500" )
+	PORT_DIPSETTING(    0x03, "700" )
+	PORT_DIPSETTING(    0x02, "1000" )
+//  PORT_DIPSETTING(    0x01, "1000" )
+//  PORT_DIPSETTING(    0x00, "1000" )
+	PORT_DIPNAME( 0x08, 0x00, "YAKUMAN Times" )
+	PORT_DIPSETTING(    0x00, "1" )
+	PORT_DIPSETTING(    0x08, "2" )
+	PORT_DIPNAME( 0x10, 0x10, "Auto Tsumo" )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x00, "DonDen Key" )
+	PORT_DIPSETTING(    0x20, "Start" )
+	PORT_DIPSETTING(    0x00, "Flip Flop" )
+	PORT_DIPNAME( 0x40, 0x40, "Digital Clock" )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW4")
+	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Demo_Sounds ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x00, "In Game Music" )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )	// used
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )	// used
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, "Undress Girl" )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )	// 3
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )	// used
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )	// used
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	// used
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSWTOP")
+	PORT_DIPNAME( 0x01, 0x00, "Credits Per Note" )
+	PORT_DIPSETTING(    0x01, "5" )
+	PORT_DIPSETTING(    0x00, "10" )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Flip_Screen ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x0c, 0x04, "Computer Strength" )
+	PORT_DIPSETTING(    0x00, "Weak" )
+	PORT_DIPSETTING(    0x04, DEF_STR( Normal ))
+	PORT_DIPSETTING(    0x0c, "Strong" )
+	PORT_DIPSETTING(    0x08, "Very Strong" )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("BET")
+	PORT_DIPNAME( 0x40, 0x40, "Bets?" )
+	PORT_DIPSETTING(    0x40, "0" )
+	PORT_DIPSETTING(    0x00, "1" )
+
+	PORT_START("HOPPER")
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+INPUT_PORTS_END
+
+static INPUT_PORTS_START( daimyojn )
+
+	PORT_START("SYSTEM")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SERVICE3 )	// medal out
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN  )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE  ) PORT_NAME(DEF_STR( Test )) PORT_CODE(KEYCODE_F1) PORT_TOGGLE
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_SERVICE1 )	// analyzer
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE2 )	// data clear
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN2 )		// note
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(5)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN3 )		// note2
+
+	PORT_START("KEY0")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_A ) PORT_PLAYER(2)	// A
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_E ) PORT_PLAYER(2)	// E
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_I ) PORT_PLAYER(2)	// I
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_M ) PORT_PLAYER(2)	// M
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_KAN ) PORT_PLAYER(2)	// Kan
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START2 )	// Start 2
+
+	PORT_START("KEY1")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_B ) PORT_PLAYER(2)	// B
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_F ) PORT_PLAYER(2)	// F
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_J ) PORT_PLAYER(2)	// J
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_N ) PORT_PLAYER(2)	// N
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_REACH ) PORT_PLAYER(2)	// Reach
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_BET ) PORT_PLAYER(2)	// BET
+
+	PORT_START("KEY2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_C ) PORT_PLAYER(2)	// C
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_G ) PORT_PLAYER(2)	// G
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_K ) PORT_PLAYER(2)	// K
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_CHI ) PORT_PLAYER(2)	// Chi
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_RON ) PORT_PLAYER(2)	// Ron
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+
+	PORT_START("KEY3")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_D ) PORT_PLAYER(2)	// D
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_H ) PORT_PLAYER(2)	// H
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_L ) PORT_PLAYER(2)	// L
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_PON ) PORT_PLAYER(2)	// Pon
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+
+	PORT_START("KEY4")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_LAST_CHANCE ) PORT_PLAYER(2)	// "l"
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_SCORE ) PORT_PLAYER(2)	// "t"
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_DOUBLE_UP ) PORT_PLAYER(2)	// "w"
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_FLIP_FLOP ) PORT_PLAYER(2)	// Flip Flop
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_BIG	 ) PORT_PLAYER(2)	// "b"
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_SMALL ) PORT_PLAYER(2)	// "s"
+
+	PORT_START("KEY5")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_A )	// A
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_E )	// E
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_I )	// I
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_M )	// M
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_KAN )	// Kan
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )	// Start 1
+
+	PORT_START("KEY6")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_B )	// B
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_F )	// F
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_J )	// J
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_N )	// N
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_REACH )	// Reach
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_BET )	// BET
+
+	PORT_START("KEY7")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_C )	// C
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_G )	// G
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_K )	// K
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_CHI )	// Chi
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_RON )	// Ron
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+
+	PORT_START("KEY8")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_D )	// D
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_H )	// H
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_L )	// L
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_PON )	// Pon
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	// nothing
+
+	PORT_START("KEY9")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_LAST_CHANCE )	// "l"
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_SCORE       )	// "t"
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_DOUBLE_UP   )	// "w"
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_FLIP_FLOP   )	// Flip Flop
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_BIG         )	// "b"
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_SMALL       )	// "s"
+
+	PORT_START("DSW1")
+	PORT_DIPNAME( 0x0f, 0x07, "Pay Out Rate (%)" )
+	PORT_DIPSETTING(    0x00, "50" )
+	PORT_DIPSETTING(    0x01, "53" )
+	PORT_DIPSETTING(    0x02, "56" )
+	PORT_DIPSETTING(    0x03, "59" )
+	PORT_DIPSETTING(    0x04, "62" )
+	PORT_DIPSETTING(    0x05, "65" )
+	PORT_DIPSETTING(    0x06, "68" )
+	PORT_DIPSETTING(    0x07, "71" )
+	PORT_DIPSETTING(    0x08, "75" )
+	PORT_DIPSETTING(    0x09, "78" )
+	PORT_DIPSETTING(    0x0a, "81" )
+	PORT_DIPSETTING(    0x0b, "84" )
+	PORT_DIPSETTING(    0x0c, "87" )
+	PORT_DIPSETTING(    0x0d, "90" )
+	PORT_DIPSETTING(    0x0e, "93" )
+	PORT_DIPSETTING(    0x0f, "96" )
+	PORT_DIPNAME( 0x30, 0x30, "Odds Rate" )
+	PORT_DIPSETTING(    0x30, "1 2 4 8 12 16 24 32" )
+//  PORT_DIPSETTING(    0x00, "1 2 3 5 8 15 30 50" )
+//  PORT_DIPSETTING(    0x10, "1 2 3 5 10 25 50 100" )
+//  PORT_DIPSETTING(    0x20, "2 3 6 8 12 15 30 50" )
+//  PORT_DIPSETTING(    0x30, "2 3 6 8 12 15 30 50" )
+	PORT_DIPNAME( 0xc0, 0xc0, "Max Bet" )
+	PORT_DIPSETTING(    0xc0, "1" )
+	PORT_DIPSETTING(    0x80, "5" )
+	PORT_DIPSETTING(    0x40, "10" )
+	PORT_DIPSETTING(    0x00, "20" )
+
+	PORT_START("DSW2")
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_5C ) )
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x38, 0x38, "Multiplier" )
+	PORT_DIPSETTING(    0x38, "1" )
+	PORT_DIPSETTING(    0x30, "2" )
+	PORT_DIPSETTING(    0x28, "3" )
+	PORT_DIPSETTING(    0x20, "4" )
+	PORT_DIPSETTING(    0x18, "5" )
+	PORT_DIPSETTING(    0x10, "6" )
+	PORT_DIPSETTING(    0x08, "7" )
+	PORT_DIPSETTING(    0x00, "8" )
+	PORT_DIPNAME( 0xc0, 0xc0, "Payout" )
+	PORT_DIPSETTING(    0xc0, "300" )
+	PORT_DIPSETTING(    0x80, "500" )
+	PORT_DIPSETTING(    0x40, "700" )
+	PORT_DIPSETTING(    0x00, "1000" )
+
+	PORT_START("DSW3")
+	PORT_DIPNAME( 0x07, 0x07, "YAKUMAN Bonus" )
+	PORT_DIPSETTING(    0x07, "Cut" )
+	PORT_DIPSETTING(    0x06, "1 T" )
+	PORT_DIPSETTING(    0x05, "300" )
+	PORT_DIPSETTING(    0x04, "500" )
+	PORT_DIPSETTING(    0x03, "700" )
+	PORT_DIPSETTING(    0x02, "1000" )
+//  PORT_DIPSETTING(    0x01, "1000" )
+//  PORT_DIPSETTING(    0x00, "1000" )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW4")
+	PORT_SERVICE( 0x01, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x02, 0x02, "DonDen Key" )
+	PORT_DIPSETTING(    0x02, "Start" )
+	PORT_DIPSETTING(    0x00, "Flip Flop" )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW5")
+	PORT_DIPNAME( 0x01, 0x01, "Credits Per Note" )
+	PORT_DIPSETTING(    0x01, "5" )
+	PORT_DIPSETTING(    0x00, "10" )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Flip_Screen ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("BET")
+	PORT_DIPNAME( 0x40, 0x40, "Bets?" )
+	PORT_DIPSETTING(    0x40, "0" )
+	PORT_DIPSETTING(    0x00, "1" )
+
+	PORT_START("HOPPER")
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+INPUT_PORTS_END
+
+
+/***************************************************************************
+
+
+                                Machine Drivers
+
+
+***************************************************************************/
+
+static MACHINE_START( ddenlovr )
+{
 	dynax_state *state = machine.driver_data<dynax_state>();
 
 	state->m_maincpu = machine.device("maincpu");
@@ -7755,10 +8563,9 @@
 {
 	AY8910_LEGACY_OUTPUT,
 	AY8910_DEFAULT_LOADS,
-	DEVCB_HANDLER(quiz365_input_r),
-	DEVCB_NULL,
-	DEVCB_NULL,
-	DEVCB_HANDLER(ddenlovr_select_w)
+	// A                            B
+	DEVCB_HANDLER(quiz365_input_r),	DEVCB_NULL,							// R
+	DEVCB_NULL,						DEVCB_HANDLER(ddenlovr_select_w)	// W
 };
 
 static MACHINE_CONFIG_DERIVED( quiz365, ddenlovr )
@@ -8156,10 +8963,9 @@
 {
 	AY8910_LEGACY_OUTPUT,
 	AY8910_DEFAULT_LOADS,
-	DEVCB_NULL,
-	DEVCB_NULL,
-	DEVCB_NULL,
-	DEVCB_HANDLER(ddenlovr_select_w)
+	// A            B
+	DEVCB_NULL,		DEVCB_NULL,							// R
+	DEVCB_NULL,		DEVCB_HANDLER(ddenlovr_select_w)	// W
 };
 
 static WRITE_LINE_DEVICE_HANDLER(mjmyster_rtc_irq)
@@ -8229,7 +9035,7 @@
 {
 	AY8910_LEGACY_OUTPUT,
 	AY8910_DEFAULT_LOADS,
-	// A            B
+	// A                            B
 	DEVCB_HANDLER(hginga_dsw_r),	DEVCB_NULL,								// R
 	DEVCB_NULL,						DEVCB_HANDLER(ddenlovr_select_w)		// W
 };
@@ -8490,6 +9296,127 @@
 MACHINE_CONFIG_END
 
 /***************************************************************************
+                            Mahjong Janshin Plus
+***************************************************************************/
+
+// PCB: NM7001004
+static MACHINE_CONFIG_START( janshinp, dynax_state )
+
+	/* basic machine hardware */
+	MCFG_CPU_ADD("maincpu",Z80, XTAL_16MHz / 2)
+	MCFG_CPU_PROGRAM_MAP(janshinp_map)
+	MCFG_CPU_IO_MAP(janshinp_portmap)
+	MCFG_CPU_VBLANK_INT("screen",mjchuuka_irq)
+
+	MCFG_MACHINE_START(hanakanz)
+	MCFG_MACHINE_RESET(ddenlovr)
+
+	/* video hardware */
+	MCFG_SCREEN_ADD("screen", RASTER)
+	MCFG_SCREEN_REFRESH_RATE(60.8532)	// VSync 60.8532Hz, HSync 15.2790kHz ?
+	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
+	MCFG_SCREEN_SIZE(336, 256+22)
+	MCFG_SCREEN_VISIBLE_AREA(0, 336-1, 0+5, 256-12-1)
+	MCFG_SCREEN_UPDATE_STATIC(ddenlovr)
+
+	MCFG_PALETTE_LENGTH(0x100)
+
+	MCFG_VIDEO_ATTRIBUTES(VIDEO_ALWAYS_UPDATE)
+	MCFG_VIDEO_START(ddenlovr)
+
+	/* sound hardware */
+	MCFG_SPEAKER_STANDARD_MONO("mono")
+
+	MCFG_SOUND_ADD("ymsnd", YM2413, XTAL_28_63636MHz / 8)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
+
+	MCFG_SOUND_ADD("aysnd", AY8910, XTAL_28_63636MHz / 8)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.30)
+
+	MCFG_OKIM6295_ADD("oki", XTAL_28_63636MHz / 28, OKIM6295_PIN7_HIGH)	// ?
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
+
+	/* devices */
+	MCFG_MSM6242_ADD("rtc", mjchuuka_rtc_intf)
+MACHINE_CONFIG_END
+
+// Same PCB as janshinp
+static MACHINE_CONFIG_DERIVED( dtoyoken, janshinp )
+
+	MCFG_VIDEO_START(mjflove)	// blitter commands in the roms are shuffled around
+MACHINE_CONFIG_END
+
+
+/***************************************************************************
+                             Return Of Sel Jan II
+***************************************************************************/
+
+static const ay8910_interface seljan2_ay8910_interface =
+{
+	AY8910_LEGACY_OUTPUT,
+	AY8910_DEFAULT_LOADS,
+	// A                            B
+	DEVCB_HANDLER(seljan2_dsw_r),	DEVCB_NULL,								// R
+	DEVCB_NULL,						DEVCB_HANDLER(ddenlovr_select_w)		// W
+};
+
+static MACHINE_START( seljan2 )
+{
+	UINT8 *ROM = machine.root_device().memregion("maincpu")->base();
+
+	machine.root_device().membank("bank1")->configure_entries(0x00, 0x10, &ROM[0x10000], 0x8000);
+	// banks 10-1f -> palette RAM
+	for (int i = 0; i < 0x10; i++)
+		machine.root_device().membank("bank1")->configure_entries(0x10+i, 1, &ROM[0x90000], 0x8000);
+
+	machine.root_device().membank("bank2")->configure_entries(0, 0x10, &ROM[0x98000], 0x1000);
+
+	MACHINE_START_CALL(ddenlovr);
+}
+
+static MACHINE_CONFIG_START( seljan2, dynax_state )
+
+	/* basic machine hardware */
+	MCFG_CPU_ADD("maincpu",Z80, XTAL_16MHz / 2)
+	MCFG_CPU_PROGRAM_MAP(seljan2_map)
+	MCFG_CPU_IO_MAP(seljan2_portmap)
+	MCFG_CPU_VBLANK_INT("screen",mjchuuka_irq)
+
+	MCFG_MACHINE_START(seljan2)
+	MCFG_MACHINE_RESET(ddenlovr)
+
+	/* video hardware */
+	MCFG_SCREEN_ADD("screen", RASTER)
+	MCFG_SCREEN_REFRESH_RATE(60.8532)	// VSync 60.8532Hz, HSync 15.2790kHz ?
+	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
+	MCFG_SCREEN_SIZE(336, 256+22)
+	MCFG_SCREEN_VISIBLE_AREA(0, 336-1, 0+5, 256-12-1)
+	MCFG_SCREEN_UPDATE_STATIC(ddenlovr)
+
+	MCFG_PALETTE_LENGTH(0x100)
+
+	MCFG_VIDEO_ATTRIBUTES(VIDEO_ALWAYS_UPDATE)
+	MCFG_VIDEO_START(mjflove)	// blitter commands in the roms are shuffled around
+
+	/* sound hardware */
+	MCFG_SPEAKER_STANDARD_MONO("mono")
+
+	MCFG_SOUND_ADD("ymsnd", YM2413, XTAL_28_63636MHz / 8)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
+
+	MCFG_SOUND_ADD("aysnd", AY8910, XTAL_28_63636MHz / 8)
+	MCFG_SOUND_CONFIG(seljan2_ay8910_interface)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.30)
+
+	MCFG_OKIM6295_ADD("oki", XTAL_28_63636MHz / 28, OKIM6295_PIN7_HIGH)	// ?
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
+
+	/* devices */
+	MCFG_MSM6242_ADD("rtc", mjchuuka_rtc_intf)
+MACHINE_CONFIG_END
+
+
+/***************************************************************************
                             Mahjong Daimyojin
 ***************************************************************************/
 
@@ -10387,6 +11314,90 @@
 	ROM_LOAD( "t0271.2b", 0x00000, 0x80000, CRC(c850d7b2) SHA1(8bb69bdea7035c5f8274927f07a4cdf6ed9b32fc) )
 ROM_END
 
+/***************************************************************************
+
+Mahjong Janshin Plus
+
+PCB is NM7001004:
+
+TMPZ84C015-8
+OKI M6295, YM2413, YMZ284
+Gfx Chip TRA ZONG TZ-2053P
+X-tals are 16MHz and 28.63636MHz
+4 x 10-position dips
+OKI 62x42B rtc + battery
+PLCC68 FPGA with label NM700D/NM700J
+
+***************************************************************************/
+
+ROM_START( janshinp )
+	ROM_REGION( 0x90000+16*0x1000, "maincpu", 0 )	/* Z80 Code */
+	ROM_LOAD( "700j-2.5c", 0x00000, 0x80000, CRC(188bae18) SHA1(46d26398126f7962d83135c48e46f737392873c4) )
+	ROM_RELOAD(            0x10000, 0x80000 )
+
+	ROM_REGION( 0x180000, "blitter", 0 )	/* blitter data */
+	ROM_LOAD( "700j-3.13b", 0x000000, 0x80000, CRC(d7289433) SHA1(3b758e6488d58f9b2dd2c9fef9ee6789deab47ec) )
+	ROM_LOAD( "700j-4.14b", 0x080000, 0x80000, CRC(881e1f91) SHA1(91f4079c22a963251aa2af0e3fb1cb2497db3a02) )
+	ROM_LOAD( "700j-5.13d", 0x100000, 0x80000, CRC(5a6bb6a9) SHA1(a6c8856221a7776a2c9732b5a1d7cb7343a69798) )
+
+	ROM_REGION( 0x80000, "oki", ROMREGION_ERASEFF )	/* Samples */
+	ROM_LOAD( "700j-1.1c", 0x00000, 0x20000, CRC(09b7a9b2) SHA1(64d9ccbb726bb6c5b362afc92bca2e3db87fd454) )
+ROM_END
+
+/***************************************************************************
+
+Mahjong Dai Touyouken
+
+PCB is NM7001004 (see janshinp)
+
+***************************************************************************/
+
+ROM_START( dtoyoken )
+	ROM_REGION( 0x90000+16*0x1000, "maincpu", 0 )	/* Z80 Code */
+	ROM_LOAD( "700d-2.5c", 0x00000, 0x80000, CRC(f92a70ad) SHA1(42fdb7ef876bcc9fe915cbb5000d238b6816e27c) )
+	ROM_RELOAD(            0x10000, 0x80000 )
+
+	ROM_REGION( 0x200000, "blitter", 0 )	/* blitter data */
+	ROM_LOAD( "700d-3.13b", 0x000000, 0x80000, CRC(6215aed3) SHA1(894f4ee9435418efc9bb721db67b96e65547e9a6) )
+	ROM_LOAD( "700d-4.14b", 0x080000, 0x80000, CRC(06d2ee0b) SHA1(0dd81cbc39fb40e623f70ae6980b14e74ecacfdc) )
+	ROM_LOAD( "700d-5.13d", 0x100000, 0x80000, CRC(be4bc975) SHA1(6a8615b538343d4a1b8ad80cdf94a274741ec8cf) )
+	ROM_LOAD( "700d-6.14d", 0x180000, 0x80000, CRC(62487321) SHA1(7cf5d81d4978fb89beffe250d776397336cce4dc) )
+
+	ROM_REGION( 0x80000, "oki", 0 )	/* Samples */
+	ROM_LOAD( "700d-1.1c", 0x00000, 0x80000, CRC(70e630e6) SHA1(d6432cdd3aa03212c17325c86118e9c22aca2429) )
+ROM_END
+
+/***************************************************************************
+
+Return Of Sel Jan II
+
+PCB is NM504-2:
+
+X-tals are 16MHz and 28.322MHz
+TMPZ84C015-8
+YM2149
+3631 (probably rtc) + battery
+scratched gfx chip but looks like same as janshinp
+6143 (probably YM2413)
+PLCC68 FPGA with label FPGA-2
+4 x 10-position dips
+
+***************************************************************************/
+
+ROM_START( seljan2 )
+	ROM_REGION( 0x90000+0x8000+16*0x1000, "maincpu", 0 )	/* Z80 Code */
+	ROM_LOAD( "5572.4c", 0x00000, 0x80000, CRC(fb99be5a) SHA1(d33a503916e41cda5459c991299a9ee599333794) )
+	ROM_RELOAD(          0x10000, 0x80000 )
+
+	ROM_REGION( 0x500000, "blitter", 0 )	/* blitter data */
+	ROM_LOAD( "5573.11c", 0x000000, 0x200000, CRC(917ef80e) SHA1(b9c3520426fde8e508d2fcec4179a8f628f330ba) )
+	/* 200000-3fffff empty */
+	ROM_LOAD( "5574.13c", 0x400000, 0x100000, CRC(260fb823) SHA1(0b63172e95d9d3fa99d34097f728427076281174) )
+
+	ROM_REGION( 0x80000, "oki", 0 )	/* Samples */
+	ROM_LOAD( "5571.1c", 0x000000, 0x80000, CRC(5a8cd45c) SHA1(25ca573b8ba226fb3f2de48c57b5ced6884eaa63) )	// = 50201.1c (sryudens)
+ROM_END
+
 static DRIVER_INIT( momotaro )
 {
 	dynax_state *state = machine.driver_data<dynax_state>();
@@ -10421,11 +11432,14 @@
 GAME( 1996, ddenlovr,  ddenlovj, ddenlovr,  ddenlovr, 0,        ROT0, "Dynax",                                       "Don Den Lover Vol. 1 (Hong Kong)",                                GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1996, hanakanz,  0,        hanakanz,  hanakanz, 0,        ROT0, "Dynax",                                       "Hana Kanzashi (Japan)",                                           GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1996, akamaru,   0,        akamaru,   akamaru,  0,        ROT0, "Dynax (Nakanihon license)",                   "Panel & Variety Akamaru Q Jousyou Dont-R",                        GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
+GAME( 1996, janshinp,  0,        janshinp,  janshinp, 0,        ROT0, "Dynax / Sigma",                               "Mahjong Janshin Plus (Japan)",                                    GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
+GAME( 1996, dtoyoken,  0,        dtoyoken,  dtoyoken, 0,        ROT0, "Dynax / Sigma",                               "Mahjong Dai Touyouken (Japan)",                                   GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1996, sryudens,  0,        sryudens,  sryudens, 0,        ROT0, "Dynax / Face",                                "Mahjong Seiryu Densetsu (Japan, NM502)",                          GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
+GAME( 1996, seljan2,   0,        seljan2,   seljan2,  0,        ROT0, "Dynax / Face",                                "Return Of Sel Jan II (Japan, NM557)",                             GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
 GAME( 1996, mjflove,   0,        mjflove,   mjflove,  0,        ROT0, "Nakanihon",                                   "Mahjong Fantasic Love (Japan)",                                   GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1997, hkagerou,  0,        hkagerou,  hkagerou, 0,        ROT0, "Nakanihon / Dynax",                           "Hana Kagerou [BET] (Japan)",                                      GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1998, mjchuuka,  0,        mjchuuka,  mjchuuka, 0,        ROT0, "Dynax",                                       "Mahjong Chuukanejyo (China)",                                     GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1998, mjreach1,  0,        mjreach1,  mjreach1, 0,        ROT0, "Nihon System",                                "Mahjong Reach Ippatsu (Japan)",                                   GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1999, jongtei,   0,        jongtei,   jongtei,  0,        ROT0, "Dynax",                                       "Mahjong Jong-Tei (Japan, ver. NM532-01)",                         GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 2002, daimyojn,  0,        daimyojn,  daimyojn, 0,        ROT0, "Dynax / Techno-Top / Techno-Planning",        "Mahjong Daimyojin (Japan, T017-PB-00)",                           GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
-GAME( 2004, momotaro,  0,        daimyojn,  daimyojn, momotaro, ROT0, "Techno-Top", 						         "Mahjong Momotarou (Japan)",                                       GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE | GAME_NOT_WORKING | GAME_IMPERFECT_GRAPHICS )
+GAME( 2004, momotaro,  0,        daimyojn,  daimyojn, momotaro, ROT0, "Techno-Top",                                  "Mahjong Momotarou (Japan)",                                       GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE | GAME_NOT_WORKING | GAME_IMPERFECT_GRAPHICS )
diff -Nru src-old/mame/drivers/dec0.c src/mame/drivers/dec0.c
--- src-old/mame/drivers/dec0.c	2012-06-11 10:00:48.000000000 +0200
+++ src/mame/drivers/dec0.c	2012-07-02 09:06:11.000000000 +0200
@@ -581,32 +581,6 @@
 
 
 
-static ADDRESS_MAP_START( secretab_map, AS_PROGRAM, 16, dec0_state )
-	AM_RANGE(0x000000, 0x05ffff) AM_ROM
-	AM_RANGE(0x240000, 0x240007) AM_DEVWRITE_LEGACY("tilegen2", deco_bac06_pf_control_0_w)
-	AM_RANGE(0x240010, 0x240017) AM_DEVWRITE_LEGACY("tilegen2", deco_bac06_pf_control_1_w)
-	AM_RANGE(0x246000, 0x247fff) AM_DEVREADWRITE_LEGACY("tilegen2", deco_bac06_pf_data_r, deco_bac06_pf_data_w)
-//  AM_RANGE(0x240000, 0x24007f) AM_DEVREADWRITE_LEGACY("tilegen2", deco_bac06_pf_colscroll_r, deco_bac06_pf_colscroll_w)
-//  AM_RANGE(0x240400, 0x2407ff) AM_DEVREADWRITE_LEGACY("tilegen2", deco_bac06_pf_rowscroll_r, deco_bac06_pf_rowscroll_w)
-
-//  AM_RANGE(0x200000, 0x300007) AM_DEVWRITE_LEGACY("tilegen1", deco_bac06_pf_control_0_w)
-//  AM_RANGE(0x300010, 0x300017) AM_DEVWRITE_LEGACY("tilegen1", deco_bac06_pf_control_1_w)
-	AM_RANGE(0x24e000, 0x24ffff) AM_DEVREADWRITE_LEGACY("tilegen1", deco_bac06_pf_data_r, deco_bac06_pf_data_w)
-//  AM_RANGE(0x340000, 0x34007f) AM_DEVREADWRITE_LEGACY("tilegen1", deco_bac06_pf_colscroll_r, deco_bac06_pf_colscroll_w)
-//  AM_RANGE(0x340400, 0x3407ff) AM_DEVREADWRITE_LEGACY("tilegen1", deco_bac06_pf_rowscroll_r, deco_bac06_pf_rowscroll_w)
-
-	AM_RANGE(0x314008, 0x31400f) AM_READ(slyspy_controls_r)
-//  AM_RANGE(0x314000, 0x314003) AM_WRITE(slyspy_control_w)
-
-	AM_RANGE(0x300000, 0x300007) AM_DEVWRITE_LEGACY("tilegen3", deco_bac06_pf_control_0_w)
-	AM_RANGE(0x300010, 0x300017) AM_DEVWRITE_LEGACY("tilegen3", deco_bac06_pf_control_1_w)
-	AM_RANGE(0x300800, 0x30087f) AM_DEVREADWRITE_LEGACY("tilegen3", deco_bac06_pf_colscroll_r, deco_bac06_pf_colscroll_w)
-	AM_RANGE(0x300c00, 0x300fff) AM_DEVREADWRITE_LEGACY("tilegen3", deco_bac06_pf_rowscroll_r, deco_bac06_pf_rowscroll_w)
-	AM_RANGE(0x301000, 0x3017ff) AM_DEVREADWRITE_LEGACY("tilegen3", deco_bac06_pf_data_r, deco_bac06_pf_data_w)
-	AM_RANGE(0x301800, 0x307fff) AM_RAM AM_SHARE("ram") /* Sly spy main ram */
-	AM_RANGE(0x310000, 0x3107ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_word_w) AM_SHARE("paletteram")
-	AM_RANGE(0xb08000, 0xb087ff) AM_RAM AM_SHARE("spriteram") /* Sprites */
-ADDRESS_MAP_END
 
 /* swizzle the palette writes around so we can use the same gfx plane ordering as the originals */
 READ16_MEMBER( dec0_automat_state::automat_palette_r )
@@ -656,15 +630,44 @@
 	AM_RANGE(0x400008, 0x400009) AM_WRITE(dec0_priority_w)
 
 	AM_RANGE(0xff8000, 0xffbfff) AM_RAM AM_SHARE("ram")				/* Main ram */
-	AM_RANGE(0xffc000, 0xffc7ff) AM_RAM AM_SHARE("spriteram")			/* Sprites */
+	AM_RANGE(0xffc000, 0xffcfff) AM_RAM AM_SHARE("spriteram")			/* Sprites */
 ADDRESS_MAP_END
 
+static ADDRESS_MAP_START( secretab_map, AS_PROGRAM, 16, dec0_automat_state )
+	AM_RANGE(0x000000, 0x05ffff) AM_ROM
+//  AM_RANGE(0x240000, 0x240007) AM_DEVWRITE_LEGACY("tilegen2", deco_bac06_pf_control_0_w)
+//  AM_RANGE(0x240010, 0x240017) AM_DEVWRITE_LEGACY("tilegen2", deco_bac06_pf_control_1_w)
+	AM_RANGE(0x246000, 0x247fff) AM_DEVREADWRITE_LEGACY("tilegen2", deco_bac06_pf_data_r, deco_bac06_pf_data_w)
+//  AM_RANGE(0x240000, 0x24007f) AM_DEVREADWRITE_LEGACY("tilegen2", deco_bac06_pf_colscroll_r, deco_bac06_pf_colscroll_w)
+//  AM_RANGE(0x240400, 0x2407ff) AM_DEVREADWRITE_LEGACY("tilegen2", deco_bac06_pf_rowscroll_r, deco_bac06_pf_rowscroll_w)
+
+//  AM_RANGE(0x200000, 0x300007) AM_DEVWRITE_LEGACY("tilegen1", deco_bac06_pf_control_0_w)
+//  AM_RANGE(0x300010, 0x300017) AM_DEVWRITE_LEGACY("tilegen1", deco_bac06_pf_control_1_w)
+	AM_RANGE(0x24e000, 0x24ffff) AM_DEVREADWRITE_LEGACY("tilegen1", deco_bac06_pf_data_r, deco_bac06_pf_data_w)
+//  AM_RANGE(0x340000, 0x34007f) AM_DEVREADWRITE_LEGACY("tilegen1", deco_bac06_pf_colscroll_r, deco_bac06_pf_colscroll_w)
+//  AM_RANGE(0x340400, 0x3407ff) AM_DEVREADWRITE_LEGACY("tilegen1", deco_bac06_pf_rowscroll_r, deco_bac06_pf_rowscroll_w)
+
+	AM_RANGE(0x314008, 0x31400f) AM_READ(slyspy_controls_r)
+//  AM_RANGE(0x314000, 0x314003) AM_WRITE(slyspy_control_w)
+
+	AM_RANGE(0x300000, 0x300007) AM_RAM
+	AM_RANGE(0x300010, 0x300017) AM_RAM
+	AM_RANGE(0x300800, 0x30087f) AM_RAM
+	AM_RANGE(0x300c00, 0x300fff) AM_RAM
+	AM_RANGE(0x301000, 0x3017ff) AM_DEVREADWRITE_LEGACY("tilegen3", deco_bac06_pf_data_r, deco_bac06_pf_data_w)
+	AM_RANGE(0x301800, 0x307fff) AM_RAM AM_SHARE("ram") /* Sly spy main ram */
+	AM_RANGE(0x310000, 0x3107ff) AM_READWRITE(automat_palette_r, automat_palette_w) AM_SHARE("paletteram")
+	AM_RANGE(0xb08000, 0xb08fff) AM_RAM AM_SHARE("spriteram") /* Sprites */
+ADDRESS_MAP_END
+
+
 WRITE8_MEMBER(dec0_automat_state::automat_adpcm_w)
 {
 	m_automat_adpcm_byte = data;
 }
 
 static ADDRESS_MAP_START( automat_s_map, AS_PROGRAM, 8, dec0_automat_state )
+	AM_RANGE(0x0103, 0x0103) AM_WRITENOP
 	AM_RANGE(0xc000, 0xc7ff) AM_RAM
 	AM_RANGE(0xc800, 0xc801) AM_DEVWRITE_LEGACY("2203a", ym2203_w)
 	AM_RANGE(0xd800, 0xd800) AM_READ(soundlatch_byte_r)
@@ -1247,6 +1250,7 @@
 	8*8
 };
 
+
 static GFXDECODE_START( dec0 )
 	GFXDECODE_ENTRY( "gfx1", 0, charlayout,   0, 16 )	/* Characters 8x8 */
 	GFXDECODE_ENTRY( "gfx2", 0, tilelayout, 512, 16 )	/* Tiles 16x16 */
@@ -1254,13 +1258,6 @@
 	GFXDECODE_ENTRY( "gfx4", 0, tilelayout, 256, 16 )	/* Sprites 16x16 */
 GFXDECODE_END
 
-static GFXDECODE_START( automat )
-	GFXDECODE_ENTRY( "gfx1", 0, charlayout,   0, 16 )	/* Characters 8x8 */
-	GFXDECODE_ENTRY( "gfx2", 0, automat_tilelayout3, 512, 16 )	/* Tiles 16x16 */
-	GFXDECODE_ENTRY( "gfx3", 0, automat_tilelayout2, 768, 16 )	/* Tiles 16x16 */
-	GFXDECODE_ENTRY( "gfx4", 0, automat_spritelayout, 256, 16 )	/* Sprites 16x16 */
-GFXDECODE_END
-
 static GFXDECODE_START( midres )
 	GFXDECODE_ENTRY( "gfx1", 0, charlayout, 256, 16 )	/* Characters 8x8 */
 	GFXDECODE_ENTRY( "gfx2", 0, tilelayout, 512, 16 )	/* Tiles 16x16 */
@@ -1268,57 +1265,22 @@
 	GFXDECODE_ENTRY( "gfx4", 0, tilelayout,   0, 16 )	/* Sprites 16x16 */
 GFXDECODE_END
 
-/* TODO: clean up this. */
-static const gfx_layout secretab_charlayout =
-{
-	8,8,
-	RGN_FRAC(1,4),
-	4,
-	{ RGN_FRAC(0,4), RGN_FRAC(1,4), RGN_FRAC(2,4), RGN_FRAC(3,4) },
-	{ 0, 1, 2, 3, 4, 5, 6, 7 },
-	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8 },
-	8*8
-};
 
-static const gfx_layout secretab_tilelayout =
-{
-	16,16,
-	0x400, // RGN_FRAC(1,16) causes divide by zero?!
-	4,
-	{ RGN_FRAC(0,4), RGN_FRAC(1,4), RGN_FRAC(2,4), RGN_FRAC(3,4) },
-	{ 0,1,2,3,4,5,6,7, 0x4000*8+0, 0x4000*8+1, 0x4000*8+2, 0x4000*8+3, 0x4000*8+4, 0x4000*8+5, 0x4000*8+6, 0x4000*8+7 },
-	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8, 0x2000*8+0*8, 0x2000*8+1*8, 0x2000*8+2*8, 0x2000*8+3*8, 0x2000*8+4*8, 0x2000*8+5*8, 0x2000*8+6*8, 0x2000*8+7*8 },
-	8*8
-};
 
-static const gfx_layout secretab_tilelayout2 =
-{
-	16,16,
-	0x800,
-	4,
-	{ RGN_FRAC(0,4), RGN_FRAC(1,4), RGN_FRAC(2,4), RGN_FRAC(3,4) },
-	{ 0,1,2,3,4,5,6,7,0x8000*8+0, 0x8000*8+1, 0x8000*8+2, 0x8000*8+3, 0x8000*8+4, 0x8000*8+5, 0x8000*8+6, 0x8000*8+7 },
-	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8, 0x4000*8+0*8, 0x4000*8+1*8, 0x4000*8+2*8, 0x4000*8+3*8, 0x4000*8+4*8, 0x4000*8+5*8, 0x4000*8+6*8, 0x4000*8+7*8 },
-	8*8
-};
 
-static const gfx_layout secretab_tilelayout3 =
-{
-	16,16,
-	RGN_FRAC(1,4),
-	4,
-	{ RGN_FRAC(0,4), RGN_FRAC(1,4), RGN_FRAC(2,4), RGN_FRAC(3,4) },
-	{ 0,1,2,3,4,5,6,7,16*8+0, 16*8+1,16*8+2,16*8+3,16*8+4,16*8+5,16*8+6,16*8+7 },
-	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8,
-			8*8, 9*8, 10*8, 11*8, 12*8, 13*8, 14*8, 15*8 },
-	16*16
-};
+
+static GFXDECODE_START( automat )
+	GFXDECODE_ENTRY( "gfx1", 0, charlayout,   0, 16 )	/* Characters 8x8 */
+	GFXDECODE_ENTRY( "gfx2", 0, automat_tilelayout3, 512, 16 )	/* Tiles 16x16 */
+	GFXDECODE_ENTRY( "gfx3", 0, automat_tilelayout2, 768, 16 )	/* Tiles 16x16 */
+	GFXDECODE_ENTRY( "gfx4", 0, automat_spritelayout, 256, 16 )	/* Sprites 16x16 */
+GFXDECODE_END
 
 static GFXDECODE_START( secretab )
-	GFXDECODE_ENTRY( "gfx1", 0, secretab_charlayout,     0x000, 0x10 )
-	GFXDECODE_ENTRY( "gfx2", 0, secretab_tilelayout,     0x200, 0x10 )
-	GFXDECODE_ENTRY( "gfx3", 0, secretab_tilelayout,     0x300, 0x10 )
-	GFXDECODE_ENTRY( "gfx4", 0, secretab_tilelayout3,    0x100, 0x10 )
+	GFXDECODE_ENTRY( "gfx1", 0, charlayout,     0x000, 0x10 )
+	GFXDECODE_ENTRY( "gfx2", 0, automat_tilelayout2,     0x200, 0x10 )
+	GFXDECODE_ENTRY( "gfx3", 0, automat_tilelayout2,     0x300, 0x10 )
+	GFXDECODE_ENTRY( "gfx4", 0, automat_spritelayout,    0x100, 0x10 )
 GFXDECODE_END
 
 /******************************************************************************/
@@ -1423,7 +1385,7 @@
 	else
 	{
 		msm5205_data_w(device, state->m_automat_adpcm_byte >> 4);
-	//  cputag_set_input_line(device->machine(), "maincpu", INPUT_LINE_NMI, PULSE_LINE);
+		//cputag_set_input_line(device->machine(), "audiocpu", INPUT_LINE_NMI, PULSE_LINE); // gives some scratch samples but breaks other sounds too
 	}
 
 	state->m_automat_msm5205_vclk_toggle ^= 1;
@@ -1452,6 +1414,7 @@
 //  MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529) /* 57.41 Hz, 529us Vblank */)
 	MCFG_SCREEN_RAW_PARAMS(DEC0_PIXEL_CLOCK,DEC0_HTOTAL,DEC0_HBEND,DEC0_HBSTART,DEC0_VTOTAL,DEC0_VBEND,DEC0_VBSTART)
 	MCFG_SCREEN_UPDATE_STATIC(automat)
+	MCFG_VIDEO_START(dec0_nodma)
 
 	MCFG_DEVICE_ADD("tilegen1", DECO_BAC06, 0)
 	deco_bac06_device::set_gfx_region_wide(*device, 0,0,0);
@@ -1460,6 +1423,9 @@
 	MCFG_DEVICE_ADD("tilegen3", DECO_BAC06, 0)
 	deco_bac06_device::set_gfx_region_wide(*device, 0,2,0);
 
+	MCFG_DEVICE_ADD("spritegen", DECO_MXC06, 0)
+	deco_mxc06_device::set_gfx_region(*device, 3);
+
 
 	MCFG_PALETTE_LENGTH(1024)
 	MCFG_GFXDECODE(automat)
@@ -1484,6 +1450,60 @@
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
+// this seems very similar to the automat bootleg
+static MACHINE_CONFIG_START( secretab, dec0_automat_state )
+
+	/* basic machine hardware */
+	MCFG_CPU_ADD("maincpu", M68000, XTAL_20MHz/2) /* verified on pcb (20MHZ OSC) 68000P12 running at 10Mhz */
+	MCFG_CPU_PROGRAM_MAP(secretab_map)
+	MCFG_CPU_VBLANK_INT("screen", irq6_line_hold)/* VBL */
+
+	MCFG_CPU_ADD("audiocpu", Z80, 3000000)// ?
+	MCFG_CPU_PROGRAM_MAP(automat_s_map)
+
+	/* video hardware */
+	MCFG_SCREEN_ADD("screen", RASTER)
+//  MCFG_SCREEN_REFRESH_RATE(57.41)
+//  MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529) /* 57.41 Hz, 529us Vblank */)
+	MCFG_SCREEN_RAW_PARAMS(DEC0_PIXEL_CLOCK,DEC0_HTOTAL,DEC0_HBEND,DEC0_HBSTART,DEC0_VTOTAL,DEC0_VBEND,DEC0_VBSTART)
+	MCFG_SCREEN_UPDATE_STATIC(secretab)
+	MCFG_VIDEO_START(dec0_nodma)
+
+	MCFG_DEVICE_ADD("tilegen1", DECO_BAC06, 0)
+	deco_bac06_device::set_gfx_region_wide(*device, 0,0,0);
+	MCFG_DEVICE_ADD("tilegen2", DECO_BAC06, 0)
+	deco_bac06_device::set_gfx_region_wide(*device, 0,1,0);
+	MCFG_DEVICE_ADD("tilegen3", DECO_BAC06, 0)
+	deco_bac06_device::set_gfx_region_wide(*device, 0,2,0);
+
+	MCFG_DEVICE_ADD("spritegen", DECO_MXC06, 0)
+	deco_mxc06_device::set_gfx_region(*device, 3);
+
+
+	MCFG_PALETTE_LENGTH(1024)
+	MCFG_GFXDECODE(secretab)
+
+	/* sound hardware */
+	MCFG_SPEAKER_STANDARD_MONO("mono")
+
+	MCFG_SOUND_ADD("2203a", YM2203, 1500000)
+	MCFG_SOUND_ROUTE(0, "mono", 0.90)
+	MCFG_SOUND_ROUTE(1, "mono", 0.90)
+	MCFG_SOUND_ROUTE(2, "mono", 0.90)
+	MCFG_SOUND_ROUTE(3, "mono", 0.35)
+
+	MCFG_SOUND_ADD("2203b", YM2203, 1500000)
+	MCFG_SOUND_ROUTE(0, "mono", 0.90)
+	MCFG_SOUND_ROUTE(1, "mono", 0.90)
+	MCFG_SOUND_ROUTE(2, "mono", 0.90)
+	MCFG_SOUND_ROUTE(3, "mono", 0.35)
+
+	MCFG_SOUND_ADD("msm", MSM5205, 384000/2)
+	MCFG_SOUND_CONFIG(msm5205_config)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+
+MACHINE_CONFIG_END
+
 
 static MACHINE_CONFIG_DERIVED( hbarrel, dec0_base_sound )
 
@@ -1650,29 +1670,6 @@
 
 
 
-static MACHINE_CONFIG_DERIVED( secretab, dec0_base_sound_alt )
-
-	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", M68000, XTAL_20MHz/2) /* verified on pcb (20MHZ OSC) 68000P12 running at 10Mhz */
-	MCFG_CPU_PROGRAM_MAP(secretab_map)
-	MCFG_CPU_VBLANK_INT("screen", irq6_line_hold)/* VBL */
-
-	/* z80 */
-//  MCFG_CPU_ADD("audiocpu", H6280, XTAL_12MHz/2/3) /* verified on pcb (6Mhz is XIN on pin 10 of H6280, verified on pcb */
-//  MCFG_CPU_PROGRAM_MAP(slyspy_s_map)
-
-	/* video hardware */
-	MCFG_SCREEN_ADD("screen", RASTER)
-//  MCFG_SCREEN_REFRESH_RATE(57.41)
-//  MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529) /* 57.41 Hz, 529us Vblank */)
-	MCFG_SCREEN_RAW_PARAMS(DEC0_PIXEL_CLOCK,DEC0_HTOTAL,DEC0_HBEND,DEC0_HBSTART,DEC0_VTOTAL,DEC0_VBEND,DEC0_VBSTART)
-//  MCFG_SCREEN_SIZE(32*8, 32*8)
-//  MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 1*8, 31*8-1)
-	MCFG_SCREEN_UPDATE_STATIC(robocop)
-
-	MCFG_GFXDECODE(secretab)
-	MCFG_VIDEO_START(dec0_nodma)
-MACHINE_CONFIG_END
 
 static MACHINE_CONFIG_DERIVED( midres, dec0_base_sound_alt )
 
@@ -2713,37 +2710,37 @@
 
 	ROM_REGION( 0x40000, "charset", 0 )
 	ROM_LOAD( "sa_08.bin", 0x00000, 0x10000,CRC(4806b951) SHA1(a2fa5b8587132747067d7d64ccfd14129a34ef58) )
-	ROM_LOAD( "sa_10.bin", 0x10000, 0x10000,CRC(843c4679) SHA1(871f3e77aa7e628e924a40d06ddec700487e23fb) )
-	ROM_LOAD( "sa_12.bin", 0x20000, 0x10000,CRC(f9e2cd5f) SHA1(f2c3f6e763c6f80307e9daee533d316b05cd02c5) )
+	ROM_LOAD( "sa_12.bin", 0x10000, 0x10000,CRC(f9e2cd5f) SHA1(f2c3f6e763c6f80307e9daee533d316b05cd02c5) )
+	ROM_LOAD( "sa_10.bin", 0x20000, 0x10000,CRC(843c4679) SHA1(871f3e77aa7e628e924a40d06ddec700487e23fb) )
 	ROM_LOAD( "sa_14.bin", 0x30000, 0x10000,CRC(3dac9128) SHA1(f3a2068e90973c1f04f1bbaa209111e3f9669ee0) )
 
-	ROM_REGION( 0x20000, "gfx1", 0 ) /* chars */
+	ROM_REGION( 0x20000, "gfx1", ROMREGION_INVERT ) /* chars */
 	ROM_COPY( "charset", 0x00000, 0x00000, 0x8000 )
 	ROM_COPY( "charset", 0x10000, 0x08000, 0x8000 )
 	ROM_COPY( "charset", 0x20000, 0x10000, 0x8000 )
 	ROM_COPY( "charset", 0x30000, 0x18000, 0x8000 )
 
-	ROM_REGION( 0x20000, "gfx2", 0 ) /* tiles */
+	ROM_REGION( 0x20000, "gfx2", ROMREGION_INVERT ) /* tiles */
 	ROM_COPY( "charset", 0x08000, 0x00000, 0x8000 )
 	ROM_COPY( "charset", 0x18000, 0x08000, 0x8000 )
 	ROM_COPY( "charset", 0x28000, 0x10000, 0x8000 )
 	ROM_COPY( "charset", 0x38000, 0x18000, 0x8000 )
 
-	ROM_REGION( 0x40000, "gfx3", 0 ) /* tiles */
+	ROM_REGION( 0x40000, "gfx3", ROMREGION_INVERT ) /* tiles */
 	ROM_LOAD( "sa_09.bin",      0x00000, 0x10000,CRC(9e412267) SHA1(482cd6e772fa21f15db66c27acf85e8f97f7c5a5) )
 	ROM_LOAD( "sa_11.bin",      0x10000, 0x10000,CRC(e87650db) SHA1(381352428b12fd4a8cd13270009ff7602aa41a0b) )
 	ROM_LOAD( "sa_07.bin",      0x20000, 0x10000,CRC(6ad2e575) SHA1(b6b159cb36e222fe62fc10271602226f027440e4) )
 	ROM_LOAD( "sa_13.bin",      0x30000, 0x10000,CRC(e8601057) SHA1(fd73a36fb84049154248d250ffea68b1ee39a43f) )
 
-	ROM_REGION( 0x80000, "gfx4", ROMREGION_INVERT ) /* sprites */
-	ROM_LOAD( "sa_15.bin",      0x10000, 0x10000,CRC(54fcbc39) SHA1(293a6799193b01424c3eac86cf90cc023aa771db) )
-	ROM_LOAD( "sa_16.bin",      0x00000, 0x10000,CRC(ff72b838) SHA1(fdc48ecdd2225fc69472313f34973f6add8fb558) )
-	ROM_LOAD( "sa_17.bin",      0x30000, 0x10000,CRC(f61972c8) SHA1(fa9ddca3473091b4879171d8f3b302e8f2b45149) )
-	ROM_LOAD( "sa_18.bin",      0x20000, 0x10000,CRC(4f989f00) SHA1(ae7ae6e62e6a516ae3c8ebbeb5e39887c1961add) )
-	ROM_LOAD( "sa_19.bin",      0x50000, 0x10000,CRC(d29bc22e) SHA1(ce0935d09f7e94fa32247c86e14a74b73514b29e) )
-	ROM_LOAD( "sa_20.bin",      0x40000, 0x10000,CRC(447e4f0b) SHA1(97db103e505a6e11eb9bdb3622e4aa3b796a9714) )
-	ROM_LOAD( "sa_21.bin",      0x70000, 0x10000,CRC(dc6a38df) SHA1(9043df911389d3f085299f2f2202cab356473a32) )
-	ROM_LOAD( "sa_22.bin",      0x60000, 0x10000,CRC(d234cae5) SHA1(0cd07bf087a4da19a5da29785385de9eee52d0fb) )
+	ROM_REGION( 0x80000, "gfx4", 0 ) /* sprites */
+	ROM_LOAD( "sa_20.bin",      0x00000, 0x10000,CRC(447e4f0b) SHA1(97db103e505a6e11eb9bdb3622e4aa3b796a9714) )
+	ROM_LOAD( "sa_19.bin",      0x10000, 0x10000,CRC(d29bc22e) SHA1(ce0935d09f7e94fa32247c86e14a74b73514b29e) )
+	ROM_LOAD( "sa_16.bin",      0x20000, 0x10000,CRC(ff72b838) SHA1(fdc48ecdd2225fc69472313f34973f6add8fb558) )
+	ROM_LOAD( "sa_15.bin",      0x30000, 0x10000,CRC(54fcbc39) SHA1(293a6799193b01424c3eac86cf90cc023aa771db) )
+	ROM_LOAD( "sa_22.bin",      0x40000, 0x10000,CRC(d234cae5) SHA1(0cd07bf087a4da19a5da29785385de9eee52d0fb) )
+	ROM_LOAD( "sa_21.bin",      0x50000, 0x10000,CRC(dc6a38df) SHA1(9043df911389d3f085299f2f2202cab356473a32) )
+	ROM_LOAD( "sa_18.bin",      0x60000, 0x10000,CRC(4f989f00) SHA1(ae7ae6e62e6a516ae3c8ebbeb5e39887c1961add) )
+	ROM_LOAD( "sa_17.bin",      0x70000, 0x10000,CRC(f61972c8) SHA1(fa9ddca3473091b4879171d8f3b302e8f2b45149) )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* ADPCM samples */
 	ROM_LOAD( "sa_02.bin",      0x00000, 0x10000,CRC(439eb5a9) SHA1(8d6baad8a1e89279ef0a378941d3d9b49a606864) ) // both halves identical
@@ -3060,27 +3057,35 @@
 GAME( 1987, hbarrelw,   hbarrel,  hbarrel,  hbarrel,  hbarrel,  ROT270, "Data East Corporation", "Heavy Barrel (World)", 0 )
 GAME( 1988, baddudes,   0,        baddudes, baddudes, baddudes, ROT0,   "Data East USA",         "Bad Dudes vs. Dragonninja (US)", 0 )
 GAME( 1988, drgninja,   baddudes, baddudes, drgninja, baddudes, ROT0,   "Data East Corporation", "Dragonninja (Japan)", 0 )
-GAME( 1988, drgninjab,  baddudes, baddudes, drgninja, baddudes, ROT0,   "bootleg", "Dragonninja (bootleg)", 0 )
-/* A Bad Dudes bootleg with 68705 like the midres and ffantasy ones exists, but is not dumped */
 GAME( 1988, birdtry,    0,        birdtry,  birdtry,  birdtry,  ROT270, "Data East Corporation", "Birdie Try (Japan)", GAME_UNEMULATED_PROTECTION )
 GAME( 1988, robocop,    0,        robocop,  robocop,  robocop,  ROT0,   "Data East Corporation", "Robocop (World revision 4)", 0 )
 GAME( 1988, robocopw,   robocop,  robocop,  robocop,  robocop,  ROT0,   "Data East Corporation", "Robocop (World revision 3)", 0 )
 GAME( 1988, robocopj,   robocop,  robocop,  robocop,  robocop,  ROT0,   "Data East Corporation", "Robocop (Japan)", 0 )
 GAME( 1988, robocopu,   robocop,  robocop,  robocop,  robocop,  ROT0,   "Data East USA",         "Robocop (US revision 1)", 0 )
 GAME( 1988, robocopu0,  robocop,  robocop,  robocop,  robocop,  ROT0,   "Data East USA",         "Robocop (US revision 0)", 0 )
-GAME( 1988, robocopb,   robocop,  robocopb, robocop,  robocop,  ROT0,   "bootleg",               "Robocop (World bootleg)", 0)
-GAME( 1988, automat,    robocop,  automat,  robocop,  robocop,  ROT0,   "bootleg",               "Automat (bootleg of Robocop)", GAME_NOT_WORKING )
 GAME( 1989, hippodrm,   0,        hippodrm, hippodrm, hippodrm, ROT0,   "Data East USA",         "Hippodrome (US)", 0 )
 GAME( 1989, ffantasy,   hippodrm, hippodrm, ffantasy, hippodrm, ROT0,   "Data East Corporation", "Fighting Fantasy (Japan revision 2)", 0 )
 GAME( 1989, ffantasya,  hippodrm, hippodrm, ffantasy, hippodrm, ROT0,   "Data East Corporation", "Fighting Fantasy (Japan)", 0 )
-GAME( 1989, ffantasybl, hippodrm, midres,   midres,   0,        ROT0,   "bootleg",               "Fighting Fantasy (bootleg with 68705)", GAME_NOT_WORKING ) // 68705 not dumped, might be the same as midresb
 GAME( 1989, slyspy,     0,        slyspy,   slyspy,   slyspy,   ROT0,   "Data East USA",         "Sly Spy (US revision 3)", 0 )
 GAME( 1989, slyspy2,    slyspy,   slyspy,   slyspy,   slyspy,   ROT0,   "Data East USA",         "Sly Spy (US revision 2)", 0 )
 GAME( 1989, secretag,   slyspy,   slyspy,   slyspy,   slyspy,   ROT0,   "Data East Corporation", "Secret Agent (World)", 0 )
-GAME( 1989, secretab,   slyspy,   secretab, slyspy,   slyspy,   ROT0,   "bootleg",               "Secret Agent (bootleg)", GAME_NOT_WORKING )
 GAME( 1989, midres,     0,        midres,   midres,   0,        ROT0,   "Data East Corporation", "Midnight Resistance (World)", 0 )
 GAME( 1989, midresu,    midres,   midres,   midresu,  0,        ROT0,   "Data East USA",         "Midnight Resistance (US)", 0 )
 GAME( 1989, midresj,    midres,   midres,   midresu,  0,        ROT0,   "Data East Corporation", "Midnight Resistance (Japan)", 0 )
-GAME( 1989, midresb,    midres,   midresb,  midresb,  midresb,  ROT0,   "bootleg",               "Midnight Resistance (bootleg with 68705)", 0 ) // need to hook up 68705?
 GAME( 1990, bouldash,   0,        slyspy,   bouldash, slyspy,   ROT0,   "Data East Corporation (licensed from First Star)", "Boulder Dash / Boulder Dash Part 2 (World)", 0 )
 GAME( 1990, bouldashj,  bouldash, slyspy,   bouldash, slyspy,   ROT0,   "Data East Corporation (licensed from First Star)", "Boulder Dash / Boulder Dash Part 2 (Japan)", 0 )
+
+// bootlegs
+
+// more or less just an unprotected versions of the game, everything intact
+GAME( 1988, robocopb,   robocop,  robocopb, robocop,  robocop,  ROT0,   "bootleg", "Robocop (World bootleg)", 0)
+GAME( 1988, drgninjab,  baddudes, baddudes, drgninja, baddudes, ROT0,   "bootleg", "Dragonninja (bootleg)", 0 )
+
+// this is a common bootleg board
+GAME( 1989, midresb,    midres,   midresb,  midresb,  midresb,  ROT0,   "bootleg", "Midnight Resistance (bootleg with 68705)", 0 ) // need to hook up 68705?
+GAME( 1989, ffantasybl, hippodrm, midres,   midres,   0,        ROT0,   "bootleg", "Fighting Fantasy (bootleg with 68705)", GAME_NOT_WORKING ) // 68705 not dumped, might be the same as midresb
+/* A Bad Dudes bootleg with 68705 like the midres and ffantasy ones exists, but is not dumped */
+
+// these are different to the above but quite similar to each other
+GAME( 1988, automat,    robocop,  automat,  robocop,  robocop,  ROT0,   "bootleg", "Automat (bootleg of Robocop)", GAME_NOT_WORKING ) // sound rom / music from section z with mods for ADPCM?
+GAME( 1989, secretab,   slyspy,   secretab, slyspy,   slyspy,   ROT0,   "bootleg", "Secret Agent (bootleg)", GAME_NOT_WORKING )
diff -Nru src-old/mame/drivers/decocass.c src/mame/drivers/decocass.c
--- src-old/mame/drivers/decocass.c	2012-05-22 18:40:44.000000000 +0200
+++ src/mame/drivers/decocass.c	2012-06-22 05:32:50.000000000 +0200
@@ -801,6 +801,12 @@
 	MCFG_MACHINE_RESET(cdsteljn)
 MACHINE_CONFIG_END
 
+static MACHINE_CONFIG_DERIVED( cfishing, decocass )
+
+	/* basic machine hardware */
+	MCFG_MACHINE_RESET(cfishing)
+MACHINE_CONFIG_END
+
 
 static MACHINE_CONFIG_DERIVED( chwy, decocass )
 
@@ -1292,6 +1298,18 @@
 /* The Following use Dongle Type 3 (unknown part number?)
     (dongle data differs for each game)      */
 
+/* 25 Fishing / Angler Dangler */
+ROM_START( cfishing )
+	DECOCASS_BIOS_A_ROMS
+
+	ROM_REGION( 0x01000, "dongle", 0 )	  /* dongle data */
+	ROM_LOAD( "dp-1250-a-0.pro", 0x0000, 0x1000, CRC(92a3b387) SHA1(e17a155d02e9ed806590b23a845dc7806b6720b1) )
+
+	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
+	ROM_LOAD( "dt-1250-a-0.cas",   0x0000, 0x7500, CRC(d4a16425) SHA1(25afaabdc8b2217d5e73606a36ea9ba408d7bc4b) )
+ROM_END
+
+
 /* 26 Hamburger / Burger Time */
 /* Photo of Dongle shows DP-126B with Cassette DT-1267B (the "7B" is in a seperate white box then the DP-126 label) */
 ROM_START( cbtime ) // version 7-B-0
@@ -1689,6 +1707,7 @@
 /* 23 */ // 1982.?? 18 Hole Pro Golf
 /* 24 */ // 1982.07 Tsumego Kaisyou
 /* 25 */ // 1982.10 Angler Dangler? (fishing)
+/* 25 */ GAME( 1982, cfishing,  decocass, cfishing, decocass, decocass, ROT270, "Data East Corporation", "Fishing (DECO Cassette)", 0 )
 /* 26 */ GAME( 1983, cbtime,    decocass, cbtime,   cbtime,   decocass, ROT270, "Data East Corporation", "Burger Time (DECO Cassette)", 0 )
          GAME( 1982, chamburger,cbtime,   cbtime,   cbtime,   decocass, ROT270, "Data East Corporation", "Hamburger (DECO Cassette, Japan)", 0 )
 /* 27 */ GAME( 1982, cburnrub,  decocass, cburnrub, decocass, decocass, ROT270, "Data East Corporation", "Burnin' Rubber (DECO Cassette, set 1)", 0 )
diff -Nru src-old/mame/drivers/dkong.c src/mame/drivers/dkong.c
--- src-old/mame/drivers/dkong.c	2012-05-25 16:38:46.000000000 +0200
+++ src/mame/drivers/dkong.c	2012-06-17 11:06:15.000000000 +0200
@@ -1599,17 +1599,6 @@
  *
  *************************************/
 
-static const eeprom_interface braze_eeprom_intf =
-{
-	7,				/* address bits */
-	8,				/* data bits */
-	"*110",			/* read command */
-	"*101",			/* write command */
-	0,				/* erase command */
-	"*10000xxxxx",	/* lock command */
-	"*10011xxxxx",	/* unlock command */
-};
-
 READ8_MEMBER(dkong_state::braze_eeprom_r)
 {
 	eeprom_device *eeprom = machine().device<eeprom_device>("eeprom");
@@ -1724,7 +1713,7 @@
 
 static MACHINE_CONFIG_DERIVED( braze, dkong2b )
 
-	MCFG_EEPROM_ADD("eeprom", braze_eeprom_intf)
+	MCFG_EEPROM_93C46_8BIT_ADD("eeprom")
 MACHINE_CONFIG_END
 
 static MACHINE_CONFIG_START( dkong3, dkong_state )
@@ -3204,8 +3193,8 @@
 GAME( 1981, dkongjo,  dkong,    dkong2b,  dkong,          0,  ROT90, "Nintendo", "Donkey Kong (Japan set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1981, dkongjo1, dkong,    dkong2b,  dkong,          0,  ROT90, "Nintendo", "Donkey Kong (Japan set 3)", GAME_SUPPORTS_SAVE )
 GAME( 2004, dkongf,   dkong,    dkong2b,  dkongf,         0,  ROT90, "hack", "Donkey Kong Foundry (hack)", GAME_SUPPORTS_SAVE ) /* from Jeff's Romhack */
-GAME( 2006, dkongx,   dkong,    braze,    dkongx,    dkongx,  ROT90, "hack", "Donkey Kong II - Jumpman Returns (V1.2) (hack)", GAME_SUPPORTS_SAVE )
-GAME( 2006, dkongx11, dkong,    braze,    dkongx,    dkongx,  ROT90, "hack", "Donkey Kong II - Jumpman Returns (V1.1) (hack)", GAME_SUPPORTS_SAVE )
+GAME( 2006, dkongx,   dkong,    braze,    dkongx,    dkongx,  ROT90, "hack (Braze Technologies)", "Donkey Kong II - Jumpman Returns (V1.2) (hack)", GAME_SUPPORTS_SAVE )
+GAME( 2006, dkongx11, dkong,    braze,    dkongx,    dkongx,  ROT90, "hack (Braze Technologies)", "Donkey Kong II - Jumpman Returns (V1.1) (hack)", GAME_SUPPORTS_SAVE )
 
 GAME( 1982, dkongjr,  0,        dkongjr,  dkongjr,        0,  ROT90, "Nintendo of America", "Donkey Kong Junior (US)", GAME_SUPPORTS_SAVE )
 GAME( 1982, dkongjrj, dkongjr,  dkongjr,  dkongjr,        0,  ROT90, "Nintendo", "Donkey Kong Jr. (Japan)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/dynax.c src/mame/drivers/dynax.c
--- src-old/mame/drivers/dynax.c	2012-05-25 16:38:46.000000000 +0200
+++ src/mame/drivers/dynax.c	2012-06-13 13:25:45.000000000 +0200
@@ -7223,5 +7223,5 @@
 GAME( 1991, tenkaie,  tenkai,   tenkai,   tenkai,   0,        ROT0,   "Dynax",                    "Mahjong Tenkaigen (set 2)",                                     GAME_SUPPORTS_SAVE )
 GAME( 1992, htengoku, 0,        htengoku, htengoku, 0,        ROT180, "Dynax",                    "Hanafuda Hana Tengoku (Japan)",                                 GAME_SUPPORTS_SAVE )
 GAME( 1994, mjreach,  0,        tenkai,   mjreach,  mjreach,  ROT0,   "bootleg / Dynax",          "Mahjong Reach (bootleg)",                                       GAME_SUPPORTS_SAVE )
-GAME( 1995, shpeng,   0,        sprtmtch, drgpunch, 0,        ROT0,   "WSAC Systems?",            "Sea Hunter Penguin",                                            GAME_WRONG_COLORS | GAME_SUPPORTS_SAVE ) // not a dynax board. proms?
+GAME( 1995, shpeng,   0,        sprtmtch, drgpunch, 0,        ROT0,   "WSAC Systems?",            "Sea Hunter Penguin",                                            GAME_NO_COCKTAIL | GAME_WRONG_COLORS | GAME_SUPPORTS_SAVE ) // not a dynax board. proms?
 GAME( 1996, majrjhdx, 0,        majrjhdx, tenkai,   0,        ROT0,   "Dynax",                    "Mahjong Raijinhai DX",                                          GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/eolith.c src/mame/drivers/eolith.c
--- src-old/mame/drivers/eolith.c	2012-06-05 19:57:02.000000000 +0200
+++ src/mame/drivers/eolith.c	2012-07-02 09:06:11.000000000 +0200
@@ -44,9 +44,6 @@
  - Fortress 2 Blue Arcade (v. 1.02)
  - Ribbon (Step1. Mild Mind) (c) 1999 - Alt title Penfan girls is dumped
 
- TODO:
- - sound & sound cpu
-
 -----------------------------------------------------------------------------
  Original (Not emulation) Bugs:
 
@@ -83,8 +80,10 @@
 
   - linkypip (Linky Pipe)
 
-      Game seems to randomly hang for unknown reasons at the "Round 1" screen
-      just before you can actually start playing.  Gets cought up here:
+      Linky Pipe seems to randomly hang based on the lower 2 bits of the
+      "dipswitches" at boot. Is this protection, some kind of left over
+      debug code, or a CPU bug? The game seems fine with those switches
+      left high. The code responsible for this issue is:
 
       40008176: MOV L10, L11
       40008178: LDW.P L5, L8
@@ -100,23 +99,21 @@
 
 #include "emu.h"
 #include "cpu/e132xs/e132xs.h"
+#include "cpu/mcs51/mcs51.h"
+#include "sound/qs1000.h"
 #include "machine/eeprom.h"
 #include "includes/eolith.h"
 #include "includes/eolithsp.h"
 
-// It's configured for 512 bytes
-static const eeprom_interface eeprom_interface_93C66 =
-{
-	9,				// address bits 9
-	8,				// data bits    8
-	"*110",			// read         110 aaaaaaaaa
-	"*101",			// write        101 aaaaaaaaa dddddddd
-	"*111",			// erase        111 aaaaaaaaa
-	"*10000xxxxxx",	// lock         100 00xxxxxxx
-	"*10011xxxxxx"	// unlock       100 11xxxxxxx
-};
+
+static MACHINE_RESET( eolith );
 
 
+/*************************************
+ *
+ *  Control
+ *
+ *************************************/
 
 READ32_MEMBER(eolith_state::eolith_custom_r)
 {
@@ -162,13 +159,95 @@
 	return xpos + (ypos*168*2);
 }
 
+WRITE32_MEMBER( eolith_state::sound_w )
+{
+//  printf("CPU Command: %x\n", m_sound_data);
+	m_sound_data = data;
+	m_soundcpu->set_input_line(MCS51_INT0_LINE, ASSERT_LINE);
+
+	space.machine().scheduler().boost_interleave(attotime::zero, attotime::from_usec(250));
+}
+
+
+/*************************************
+ *
+ *  Sound CPU
+ *
+ *************************************/
+
+READ8_MEMBER( eolith_state::sound_cmd_r )
+{
+	m_soundcpu->set_input_line(MCS51_INT0_LINE, CLEAR_LINE);
+	return m_sound_data;
+}
+
+WRITE8_MEMBER( eolith_state::sound_p1_w )
+{
+	// .... xxxx - Data ROM bank (32kB)
+	// ...x .... - Unknown (Usually 1?)
+	membank("sound_bank")->set_entry(data & 0x0f);
+}
+
+
+/*************************************
+ *
+ *  QS1000 CPU
+ *
+ *************************************/
+
+/*
+    Possible port mapping:
+
+    P30 (O) A16      (RxD)
+    P31 (O) A17      (TxD)
+    P32 (O) A18      (/INT0)
+    P33 (I) INT_68   (/INT1)
+    P34 (O) PCM1     (T0)
+    P35 (O) SET_INT  (T1)
+    P36 (O) PCM0
+    P37 (O) RDB      (/RD)
+*/
+
+READ8_MEMBER( eolith_state::qs1000_p1_r )
+{
+	// Sound banking? (must be 1)
+	return 1;
+}
+
+WRITE8_MEMBER( eolith_state::qs1000_p1_w )
+{
+
+}
+
+
+/*************************************
+ *
+ *  Sound CPU <-> QS1000 CPU
+ *
+ *************************************/
+
+static void soundcpu_to_qs1000(device_t *device, int data)
+{
+	qs1000_device *qs1000 = device->machine().device<qs1000_device>("qs1000");
+	qs1000->serial_in(data);
+
+	device->machine().scheduler().boost_interleave(attotime::zero, attotime::from_usec(250));
+}
+
+
+/*************************************
+ *
+ *  Main CPU memory map
+ *
+ *************************************/
+
 static ADDRESS_MAP_START( eolith_map, AS_PROGRAM, 32, eolith_state )
 	AM_RANGE(0x00000000, 0x001fffff) AM_RAM // fort2b wants ram here
 	AM_RANGE(0x40000000, 0x401fffff) AM_RAM
 	AM_RANGE(0x90000000, 0x9003ffff) AM_READWRITE(eolith_vram_r, eolith_vram_w)
 	AM_RANGE(0xfc000000, 0xfc000003) AM_READ(eolith_custom_r)
 	AM_RANGE(0xfc400000, 0xfc400003) AM_WRITE(systemcontrol_w)
-	AM_RANGE(0xfc800000, 0xfc800003) AM_WRITENOP // sound latch
+	AM_RANGE(0xfc800000, 0xfc800003) AM_WRITE(sound_w)
 	AM_RANGE(0xfca00000, 0xfca00003) AM_READ_PORT("DSW1")
 	AM_RANGE(0xfcc00000, 0xfcc0005b) AM_WRITENOP // crt registers ?
 	AM_RANGE(0xfd000000, 0xfeffffff) AM_ROM AM_REGION("user1", 0)
@@ -176,6 +255,28 @@
 ADDRESS_MAP_END
 
 
+/*************************************
+ *
+ *  Sound CPU memory map
+ *
+ *************************************/
+
+static ADDRESS_MAP_START( sound_prg_map, AS_PROGRAM, 8, eolith_state )
+	AM_RANGE(0x0000, 0x7fff) AM_ROM
+ADDRESS_MAP_END
+
+static ADDRESS_MAP_START( sound_io_map, AS_IO, 8, eolith_state )
+	AM_RANGE(0x0000, 0x7fff) AM_ROMBANK("sound_bank")
+	AM_RANGE(0x8000, 0x8000) AM_READ(sound_cmd_r)
+	AM_RANGE(MCS51_PORT_P1, MCS51_PORT_P1) AM_WRITE(sound_p1_w)
+ADDRESS_MAP_END
+
+
+/*************************************
+ *
+ *  Inputs
+ *
+ *************************************/
 
 static INPUT_PORTS_START( common )
 	PORT_START("IN0")
@@ -233,12 +334,11 @@
 	PORT_BIT( 0x40000000, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)
 
 	PORT_MODIFY("DSW1")
-	PORT_DIPNAME( 0x00000001, 0x00000001, DEF_STR( Unknown ) ) PORT_DIPLOCATION("SW4:1")
-	PORT_DIPSETTING(          0x00000001, DEF_STR( Off ) )
-	PORT_DIPSETTING(          0x00000000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x00000002, 0x00000002, DEF_STR( Unknown ) ) PORT_DIPLOCATION("SW4:2")
-	PORT_DIPSETTING(          0x00000002, DEF_STR( Off ) )
-	PORT_DIPSETTING(          0x00000000, DEF_STR( On ) )
+	PORT_DIPNAME( 0x00000003, 0x00000003, "Don't Touch" ) PORT_DIPLOCATION("SW4:1,2") // See notes in header of source.
+	PORT_DIPSETTING(          0x00000000, "Fail (0)" )
+	PORT_DIPSETTING(          0x00000001, "Fail (1)" )
+	PORT_DIPSETTING(          0x00000002, "Fail (2)" )
+	PORT_DIPSETTING(          0x00000003, "Working (3)" )
 	PORT_DIPNAME( 0x0000000c, 0x0000000c, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW4:3,4")
 	PORT_DIPSETTING(          0x00000000, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(          0x00000004, DEF_STR( 3C_1C ) )
@@ -270,9 +370,9 @@
 	PORT_DIPNAME( 0x00000001, 0x00000001, "Show Dip-switch Information" ) PORT_DIPLOCATION("SW4:1")
 	PORT_DIPSETTING(          0x00000001, DEF_STR( Off ) )
 	PORT_DIPSETTING(          0x00000000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x00000002, 0x00000000, DEF_STR( Demo_Sounds ) ) PORT_DIPLOCATION("SW4:2")
-	PORT_DIPSETTING(          0x00000002, DEF_STR( Off ) )
-	PORT_DIPSETTING(          0x00000000, DEF_STR( On ) )
+	PORT_DIPNAME( 0x00000002, 0x00000002, DEF_STR( Demo_Sounds ) ) PORT_DIPLOCATION("SW4:2")
+	PORT_DIPSETTING(          0x00000000, DEF_STR( Off ) )
+	PORT_DIPSETTING(          0x00000002, DEF_STR( On ) )
 	PORT_DIPNAME( 0x0000000c, 0x0000000c, DEF_STR( Lives ) ) PORT_DIPLOCATION("SW4:3,4")
 	PORT_DIPSETTING(          0x00000008, "1" )
 	PORT_DIPSETTING(          0x00000004, "2" )
@@ -420,16 +520,72 @@
 INPUT_PORTS_END
 
 
+/*************************************
+ *
+ *  EEPROM interface
+ *
+ *************************************/
+
+// It's configured for 512 bytes
+static const eeprom_interface eeprom_interface_93C66 =
+{
+	9,				// address bits 9
+	8,				// data bits    8
+	"*110",			// read         110 aaaaaaaaa
+	"*101",			// write        101 aaaaaaaaa dddddddd
+	"*111",			// erase        111 aaaaaaaaa
+	"*10000xxxxxx",	// lock         100 00xxxxxxx
+	"*10011xxxxxx"	// unlock       100 11xxxxxxx
+};
+
+
+/*************************************
+ *
+ *  QS1000 interface
+ *
+ *************************************/
+
+static QS1000_INTERFACE( qs1000_intf )
+{
+	/* External ROM */
+	true,
+
+	/* P1-P3 read handlers */
+	DEVCB_DRIVER_MEMBER(eolith_state, qs1000_p1_r),
+	DEVCB_NULL,
+	DEVCB_NULL,
+
+	/* P1-P3 write handlers */
+	DEVCB_DRIVER_MEMBER(eolith_state, qs1000_p1_w),
+	DEVCB_NULL,
+	DEVCB_NULL,
+};
+
+
+/*************************************
+ *
+ *  Machine driver
+ *
+ *************************************/
 
 static MACHINE_CONFIG_START( eolith45, eolith_state )
 	MCFG_CPU_ADD("maincpu", E132N, 45000000)		 /* 45 MHz */
 	MCFG_CPU_PROGRAM_MAP(eolith_map)
 	MCFG_TIMER_ADD_SCANLINE("scantimer", eolith_speedup, "screen", 0, 1)
 
-	/* sound cpu */
+	/* Sound CPU */
+	MCFG_CPU_ADD("soundcpu", I8032, XTAL_12MHz)
+	MCFG_CPU_PROGRAM_MAP(sound_prg_map)
+	MCFG_CPU_IO_MAP(sound_io_map)
+
+	MCFG_MACHINE_RESET(eolith)
 
 	MCFG_EEPROM_ADD("eeprom", eeprom_interface_93C66)
 
+//  for testing sound sync
+//  MCFG_QUANTUM_PERFECT_CPU("maincpu")
+//  MCFG_QUANTUM_TIME(attotime::from_hz(6000))
+
 	/* video hardware */
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -444,6 +600,11 @@
 	MCFG_VIDEO_START(eolith)
 
 	/* sound hardware */
+	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
+
+	MCFG_QS1000_ADD("qs1000", XTAL_24MHz, qs1000_intf)
+	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
+	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
 
 static MACHINE_CONFIG_DERIVED( eolith50, eolith45 )
@@ -457,6 +618,11 @@
 MACHINE_CONFIG_END
 
 
+/*************************************
+ *
+ *  ROM definition
+ *
+ *************************************/
 
 /*
 
@@ -523,20 +689,18 @@
 	ROM_LOAD32_WORD_SWAP( "if00-02.u40", 0x0800000, 0x400000, CRC(63b5cca5) SHA1(4ec8b813c7e465f659a4a2361ddfbad763bf6e6a) )
 	ROM_LOAD32_WORD_SWAP( "if00-03.u35", 0x0800002, 0x400000, CRC(54a76cb5) SHA1(21fb3bedf065079d59f642b19487f76590f97558) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "u107", 0x0000, 0x8000, CRC(89450a2f) SHA1(d58efa805f497bec179fdbfb8c5860ac5438b4ec) ) /* 27C256 eprom with no label */
-
-	ROM_REGION( 0x08000, "cpu2", 0 ) /* Sound (80c301) CPU Code */
+	ROM_REGION( 0x08000, "soundcpu", 0 ) /* Sound (80c301) CPU Code */
 	ROM_LOAD( "u111", 0x0000, 0x8000, CRC(5d1d1387) SHA1(91c8aa4c7472b91c149bef9da64569a97df35298) ) /* 27C256 eprom with no label */
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "u108", 0x00000, 0x80000, CRC(89233144) SHA1(74e87679a7559450934b80fcfcb667d9845977a7) ) /* 27C040 eprom with no label */
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "u97", 0x00000, 0x80000, CRC(47b9d43a) SHA1(e0bc42892480cb563dc694fcefa8ca0b984749dd) ) /* 27C040 eprom with no label */
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "u107", 0x0000, 0x8000, CRC(89450a2f) SHA1(d58efa805f497bec179fdbfb8c5860ac5438b4ec) ) /* 27C256 eprom with no label */
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "u97",         0x00000, 0x80000, CRC(47b9d43a) SHA1(e0bc42892480cb563dc694fcefa8ca0b984749dd) ) /* 27C040 eprom with no label */
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 ROM_START( ironfortj )
@@ -549,20 +713,18 @@
 	ROM_LOAD32_WORD_SWAP( "if00-02.u40", 0x0800000, 0x400000, CRC(63b5cca5) SHA1(4ec8b813c7e465f659a4a2361ddfbad763bf6e6a) )
 	ROM_LOAD32_WORD_SWAP( "if00-03.u35", 0x0800002, 0x400000, CRC(54a76cb5) SHA1(21fb3bedf065079d59f642b19487f76590f97558) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "u107", 0x0000, 0x8000, CRC(89450a2f) SHA1(d58efa805f497bec179fdbfb8c5860ac5438b4ec) ) /* 27C256 eprom with no label */
-
-	ROM_REGION( 0x08000, "cpu2", 0 ) /* Sound (80c301) CPU Code */
+	ROM_REGION( 0x08000, "soundcpu", 0 ) /* Sound (80c301) CPU Code */
 	ROM_LOAD( "u111", 0x0000, 0x8000, CRC(5d1d1387) SHA1(91c8aa4c7472b91c149bef9da64569a97df35298) ) /* 27C256 eprom with no label */
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "u108", 0x00000, 0x80000, CRC(89233144) SHA1(74e87679a7559450934b80fcfcb667d9845977a7) ) /* 27C040 eprom with no label */
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "u97", 0x00000, 0x80000, CRC(47b9d43a) SHA1(e0bc42892480cb563dc694fcefa8ca0b984749dd) ) /* 27C040 eprom with no label */
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "u107", 0x0000, 0x8000, CRC(89450a2f) SHA1(d58efa805f497bec179fdbfb8c5860ac5438b4ec) ) /* 27C256 eprom with no label */
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "u97",         0x00000, 0x80000, CRC(47b9d43a) SHA1(e0bc42892480cb563dc694fcefa8ca0b984749dd) ) /* 27C040 eprom with no label */
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 /* Linky Pipe */
@@ -577,20 +739,18 @@
 	ROM_LOAD32_WORD_SWAP( "lp02.u40", 0x0800000, 0x400000, CRC(3381bd2c) SHA1(78b30f3940e5c9887ab4ad398bde356671deabb5) )
 	ROM_LOAD32_WORD_SWAP( "lp03.u35", 0x0800002, 0x400000, CRC(459008f3) SHA1(c59e58c3afc1b7466df306c1b57110a6b644cdf4) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "u107.bin", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
-
-	ROM_REGION( 0x08000, "cpu2", 0 ) /* Sound (80c301) CPU Code */
+	ROM_REGION( 0x08000, "soundcpu", 0 ) /* Sound (80c301) CPU Code */
 	ROM_LOAD( "u111.bin", 0x0000, 0x8000, CRC(52f419ea) SHA1(79c9f135b0cf8b1928411faed9b447cd98a83287) )
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "u108.bin", 0x00000, 0x80000, CRC(ca65856f) SHA1(f45868552389ccd637b5ccb1067b94e1226001ce) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "u97.bin", 0x00000, 0x80000, CRC(4465fe8d) SHA1(4d77169fff2fee5424e8da833088a544318b2981) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "u107.bin", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "u97.bin",     0x00000, 0x80000, CRC(4465fe8d) SHA1(4d77169fff2fee5424e8da833088a544318b2981) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 /* Hidden Catch */
@@ -608,20 +768,18 @@
 	ROM_LOAD32_WORD_SWAP( "hc5_u36.bin", 0x1000002, 0x400000, CRC(74b1719d) SHA1(fe2325259117598ad7c23217426ac9c28440e3a0) )
 	// 0x1800000 - 0x1ffffff empty
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "hc_u107.bin", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
-
-	ROM_REGION( 0x008000, "cpu2", 0 )  /* Sound (80c301) CPU Code */
-	ROM_LOAD( "hc_u111.bin", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) ) /* Only 0x3E6 bytes used */
+	ROM_REGION( 0x008000, "soundcpu", 0 )  /* Sound (80c301) CPU Code */
+	ROM_LOAD( "hc_u111.bin", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) )
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "hc_u108.bin", 0x00000, 0x80000, CRC(2bae46cb) SHA1(7c43f1002dfc20b9c1bb1647f7261dfa7ed2b4f9) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "hc_u97.bin", 0x00000, 0x80000, CRC(ebf9f77b) SHA1(5d472aeb84fc011e19b9e61d34aeddfe7d6ac216) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "hc_u107.bin", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "hc_u97.bin",  0x00000, 0x80000, CRC(ebf9f77b) SHA1(5d472aeb84fc011e19b9e61d34aeddfe7d6ac216) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 /*
@@ -681,20 +839,18 @@
 	ROM_LOAD32_WORD_SWAP( "hc006.u42",   0x1800000, 0x400000, CRC(2ec58049) SHA1(2a95d615f397cc4befdf92fcfca64a2726f6a791) )
 	ROM_LOAD32_WORD_SWAP( "hc007.u37",   0x1800002, 0x400000, CRC(07e25def) SHA1(6e52a897cb2894625721010b8468ff237930b19b) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "u107",        0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
-
-	ROM_REGION( 0x008000, "cpu2", 0 )  /* Sound (80c301) CPU Code */
-	ROM_LOAD( "u111",        0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) ) /* Only 0x3E6 bytes used */
+	ROM_REGION( 0x008000, "soundcpu", 0 )  /* Sound (80c301) CPU Code */
+	ROM_LOAD( "u111",        0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) )
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "u108",        0x00000, 0x80000, CRC(2bae46cb) SHA1(7c43f1002dfc20b9c1bb1647f7261dfa7ed2b4f9) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "u97",        0x00000, 0x80000, CRC(ebf9f77b) SHA1(5d472aeb84fc011e19b9e61d34aeddfe7d6ac216) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "u107",        0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "u97",         0x00000, 0x80000, CRC(ebf9f77b) SHA1(5d472aeb84fc011e19b9e61d34aeddfe7d6ac216) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 /*
@@ -764,21 +920,19 @@
 	ROM_LOAD32_WORD_SWAP( "14", 0x1c00000, 0x200000, CRC(8eb1b01b) SHA1(e144ba01aa65dc96e22d1d41c3ca87ae19e874d5) )
 	ROM_LOAD32_WORD_SWAP( "15", 0x1c00002, 0x200000, CRC(3b06fe4e) SHA1(35356a116e6b825b8ed93c8ea1e016491ac1863a) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "u107",        0x0000, 0x8000, CRC(89450a2f) SHA1(d58efa805f497bec179fdbfb8c5860ac5438b4ec) )
-
-	ROM_REGION( 0x000800, "cpu2", 0 ) /* AT89c52 */
+	ROM_REGION( 0x008000, "soundcpu", 0 ) /* AT89c52 */
 	/* This is the first 2K of hc2j.u111 from hidctch2a, verify against the internal dump when decapped */
 	ROM_LOAD( "hc2.103", 0x0000, 0x0800, BAD_DUMP CRC(92797034) SHA1(b600f19972986b2e09c56be0ea0c09f92a9fe422) ) /* MCU internal 2K flash */
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "u108",        0x00000, 0x80000, CRC(75fc7a65) SHA1(308715ab62d28787ee894ddcf7304464e2543b2e) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "u97",        0x00000, 0x80000, CRC(a7a1627e) SHA1(a93ced858d839daac1fa9a85f4f8c89cb179bad5) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "u107",        0x0000, 0x8000, CRC(89450a2f) SHA1(d58efa805f497bec179fdbfb8c5860ac5438b4ec) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "u97",         0x00000, 0x80000, CRC(a7a1627e) SHA1(a93ced858d839daac1fa9a85f4f8c89cb179bad5) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 ROM_START( hidctch2a )
@@ -803,20 +957,18 @@
 	ROM_LOAD32_WORD_SWAP( "14", 0x1c00000, 0x200000, CRC(8eb1b01b) SHA1(e144ba01aa65dc96e22d1d41c3ca87ae19e874d5) )
 	ROM_LOAD32_WORD_SWAP( "15", 0x1c00002, 0x200000, CRC(3b06fe4e) SHA1(35356a116e6b825b8ed93c8ea1e016491ac1863a) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "u107",        0x0000, 0x8000, CRC(89450a2f) SHA1(d58efa805f497bec179fdbfb8c5860ac5438b4ec) )
+	ROM_REGION( 0x008000, "soundcpu", 0 ) /* Sound (80c301) CPU Code */
+	ROM_LOAD( "hc2j.u111", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) )
 
-	ROM_REGION( 0x008000, "cpu2", 0 ) /* Sound (80c301) CPU Code */
-	ROM_LOAD( "hc2j.u111", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) ) /* Only 0x3E6 bytes used */
-
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "u108",        0x00000, 0x80000, CRC(75fc7a65) SHA1(308715ab62d28787ee894ddcf7304464e2543b2e) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "u97",        0x00000, 0x80000, CRC(a7a1627e) SHA1(a93ced858d839daac1fa9a85f4f8c89cb179bad5) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "u107",        0x0000, 0x8000, CRC(89450a2f) SHA1(d58efa805f497bec179fdbfb8c5860ac5438b4ec) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "u97",         0x00000, 0x80000, CRC(a7a1627e) SHA1(a93ced858d839daac1fa9a85f4f8c89cb179bad5) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 
@@ -896,20 +1048,18 @@
 	ROM_LOAD32_WORD_SWAP( "racoon.u5",  0x0800002, 0x200000, CRC(5fbac174) SHA1(1d3e3f40a737d61ff688627891dec183af7fa19a) )
 	// 0x0c00000 - 0x1ffffff empty
 
-	ROM_REGION( 0x08000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "racoon-u.107", 0x0000, 0x8000, CRC(89450a2f) SHA1(d58efa805f497bec179fdbfb8c5860ac5438b4ec) )
-
-	ROM_REGION( 0x08000, "cpu2", 0 ) /* Sound (80c301) CPU Code */
+	ROM_REGION( 0x08000, "soundcpu", 0 ) /* Sound (80c301) CPU Code */
 	ROM_LOAD( "racoon-u.111", 0x0000, 0x8000, CRC(52f419ea) SHA1(79c9f135b0cf8b1928411faed9b447cd98a83287) )
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "racoon-u.108", 0x00000, 0x80000, CRC(fc4f30ee) SHA1(74b9e60cceb03ad572e0e080fbe1de5cffa1b2c3) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "racoon-u.97", 0x00000, 0x80000, CRC(fef828b1) SHA1(38352b67d18300db40113df9426c2aceec12a29b) )
+	ROM_REGION( 0x08000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "racoon-u.107", 0x0000, 0x8000, CRC(89450a2f) SHA1(d58efa805f497bec179fdbfb8c5860ac5438b4ec) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "racoon-u.97", 0x00000, 0x80000, CRC(fef828b1) SHA1(38352b67d18300db40113df9426c2aceec12a29b) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 /* Land Breaker */
@@ -936,20 +1086,18 @@
 	ROM_LOAD32_WORD_SWAP( "14.bin", 0x1c00000, 0x200000, CRC(f30f7bc5) SHA1(8b3e002b773a88229d013e1d95336736a259c698) )
 	ROM_LOAD32_WORD_SWAP( "15.bin", 0x1c00002, 0x200000, CRC(bc1664e3) SHA1(a13a4e1df8d9825a72ecca1552ee52958c0d33d8) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "lb.107", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
-
-	ROM_REGION( 0x008000, "cpu2", 0 ) /* Sound (80c301) CPU Code */
-	ROM_LOAD( "rom1.u111", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) ) /* Only 0x3E6 bytes used */
+	ROM_REGION( 0x008000, "soundcpu", 0 ) /* Sound (80c301) CPU Code */
+	ROM_LOAD( "rom1.u111", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) )
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "rom2.u108", 0x00000, 0x80000, CRC(f3b327ef) SHA1(4b359171afd6ca10275961f795f3fe64f9df9897) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "lb_3.u97", 0x00000, 0x80000, CRC(5b34dff0) SHA1(1668763e977e272781ddcc74beba97b53477cc9d) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "lb.107", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "lb_3.u97",    0x00000, 0x80000, CRC(5b34dff0) SHA1(1668763e977e272781ddcc74beba97b53477cc9d) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 
@@ -967,21 +1115,19 @@
 	ROM_LOAD32_WORD_SWAP( "lb2-006.u42", 0x1800000, 0x400000, CRC(22c57cd8) SHA1(c9eb745523005876395ff7f0b3e996994b3f1220) )
 	ROM_LOAD32_WORD_SWAP( "lb2-007.u37", 0x1800002, 0x400000, CRC(31f957b3) SHA1(ab1c4c50c2d5361ba8db047feb714423d84e6df4) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "lb.107", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
-
-	ROM_REGION( 0x000800, "cpu2", 0 ) /* AT89c52 */
+	ROM_REGION( 0x008000, "soundcpu", 0 ) /* AT89c52 */
 	/* This is the first 2K of rom1.u111 from landbrk, verify against the internal dump when decapped */
 	ROM_LOAD( "lb.103", 0x0000, 0x0800, BAD_DUMP CRC(92797034) SHA1(b600f19972986b2e09c56be0ea0c09f92a9fe422) ) /* MCU internal 2K flash */
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "lb_2.108", 0x00000, 0x80000, CRC(a99182d7) SHA1(628c8d09efb3917a4e97d9e02b6b0ca1f339825d) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "lb_3.u97", 0x00000, 0x80000, CRC(5b34dff0) SHA1(1668763e977e272781ddcc74beba97b53477cc9d) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "lb.107", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "lb_3.u97",    0x00000, 0x80000, CRC(5b34dff0) SHA1(1668763e977e272781ddcc74beba97b53477cc9d) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 
@@ -1007,20 +1153,18 @@
 	ROM_LOAD32_WORD_SWAP( "14.u18", 0x1c00000, 0x200000, CRC(20a9a08e) SHA1(fe4071cdf78d362bccaee92cdc70c66f7e30f817) ) // not checked by rom check
 	ROM_LOAD32_WORD_SWAP( "15.u13", 0x1c00002, 0x200000, CRC(872fa9c4) SHA1(4902faa97c9a3a9671cfefc6a711cfcd25f2d6bc) ) // not checked by rom check
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "pfg.u107", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
-
-	ROM_REGION( 0x008000, "cpu2", 0 ) /* Sound (80c301) CPU Code */
-	ROM_LOAD( "pfg.u111", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) ) /* Only 0x3E6 bytes used */
+	ROM_REGION( 0x008000, "soundcpu", 0 ) /* Sound (80c301) CPU Code */
+	ROM_LOAD( "pfg.u111", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) )
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "pfg.u108", 0x00000, 0x80000, CRC(ac97c23b) SHA1(85319cbff811c84af2a802c2f609bd58cf9e7bc3) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "pfg.u97", 0x00000, 0x80000, CRC(0c713eef) SHA1(4c4ea19fec5af4f0cb983c8b9f71152d05c15047) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "pfg.u107", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "pfg.u97",     0x00000, 0x80000, CRC(0c713eef) SHA1(4c4ea19fec5af4f0cb983c8b9f71152d05c15047) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 
@@ -1047,20 +1191,18 @@
 	ROM_LOAD32_WORD_SWAP( "14.u18", 0x1c00000, 0x200000, CRC(9a4109e5) SHA1(ba59caac5f5a80fc52c507d8a47f322a380aa9a1) )
 	ROM_LOAD32_WORD_SWAP( "15.u13", 0x1c00002, 0x200000, CRC(9a4109e5) SHA1(ba59caac5f5a80fc52c507d8a47f322a380aa9a1) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "ss.u107", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
-
-	ROM_REGION( 0x008000, "cpu2", 0 ) /* Sound (80c301) CPU Code */
-	ROM_LOAD( "ss.u111", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) ) /* Only 0x3E6 bytes used */
+	ROM_REGION( 0x008000, "soundcpu", 0 ) /* Sound (80c301) CPU Code */
+	ROM_LOAD( "ss.u111", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) )
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "ss.u108", 0x00000, 0x80000, CRC(95bd136d) SHA1(a6e2d75fc5e8d600d4dceab13c596f6a7edb6e72) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "ss.u97", 0x00000, 0x80000, CRC(56c9f4a4) SHA1(dfc7cb8b68ec9e77854287b8998131e3ef4ca18d) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "ss.u107", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "ss.u97",      0x00000, 0x80000, CRC(56c9f4a4) SHA1(dfc7cb8b68ec9e77854287b8998131e3ef4ca18d) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 
@@ -1086,25 +1228,21 @@
 	ROM_LOAD32_WORD_SWAP( "14.u18", 0x1c00000, 0x200000, CRC(7cdd8639) SHA1(bdffcb2eeff10b7b3de5d178c766619205dd6f21) ) // not checked by rom check
 	ROM_LOAD32_WORD_SWAP( "15.u13", 0x1c00002, 0x200000, CRC(8b0cf884) SHA1(5acdd084732a15c4a452766bb53bd0e908c1e6f0) ) // not checked by rom check
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "cc.u107", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
+	ROM_REGION( 0x008000, "soundcpu", 0 )  /* Sound (80c301) CPU Code */
+	ROM_LOAD( "cc.u111", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) )
 
-	ROM_REGION( 0x008000, "cpu2", 0 ) /* Sound (80c301) CPU Code */
-	ROM_LOAD( "cc.u111", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) ) /* Only 0x3E6 bytes used */
-
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "cc.u108", 0x00000, 0x80000, CRC(6eedb497) SHA1(d9c7322cba0efa21bef72bc6b1465aa45e8caef6) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "cc.u97", 0x00000, 0x80000, CRC(1400c878) SHA1(d643a9fa930d3a945786a2bb90919a0f6404c625) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "hc_u107.bin", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "cc.u97",      0x00000, 0x80000, CRC(1400c878) SHA1(d643a9fa930d3a945786a2bb90919a0f6404c625) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 
-/* Fortress 2 Blue */
-
 ROM_START( fort2b )
 	ROM_REGION( 0x80000, "maincpu", 0 ) /* Hyperstone CPU Code */
 	ROM_LOAD( "1.u43",        0x00000, 0x80000, CRC(b2279485) SHA1(022591b260be28820f04a1c1fdd61cb9b68d6703) )
@@ -1127,22 +1265,21 @@
 	ROM_LOAD32_WORD_SWAP( "14.u18", 0x1c00000, 0x200000, CRC(450fa784) SHA1(d1244b94be6571f1f8930154778362af5cd4c334) )
 	ROM_LOAD32_WORD_SWAP( "15.u13", 0x1c00002, 0x200000, CRC(c1f02d5c) SHA1(73fe9e654c097cd57863b49545c6aa05996a7645) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "5.u107",       0x00000, 0x08000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
-
-	ROM_REGION( 0x08000, "cpu2", 0 ) /* Sound (80c301) CPU Code */
-	ROM_LOAD( "4.u111",       0x00000, 0x08000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) ) /* Only 0x3E6 bytes used */
+	ROM_REGION( 0x08000, "soundcpu", 0 ) /* Sound (80c301) CPU Code */
+	ROM_LOAD( "4.u111",       0x00000, 0x08000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) )
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "3.u108",       0x00000, 0x80000, CRC(9b996b60) SHA1(c4e34601f754ae2908dd6d59ea9da0c5c6f56f2d) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "2.u97",        0x00000, 0x80000, CRC(8a431b14) SHA1(5a9824280f30ef2e7b7f16652b2f9f9559cb764f) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "5.u107",       0x00000, 0x08000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sapmle ROMs */
+	ROM_LOAD( "2.u97",        0x00000, 0x80000, CRC(8a431b14) SHA1(5a9824280f30ef2e7b7f16652b2f9f9559cb764f) )
+	ROM_LOAD( "qs1001a.u96",  0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
+
 ROM_START( fort2ba )
 	ROM_REGION( 0x80000, "maincpu", 0 ) /* Hyperstone CPU Code */
 	ROM_LOAD( "ftii012.u43", 0x00000, 0x80000, CRC(6424e05f) SHA1(2f02f103de180561e372ce897f8410a11c4cb58d) )
@@ -1157,20 +1294,18 @@
 	ROM_LOAD32_WORD_SWAP( "ftii003.u42", 0x1800000, 0x400000, CRC(3cac1efe) SHA1(aca009a39b5d6049e3cf234f4412868a569ffb18) )
 	ROM_LOAD32_WORD_SWAP( "ftii007.u37", 0x1800002, 0x400000, CRC(a583a672) SHA1(b013fbfaa1e3f573a305e6346e50b930766daa1d) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "ftii010.u107", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
+	ROM_REGION( 0x08000, "soundcpu", 0 ) /* Sound (80c301) CPU Code */
+	ROM_LOAD( "ftii008.u111", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) )
 
-	ROM_REGION( 0x08000, "cpu2", 0 ) /* Sound (80c301) CPU Code */
-	ROM_LOAD( "ftii008.u111", 0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) ) /* Only 0x3E6 bytes used */
-
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "ftii009.u108", 0x00000, 0x80000, CRC(9b996b60) SHA1(c4e34601f754ae2908dd6d59ea9da0c5c6f56f2d) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "ftii011.u97", 0x00000, 0x80000, CRC(8a431b14) SHA1(5a9824280f30ef2e7b7f16652b2f9f9559cb764f) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "ftii010.u107", 0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "ftii011.u97",  0x00000, 0x80000, CRC(8a431b14) SHA1(5a9824280f30ef2e7b7f16652b2f9f9559cb764f) )
+	ROM_LOAD( "qs1001a.u96",  0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 /* Puzzle King */
@@ -1197,20 +1332,18 @@
 	ROM_LOAD32_WORD_SWAP( "u17.bin", 0x1c00000, 0x200000, CRC(234b7261) SHA1(6bb95b8258133cc802f076c15e69c5412272e960) )
 	ROM_LOAD32_WORD_SWAP( "u8.bin",  0x1c00002, 0x200000, CRC(8f4e50d7) SHA1(78808f0193a13467b45c84aef7f6a8f1cfe24feb) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "u107.bin",    0x0000, 0x8000, CRC(f3add818) SHA1(96e77950154ced9f3234200de2aa29060c00d47f) )
-
-	ROM_REGION( 0x08000, "cpu2", 0 ) /* Sound (80c301) CPU Code */
-	ROM_LOAD( "u111.bin",    0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) ) /* Only 0x3E6 bytes used */
+	ROM_REGION( 0x08000, "soundcpu", 0 ) /* Sound (80c301) CPU Code */
+	ROM_LOAD( "u111.bin",    0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) )
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "u108.bin",    0x00000, 0x80000, CRC(e4555c6b) SHA1(128196a5b47d13ee7163981043b96f7b4b27204b) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "u97.bin",     0x00000, 0x80000, CRC(f4604ce8) SHA1(e061b203ef5df386120dbf089ece094d16a1b59b) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "u107.bin",    0x0000, 0x8000, CRC(f3add818) SHA1(96e77950154ced9f3234200de2aa29060c00d47f) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "u97.bin",     0x00000, 0x80000, CRC(f4604ce8) SHA1(e061b203ef5df386120dbf089ece094d16a1b59b) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 /*
@@ -1285,32 +1418,45 @@
 	ROM_LOAD32_WORD_SWAP( "14", 0x1c00000, 0x200000, CRC(6c042967) SHA1(e81ec2bf4fe5880d283e76bebf5e22d60f0588f9) )
 	ROM_LOAD32_WORD_SWAP( "15", 0x1c00002, 0x200000, CRC(a49c0834) SHA1(64ca242cbf3ad6160b79ea2cb8ca4e4958d40e59) )
 
-	ROM_REGION( 0x008000, "cpu1", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "u107",        0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
-
-	ROM_REGION( 0x008000, "cpu2", 0 ) /* GMS90C32 */
-	ROM_LOAD( "u111",        0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) ) /* Only 0x3E6 bytes used */
+	ROM_REGION( 0x008000, "soundcpu", 0 ) /* GMS90C32 */
+	ROM_LOAD( "u111",        0x0000, 0x8000, CRC(79012474) SHA1(09a2d5705d7bc52cc2d1644c87c1e31ee44813ef) )
 
-	ROM_REGION( 0x080000, "music", 0 ) /* Music data */
+	ROM_REGION( 0x080000, "sounddata", 0 ) /* Music data */
 	ROM_LOAD( "u108",        0x00000, 0x80000, CRC(4a7de2e1) SHA1(89da2423f22f98886d7cac807964b1e52398ee19) )
 
-	ROM_REGION( 0x080000, "sfx", 0 ) /* QDSP samples (SFX) */
-	ROM_LOAD( "u97",        0x00000, 0x80000, CRC(6d37aa1a) SHA1(6827e500d9bf66e2e9236be563456ff88c78db91) )
+	ROM_REGION( 0x008000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "u107",        0x0000, 0x8000, CRC(afd5263d) SHA1(71ace1b749d8a6b84d08b97185e7e512d04e4b8d) )
 
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u96",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP sample ROMs */
+	ROM_LOAD( "u97",         0x00000, 0x80000, CRC(6d37aa1a) SHA1(6827e500d9bf66e2e9236be563456ff88c78db91) )
+	ROM_LOAD( "qs1001a.u96", 0x80000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
+
+static MACHINE_RESET( eolith )
+{
+	cputag_set_input_line(machine, "soundcpu", MCS51_INT1_LINE, ASSERT_LINE);
+}
+
 static DRIVER_INIT( eolith )
 {
+	eolith_state *state = machine.driver_data<eolith_state>();
+
 	init_eolith_speedup(machine);
+
+	// Sound CPU -> QS1000 CPU serial link
+	i8051_set_serial_tx_callback(machine.device("soundcpu"), soundcpu_to_qs1000);
+
+	// Configure the sound ROM banking
+	machine.root_device().membank("sound_bank")->configure_entries(0, 16, state->memregion("sounddata")->base(), 0x8000);
 }
 
 static DRIVER_INIT( landbrk )
 {
 	eolith_state *state = machine.driver_data<eolith_state>();
 	state->m_coin_counter_bit = 0x1000;
-	init_eolith_speedup(machine);
+
+    DRIVER_INIT_CALL(eolith);
 }
 
 static DRIVER_INIT( landbrka )
@@ -1323,7 +1469,8 @@
 	rombase[0x14f00/4] = (rombase[0x14f00/4] & 0xffff) | 0x03000000; /* Change BR to NOP */
 
 	state->m_coin_counter_bit = 0x2000;
-	init_eolith_speedup(machine);
+
+    DRIVER_INIT_CALL(eolith);
 }
 
 static DRIVER_INIT( hidctch2 )
@@ -1331,7 +1478,8 @@
 	//it fails compares in memory like in landbrka
 	UINT32 *rombase = (UINT32*)machine.root_device().memregion("maincpu")->base();
 	rombase[0xbcc8/4] = (rombase[0xbcc8/4] & 0xffff) | 0x03000000; /* Change BR to NOP */
-	init_eolith_speedup(machine);
+
+    DRIVER_INIT_CALL(eolith);
 }
 
 static DRIVER_INIT( hidctch3 )
@@ -1347,23 +1495,30 @@
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0xfcf00000, 0xfcf00003, read32_delegate(FUNC(eolith_state::hidctch3_pen2_r),state));
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0xfcf80000, 0xfcf80003, read32_delegate(FUNC(eolith_state::hidctch3_pen2_r),state));
 
-	init_eolith_speedup(machine);
+    DRIVER_INIT_CALL(eolith);
 }
 
-GAME( 1998, linkypip,  0,        eolith45, linkypip,  eolith,   ROT0, "Eolith", "Linky Pipe", GAME_NO_SOUND | GAME_NOT_WORKING )
-GAME( 1998, ironfort,  0,        ironfort, ironfort,  eolith,   ROT0, "Eolith", "Iron Fortress", GAME_NO_SOUND )
-GAME( 1998, ironfortj, ironfort, ironfort, ironfortj, eolith,   ROT0, "Eolith", "Iron Fortress (Japan)", GAME_NO_SOUND )
-GAME( 1998, hidnctch,  0,        eolith45, hidnctch,  eolith,   ROT0, "Eolith", "Hidden Catch (World) / Tul Lin Gu Lim Chat Ki '98 (Korea) (pcb ver 3.03)",  GAME_NO_SOUND ) // or Teurrin Geurim Chajgi '98
-GAME( 1998, raccoon,   0,        eolith45, raccoon,   eolith,   ROT0, "Eolith", "Raccoon World", GAME_NO_SOUND )
-GAME( 1998, puzzlekg,  0,        eolith45, puzzlekg,  eolith,   ROT0, "Eolith", "Puzzle King (Dance & Puzzle)",  GAME_NO_SOUND )
-GAME( 1999, candy,     0,        eolith50, candy,     eolith,   ROT0, "Eolith", "Candy Candy",  GAME_IMPERFECT_GRAPHICS | GAME_NO_SOUND )
-GAME( 1999, hidctch2,  0,        eolith50, hidnctch,  hidctch2, ROT0, "Eolith", "Hidden Catch 2 (pcb ver 3.03) (Kor/Eng) (AT89c52 protected)", GAME_NO_SOUND )
-GAME( 1999, hidctch2a, hidctch2, eolith50, hidnctch,  eolith,   ROT0, "Eolith", "Hidden Catch 2 (pcb ver 1.00) (Kor/Eng/Jpn/Chi)", GAME_NO_SOUND )
-GAME( 1999, landbrk,   0,        eolith45, landbrk,   landbrk,  ROT0, "Eolith", "Land Breaker (World) / Miss Tang Ja Ru Gi (Korea) (pcb ver 3.02)",  GAME_NO_SOUND ) // or Miss Ttang Jjareugi
-GAME( 1999, landbrka,  landbrk,  eolith45, landbrk,   landbrka, ROT0, "Eolith", "Land Breaker (World) / Miss Tang Ja Ru Gi (Korea) (pcb ver 3.03) (AT89c52 protected)",  GAME_NO_SOUND ) // or Miss Ttang Jjareugi
-GAME( 1999, nhidctch,  0,        eolith45, hidnctch,  eolith,   ROT0, "Eolith", "New Hidden Catch (World) / New Tul Lin Gu Lim Chat Ki '98 (Korea) (pcb ver 3.02)", GAME_NO_SOUND ) // or New Teurrin Geurim Chajgi '98
-GAME( 1999, penfan,    0,        eolith45, landbrk,   eolith,   ROT0, "Eolith", "Penfan Girls - Step1. Mild Mind",  GAME_NO_SOUND ) // alt title of Ribbon
-GAME( 2000, stealsee,  0,        eolith45, stealsee,  eolith,   ROT0, "Moov Generation / Eolith", "Steal See (& Get Land)",  GAME_NO_SOUND )
-GAME( 2000, hidctch3,  0,        eolith50, hidctch3,  hidctch3, ROT0, "Eolith", "Hidden Catch 3 (ver 1.00 / pcb ver 3.05)", GAME_NO_SOUND )
-GAME( 2001, fort2b,    0,        eolith50, common,    eolith,   ROT0, "Eolith", "Fortress 2 Blue Arcade (ver 1.01 / pcb ver 3.05)",  GAME_NO_SOUND )
-GAME( 2001, fort2ba,   fort2b,   eolith50, common,    eolith,   ROT0, "Eolith", "Fortress 2 Blue Arcade (ver 1.00 / pcb ver 3.05)",  GAME_NO_SOUND )
+
+/*************************************
+ *
+ *  Game driver(s)
+ *
+ *************************************/
+
+GAME( 1998, linkypip,  0,        eolith45, linkypip,  eolith,   ROT0, "Eolith", "Linky Pipe", GAME_IMPERFECT_SOUND )
+GAME( 1998, ironfort,  0,        ironfort, ironfort,  eolith,   ROT0, "Eolith", "Iron Fortress", GAME_IMPERFECT_SOUND )
+GAME( 1998, ironfortj, ironfort, ironfort, ironfortj, eolith,   ROT0, "Eolith", "Iron Fortress (Japan)", GAME_IMPERFECT_SOUND )
+GAME( 1998, hidnctch,  0,        eolith45, hidnctch,  eolith,   ROT0, "Eolith", "Hidden Catch (World) / Tul Lin Gu Lim Chat Ki '98 (Korea) (pcb ver 3.03)",  GAME_IMPERFECT_SOUND ) // or Teurrin Geurim Chajgi '98
+GAME( 1998, raccoon,   0,        eolith45, raccoon,   eolith,   ROT0, "Eolith", "Raccoon World", GAME_IMPERFECT_SOUND )
+GAME( 1998, puzzlekg,  0,        eolith45, puzzlekg,  eolith,   ROT0, "Eolith", "Puzzle King (Dance & Puzzle)",  GAME_IMPERFECT_SOUND )
+GAME( 1999, candy,     0,        eolith50, candy,     eolith,   ROT0, "Eolith", "Candy Candy",  GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
+GAME( 1999, hidctch2,  0,        eolith50, hidnctch,  hidctch2, ROT0, "Eolith", "Hidden Catch 2 (pcb ver 3.03) (Kor/Eng) (AT89c52 protected)", GAME_IMPERFECT_SOUND )
+GAME( 1999, hidctch2a, hidctch2, eolith50, hidnctch,  eolith,   ROT0, "Eolith", "Hidden Catch 2 (pcb ver 1.00) (Kor/Eng/Jpn/Chi)", GAME_IMPERFECT_SOUND )
+GAME( 1999, landbrk,   0,        eolith45, landbrk,   landbrk,  ROT0, "Eolith", "Land Breaker (World) / Miss Tang Ja Ru Gi (Korea) (pcb ver 3.02)",  GAME_IMPERFECT_SOUND ) // or Miss Ttang Jjareugi
+GAME( 1999, landbrka,  landbrk,  eolith45, landbrk,   landbrka, ROT0, "Eolith", "Land Breaker (World) / Miss Tang Ja Ru Gi (Korea) (pcb ver 3.03) (AT89c52 protected)",  GAME_IMPERFECT_SOUND ) // or Miss Ttang Jjareugi
+GAME( 1999, nhidctch,  0,        eolith45, hidnctch,  eolith,   ROT0, "Eolith", "New Hidden Catch (World) / New Tul Lin Gu Lim Chat Ki '98 (Korea) (pcb ver 3.02)", GAME_IMPERFECT_SOUND ) // or New Teurrin Geurim Chajgi '98
+GAME( 1999, penfan,    0,        eolith45, landbrk,   eolith,   ROT0, "Eolith", "Penfan Girls - Step1. Mild Mind",  GAME_IMPERFECT_SOUND ) // alt title of Ribbon
+GAME( 2000, stealsee,  0,        eolith45, stealsee,  eolith,   ROT0, "Moov Generation / Eolith", "Steal See (& Get Land)",  GAME_IMPERFECT_SOUND )
+GAME( 2000, hidctch3,  0,        eolith50, hidctch3,  hidctch3, ROT0, "Eolith", "Hidden Catch 3 (ver 1.00 / pcb ver 3.05)", GAME_IMPERFECT_SOUND )
+GAME( 2001, fort2b,    0,        eolith50, common,    eolith,   ROT0, "Eolith", "Fortress 2 Blue Arcade (ver 1.01 / pcb ver 3.05)",  GAME_IMPERFECT_SOUND )
+GAME( 2001, fort2ba,   fort2b,   eolith50, common,    eolith,   ROT0, "Eolith", "Fortress 2 Blue Arcade (ver 1.00 / pcb ver 3.05)",  GAME_IMPERFECT_SOUND )
diff -Nru src-old/mame/drivers/eolithsp.c src/mame/drivers/eolithsp.c
--- src-old/mame/drivers/eolithsp.c	2012-06-05 16:29:13.000000000 +0200
+++ src/mame/drivers/eolithsp.c	2012-07-02 09:06:11.000000000 +0200
@@ -13,6 +13,7 @@
 #include "includes/eolith.h"
 
 static int eolith_speedup_address;
+static int eolith_speedup_address2;
 static int eolith_speedup_resume_scanline;
 static int eolith_vblank = 0;
 static int eolith_scanline = 0;
@@ -23,41 +24,46 @@
   //if ((cpu_get_pc(&space->device())!=eolith_speedup_address) && (eolith_vblank!=1) )
   //    printf("%s:eolith speedup_read data %02x\n",space->machine().describe_context(), eolith_vblank);
 
-	if (cpu_get_pc(&space->device())==eolith_speedup_address && eolith_vblank==0 && eolith_scanline < eolith_speedup_resume_scanline)
+	if (eolith_vblank==0 && eolith_scanline < eolith_speedup_resume_scanline)
 	{
-		device_spin_until_trigger(&space->device(), 1000);
-	}
+		int pc = cpu_get_pc(&space->device());
 
+		if ((pc==eolith_speedup_address) || (pc==eolith_speedup_address2))
+		{
+			device_spin_until_trigger(&space->device(), 1000);
+		}
+	}
 }
 
 static const struct
 {
 	const char *s_name;
-	UINT32 speedup_address;
+	int speedup_address;
+	int speedup_address2;
 	int speedup_resume_scanline;
 
 } eolith_speedup_table[] =
 {
 	/* eolith.c */
-	{ "linkypip", 0x4000825c, 240 },
-	{ "ironfort", 0x40020854, 240 },
-	{ "hidnctch", 0x4000bba0, 240 },
-	{ "raccoon",  0x40008204, 240 },
-	{ "puzzlekg", 0x40029458, 240 },
-	{ "hidctch2", 0x40009524, 240 },
-	{ "hidctch2a",0x40029B58, 240 },
-	{ "landbrk",  0x40023574, 240 },
-	{ "landbrka", 0x4002446c, 240 },
-	{ "nhidctch", 0x40012778, 240 },
-	{ "hidctch3", 0x4001f6a0, 240 },
-	{ "fort2b",   0x000081e0, 240 },
-	{ "fort2ba",  0x000081e0, 240 },
-	{ "penfan",   0x4001FA66, 240 },
-	{ "candy",    0x4001990C, 240 },
+	{ "linkypip", 0x4000825c, -1,/*0x4000ABAE,*/ 240 }, // 2nd address is used on the planet cutscene between but idle skipping between levels, but seems too aggressive
+	{ "ironfort", 0x40020854, -1, 240 },
+	{ "hidnctch", 0x4000bba0, -1, 240 },
+	{ "raccoon",  0x40008204, -1, 240 },
+	{ "puzzlekg", 0x40029458, -1, 240 },
+	{ "hidctch2", 0x40009524, -1, 240 },
+	{ "hidctch2a",0x40029B58, -1, 240 },
+	{ "landbrk",  0x40023574, -1, 240 },
+	{ "landbrka", 0x4002446c, -1, 240 },
+	{ "nhidctch", 0x40012778, -1, 240 },
+	{ "hidctch3", 0x4001f6a0, -1, 240 },
+	{ "fort2b",   0x000081e0, -1, 240 },
+	{ "fort2ba",  0x000081e0, -1, 240 },
+	{ "penfan",   0x4001FA66, -1, 240 },
+	{ "candy",    0x4001990C, -1, 240 },
 	/* eolith16.c */
-	{ "klondkp",  0x0001a046, 240 },
+	{ "klondkp",  0x0001a046, -1, 240 },
 	/* vegaeo.c */
-	{ "crazywar", 0x00008cf8, 240 },
+	{ "crazywar", 0x00008cf8, -1, 240 },
 	{ NULL, 0, 0 }
 };
 
@@ -73,8 +79,8 @@
 		if( strcmp( machine.system().name, eolith_speedup_table[ n_game ].s_name ) == 0 )
 		{
 			eolith_speedup_address = eolith_speedup_table[ n_game ].speedup_address;
+			eolith_speedup_address2 = eolith_speedup_table[ n_game ].speedup_address2;
 			eolith_speedup_resume_scanline = eolith_speedup_table[ n_game ].speedup_resume_scanline;
-
 		}
 		n_game++;
 	}
diff -Nru src-old/mame/drivers/expro02.c src/mame/drivers/expro02.c
--- src-old/mame/drivers/expro02.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/expro02.c	2012-06-12 03:50:09.000000000 +0200
@@ -786,9 +786,9 @@
  *
  *************************************/
 
-GAME( 1990, galsnew,  0,       galsnew, galsnew,  galsnew, ROT90, "Kaneko", "Gals Panic (US, EXPRO-02 PCB)", 0 )
-GAME( 1990, galsnewa, galsnew, galsnew, galsnewa, galsnew, ROT90, "Kaneko", "Gals Panic (Export, EXPRO-02 PCB)", 0 )
-GAME( 1990, galsnewj, galsnew, galsnew, galsnewj, galsnew, ROT90, "Kaneko (Taito license)", "Gals Panic (Japan, EXPRO-02 PCB)", 0 )
-GAME( 1990, galsnewk, galsnew, galsnew, galsnewj, galsnew, ROT90, "Kaneko (Inter license)", "Gals Panic (Korea, EXPRO-02 PCB)", 0 )
+GAME( 1990, galsnew,  0,       galsnew, galsnew,  galsnew, ROT90, "Kaneko", "Gals Panic (US, EXPRO-02 PCB)", GAME_NO_COCKTAIL )
+GAME( 1990, galsnewa, galsnew, galsnew, galsnewa, galsnew, ROT90, "Kaneko", "Gals Panic (Export, EXPRO-02 PCB)", GAME_NO_COCKTAIL )
+GAME( 1990, galsnewj, galsnew, galsnew, galsnewj, galsnew, ROT90, "Kaneko (Taito license)", "Gals Panic (Japan, EXPRO-02 PCB)", GAME_NO_COCKTAIL )
+GAME( 1990, galsnewk, galsnew, galsnew, galsnewj, galsnew, ROT90, "Kaneko (Inter license)", "Gals Panic (Korea, EXPRO-02 PCB)", GAME_NO_COCKTAIL )
 
 GAME( 1994, fantasia, 0,       fantasia,fantasia, galsnew, ROT90, "Comad & New Japan System", "Fantasia", GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS )
diff -Nru src-old/mame/drivers/freekick.c src/mame/drivers/freekick.c
--- src-old/mame/drivers/freekick.c	2012-05-25 16:38:46.000000000 +0200
+++ src/mame/drivers/freekick.c	2012-06-13 13:25:45.000000000 +0200
@@ -14,7 +14,7 @@
     NEC MC-8123 with Sega security number 317-5002
 
 TODO:
-- Gigas cocktail mode / flipscreen
+- Proper cocktail mode / flipscreen support for all games in driver
 
 ****************************************************************************
 
@@ -1119,16 +1119,16 @@
  *
  *************************************/
 /*    YEAR  NAME       PARENT    MACHINE    INPUT     INIT      ROT     COMPANY   FULLNAME        FLAGS  */
-GAME( 1986, gigas,     0,        gigas,     gigas,    gigas,    ROT270, "Sega", "Gigas (MC-8123, 317-5002)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
+GAME( 1986, gigas,     0,        gigas,     gigas,    gigas,    ROT270, "Sega", "Gigas (MC-8123, 317-5002)", GAME_NO_COCKTAIL | GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
 GAME( 1986, gigasb,    gigas,    gigas,     gigas,    gigasb,   ROT270, "bootleg", "Gigas (bootleg)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1986, oigas,     gigas ,   oigas,     gigas,    gigasb,   ROT270, "bootleg", "Oigas (bootleg)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1986, gigasm2b,  0,        gigas,     gigasm2,  gigasb,   ROT270, "bootleg", "Gigas Mark II (bootleg)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
-GAME( 1987, pbillrd,   0,        pbillrd,   pbillrd,  0,        ROT0,   "Nihon System", "Perfect Billiard", GAME_SUPPORTS_SAVE )
-GAME( 1987, pbillrds,  pbillrd,  pbillrd,   pbillrd,  pbillrds, ROT0,   "Nihon System", "Perfect Billiard (MC-8123, 317-0030)", GAME_SUPPORTS_SAVE )
-GAME( 1987, freekick,  0,        freekickb, freekck,  0,        ROT270, "Nihon System (Merit license)", "Free Kick", GAME_SUPPORTS_SAVE )
-GAME( 1987, freekickb, freekick, freekickb, freekck,  0,        ROT270, "bootleg", "Free Kick (bootleg set 1)", GAME_SUPPORTS_SAVE )
-GAME( 1987, freekickb2,freekick, freekickb, freekck,  0,        ROT270, "bootleg", "Free Kick (bootleg set 2)", GAME_SUPPORTS_SAVE )
-GAME( 1988, countrun,  0,        freekickb, countrun, 0,        ROT0,   "Nihon System (Sega license)", "Counter Run", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
-GAME( 1988, countrunb, countrun, freekickb, countrun, 0,        ROT0,   "bootleg", "Counter Run (bootleg set 1)", GAME_SUPPORTS_SAVE )
-GAME( 1988, countrunb2,countrun, freekickb, countrun, 0,        ROT0,   "bootleg", "Counter Run (bootleg set 2)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
+GAME( 1987, pbillrd,   0,        pbillrd,   pbillrd,  0,        ROT0,   "Nihon System", "Perfect Billiard", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
+GAME( 1987, pbillrds,  pbillrd,  pbillrd,   pbillrd,  pbillrds, ROT0,   "Nihon System", "Perfect Billiard (MC-8123, 317-0030)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
+GAME( 1987, freekick,  0,        freekickb, freekck,  0,        ROT270, "Nihon System (Merit license)", "Free Kick", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
+GAME( 1987, freekickb, freekick, freekickb, freekck,  0,        ROT270, "bootleg", "Free Kick (bootleg set 1)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
+GAME( 1987, freekickb2,freekick, freekickb, freekck,  0,        ROT270, "bootleg", "Free Kick (bootleg set 2)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
+GAME( 1988, countrun,  0,        freekickb, countrun, 0,        ROT0,   "Nihon System (Sega license)", "Counter Run", GAME_NO_COCKTAIL | GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
+GAME( 1988, countrunb, countrun, freekickb, countrun, 0,        ROT0,   "bootleg", "Counter Run (bootleg set 1)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
+GAME( 1988, countrunb2,countrun, freekickb, countrun, 0,        ROT0,   "bootleg", "Counter Run (bootleg set 2)", GAME_NO_COCKTAIL | GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
 
diff -Nru src-old/mame/drivers/funkball.c src/mame/drivers/funkball.c
--- src-old/mame/drivers/funkball.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/funkball.c	2012-07-02 08:20:21.000000000 +0200
@@ -602,7 +602,7 @@
 //  AM_RANGE(0x03f0, 0x03ff) AM_READWRITE(fdc_r, fdc_w)
 	AM_RANGE(0x03f0, 0x03ff) AM_READWRITE8(fdc_r,fdc_w,0xffffffff)
 
-	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE_LEGACY("pcibus", pci_32le_r,	pci_32le_w)
+	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_bus_legacy_device, read, write)
 
 	AM_RANGE(0x0360, 0x0363) AM_WRITE8(flash_w,0xffffffff)
 
@@ -1156,9 +1156,9 @@
 
 	MCFG_MC146818_ADD( "rtc", MC146818_STANDARD )
 
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(7, "voodoo_0", voodoo_0_pci_r, voodoo_0_pci_w)
-	MCFG_PCI_BUS_DEVICE(18, NULL, cx5510_pci_r, cx5510_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(7, "voodoo_0", voodoo_0_pci_r, voodoo_0_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(18, NULL, cx5510_pci_r, cx5510_pci_w)
 
 	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL, true)
 
diff -Nru src-old/mame/drivers/galdrvr.c src/mame/drivers/galdrvr.c
--- src-old/mame/drivers/galdrvr.c	2012-05-18 17:49:47.000000000 +0200
+++ src/mame/drivers/galdrvr.c	2012-06-24 01:17:51.000000000 +0200
@@ -3332,7 +3332,7 @@
 ROM_END
 
 
-ROM_START( warofbug )
+ROM_START( warofbug )  /* Shows 20c as the base of currency.  I know of no US games that used dimes - unless it's another country? */
 	ROM_REGION( 0x4000, "maincpu", 0 )
 	ROM_LOAD( "warofbug.u",   0x0000, 0x0800, CRC(b8dfb7e3) SHA1(c7c675b2638869a9cd7dbd554e6131d8c71b567a) )
 	ROM_LOAD( "warofbug.v",   0x0800, 0x0800, CRC(fd8854e0) SHA1(b39ab41b834f18341968dd780f0a3cd07d70c16c) )
@@ -3348,6 +3348,24 @@
 	ROM_LOAD( "warofbug.clr", 0x0000, 0x0020, CRC(8688e64b) SHA1(ed13414257f580b98b50c9892a14159c55e7838d) )
 ROM_END
 
+
+ROM_START( warofbugg )
+	ROM_REGION( 0x4000, "maincpu", 0 )
+	ROM_LOAD( "wotbg-u-1.bin",   0x0000, 0x0800, CRC(f43ff0a8) SHA1(b87abeb8af9105fa8fba78f9a68363bd89066e7f) )
+	ROM_LOAD( "wotbg-v-2.bin",   0x0800, 0x0800, CRC(eb7a028b) SHA1(8c822ae11d3cc04f749a7cd639d15b9fc830ab35) )
+	ROM_LOAD( "wotbg-w-3.bin",   0x1000, 0x0800, CRC(693e0e50) SHA1(00b19969cee0f95bfb8251c2df133ff2c9ae3b00) )
+	ROM_LOAD( "wotbg-y-4.bin",   0x1800, 0x0800, CRC(885d4982) SHA1(4aeaf514a9413a9cb9a971fd258c6cf46ca66fc4) )
+	ROM_LOAD( "wotbg-z-5.bin",   0x2000, 0x0800, CRC(60041ef2) SHA1(cced5837a037ac5cd8fa6260d69d8e33de5ecd48) )
+
+	ROM_REGION( 0x1000, "gfx1", 0 )
+	ROM_LOAD( "warofbug.1k",  0x0000, 0x0800, CRC(8100fa85) SHA1(06641c431cace36dec98b87555f62e72f3e53a31) )
+	ROM_LOAD( "warofbug.1j",  0x0800, 0x0800, CRC(d1220ae9) SHA1(e892bc8b0b71d8b07503e474e9c30e6cab460682) )
+
+	ROM_REGION( 0x0020, "proms", 0 )
+	ROM_LOAD( "warofbug.clr", 0x0000, 0x0020, CRC(8688e64b) SHA1(ed13414257f580b98b50c9892a14159c55e7838d) )
+ROM_END
+
+
 /*  Galaxian hardware mods for War of the Bugs warofbug/warofbugg
 
 (WotB using daughterboard that plugs into Z80 socket - has a socketed PAL, two other 20-pin ICs,
@@ -3368,22 +3386,24 @@
 (although I've seen one set of docs saying to connect to pin 1 of
 ic 2N (7408) instead)  */
 
-ROM_START( warofbugg )
+
+ROM_START( warofbugu )
 	ROM_REGION( 0x4000, "maincpu", 0 )
-	ROM_LOAD( "wotbg-u-1.bin",   0x0000, 0x0800, CRC(f43ff0a8) SHA1(b87abeb8af9105fa8fba78f9a68363bd89066e7f) )
-	ROM_LOAD( "wotbg-v-2.bin",   0x0800, 0x0800, CRC(eb7a028b) SHA1(8c822ae11d3cc04f749a7cd639d15b9fc830ab35) )
-	ROM_LOAD( "wotbg-w-3.bin",   0x1000, 0x0800, CRC(693e0e50) SHA1(00b19969cee0f95bfb8251c2df133ff2c9ae3b00) )
-	ROM_LOAD( "wotbg-y-4.bin",   0x1800, 0x0800, CRC(885d4982) SHA1(4aeaf514a9413a9cb9a971fd258c6cf46ca66fc4) )
-	ROM_LOAD( "wotbg-z-5.bin",   0x2000, 0x0800, CRC(60041ef2) SHA1(cced5837a037ac5cd8fa6260d69d8e33de5ecd48) )
+	ROM_LOAD( "wb-prog-1.7d",   0x0000, 0x0800, CRC(b8dfb7e3) SHA1(c7c675b2638869a9cd7dbd554e6131d8c71b567a) )
+	ROM_LOAD( "wb-prog-2.7e",   0x0800, 0x0800, CRC(fd8854e0) SHA1(b39ab41b834f18341968dd780f0a3cd07d70c16c) )
+	ROM_LOAD( "wb-prog-3.7j",   0x1000, 0x0800, CRC(4495aa14) SHA1(f1be281db1d831770efa9cc41ea87eb348e70108) )
+	ROM_LOAD( "wb-prog-4.7n",   0x1800, 0x0800, CRC(e4bd257c) SHA1(e9a26a50cbc76bb339dfbf3d2817229fe9ff7fc4) )
+	ROM_LOAD( "wb-prog-5.7p",   0x2000, 0x0800, CRC(71257bb4) SHA1(3624becfda4e080795a15428a51dcda261f91210) )
 
 	ROM_REGION( 0x1000, "gfx1", 0 )
-	ROM_LOAD( "warofbug.1k",  0x0000, 0x0800, CRC(8100fa85) SHA1(06641c431cace36dec98b87555f62e72f3e53a31) )
-	ROM_LOAD( "warofbug.1j",  0x0800, 0x0800, CRC(d1220ae9) SHA1(e892bc8b0b71d8b07503e474e9c30e6cab460682) )
+	ROM_LOAD( "warofbug.1k",  0x0000, 0x0800, CRC(8100fa85) SHA1(06641c431cace36dec98b87555f62e72f3e53a31) ) // wb-vid-1.1j
+	ROM_LOAD( "warofbug.1j",  0x0800, 0x0800, CRC(d1220ae9) SHA1(e892bc8b0b71d8b07503e474e9c30e6cab460682) ) // wb-vid-2.1l
 
 	ROM_REGION( 0x0020, "proms", 0 )
 	ROM_LOAD( "warofbug.clr", 0x0000, 0x0020, CRC(8688e64b) SHA1(ed13414257f580b98b50c9892a14159c55e7838d) )
 ROM_END
 
+
 ROM_START( redufo ) /* Galaxian bootleg hardware known as Artic Multi-System */
 	ROM_REGION( 0x4000, "maincpu", 0 )
 	ROM_LOAD( "redufo.1",  0x0000, 0x0800, CRC(6a3b873c) SHA1(82f07921d8f1da3ed8b4f99b8052bd7e2cefcb6a) )
@@ -6384,7 +6404,8 @@
 GAME( 19??, omega,    theend,   galaxian, omega,    galaxian, ROT270, "bootleg?", "Omega", GAME_SUPPORTS_SAVE )
 
 /* these games require the coin lockout mechanism to be disabled */
-GAME( 1981, warofbug, 0,        galaxian, warofbug, nolock,   ROT90,  "Armenia", "War of the Bugs or Monsterous Manouvers in a Mushroom Maze", GAME_SUPPORTS_SAVE )
+GAME( 1981, warofbug, 0,        galaxian, warofbug, nolock,   ROT90,  "Armenia / Food and Fun Corp", "War of the Bugs or Monsterous Manouvers in a Mushroom Maze", GAME_SUPPORTS_SAVE )
+GAME( 1981, warofbugu,warofbug, galaxian, warofbug, nolock,   ROT90,  "Armenia / Super Video Games", "War of the Bugs or Monsterous Manouvers in a Mushroom Maze (US)", GAME_SUPPORTS_SAVE )
 GAME( 1981, warofbugg,warofbug, galaxian, warofbug, nolock,   ROT90,  "Armenia", "War of the Bugs or Monsterous Manouvers in a Mushroom Maze (German)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
 GAME( 1981, redufo,   0,        galaxian, redufo,   nolock,   ROT270, "Artic", "Defend the Terra Attack on the Red UFO", GAME_SUPPORTS_SAVE ) // is this the original?
 GAME( 1981, redufob,  redufo,   galaxian, redufob,  nolock,   ROT90,  "bootleg", "Defend the Terra Attack on the Red UFO (bootleg)", GAME_SUPPORTS_SAVE ) // rev A?
diff -Nru src-old/mame/drivers/gamecstl.c src/mame/drivers/gamecstl.c
--- src-old/mame/drivers/gamecstl.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/gamecstl.c	2012-07-02 08:20:21.000000000 +0200
@@ -540,7 +540,7 @@
 	AM_RANGE(0x0278, 0x027b) AM_WRITE(pnp_config_w)
 	AM_RANGE(0x03f0, 0x03ff) AM_READWRITE(fdc_r, fdc_w)
 	AM_RANGE(0x0a78, 0x0a7b) AM_WRITE(pnp_data_w)
-	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE_LEGACY("pcibus", pci_32le_r,	pci_32le_w)
+	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_bus_legacy_device, read, write)
 ADDRESS_MAP_END
 
 /*****************************************************************************/
@@ -694,9 +694,9 @@
 	MCFG_MACHINE_START(gamecstl)
 	MCFG_MACHINE_RESET(gamecstl)
 
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
-	MCFG_PCI_BUS_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
 
 	MCFG_PIT8254_ADD( "pit8254", gamecstl_pit8254_config )
 
diff -Nru src-old/mame/drivers/ghosteo.c src/mame/drivers/ghosteo.c
--- src-old/mame/drivers/ghosteo.c	2012-05-14 20:45:29.000000000 +0200
+++ src/mame/drivers/ghosteo.c	2012-07-02 09:06:11.000000000 +0200
@@ -88,6 +88,7 @@
 	struct nand_t m_nand;
 	DECLARE_WRITE32_MEMBER(sound_w);
 	DECLARE_READ32_MEMBER(bballoon_speedup_r);
+	DECLARE_READ32_MEMBER(touryuu_port_10000000_r);
 
 	int m_rom_pagesize;
 };
@@ -118,7 +119,7 @@
 
 // GPIO
 
-static const UINT8 security_data[] = { 0x01, 0xC4, 0xFF, 0x22 };
+static const UINT8 security_data[] = { 0x01, 0xC4, 0xFF, 0x22, 0xFF, 0xFF, 0xFF, 0xFF };
 
 static UINT32 s3c2410_gpio_port_r( device_t *device, int port, UINT32 mask)
 {
@@ -361,6 +362,24 @@
 	}
 }
 
+READ32_MEMBER( ghosteo_state::touryuu_port_10000000_r )
+{
+	ghosteo_state *state = machine().driver_data<ghosteo_state>();
+	UINT32 port_g = state->m_bballoon_port[S3C2410_GPIO_PORT_G];
+	UINT32 data = 0xFFFFFFFF;
+	switch (port_g)
+	{
+		case 0x8 : data = machine().root_device().ioport( "10000000-08")->read(); break;
+		case 0x9 : data = machine().root_device().ioport( "10000000-09")->read(); break;
+		case 0xA : data = machine().root_device().ioport( "10000000-0A")->read(); break;
+		case 0xB : data = machine().root_device().ioport( "10000000-0B")->read(); break;
+		case 0xC : data = machine().root_device().ioport( "10000000-0C")->read(); break;
+	}
+//  logerror( "touryuu_port_10000000_r (%08X) -> %08X\n", port_g, data);
+	return data;
+}
+
+
 static ADDRESS_MAP_START( bballoon_map, AS_PROGRAM, 32, ghosteo_state )
 	AM_RANGE(0x10000000, 0x10000003) AM_READ_PORT("10000000")
 	AM_RANGE(0x10100000, 0x10100003) AM_READ_PORT("10100000")
@@ -369,6 +388,15 @@
 	AM_RANGE(0x30000000, 0x31ffffff) AM_RAM AM_SHARE("systememory") AM_MIRROR(0x02000000)
 ADDRESS_MAP_END
 
+static ADDRESS_MAP_START( touryuu_map, AS_PROGRAM, 32, ghosteo_state )
+	AM_RANGE(0x10000000, 0x10000003) AM_READ(touryuu_port_10000000_r)
+	AM_RANGE(0x10100000, 0x10100003) AM_READ_PORT("10100000")
+	AM_RANGE(0x10200000, 0x10200003) AM_READ_PORT("10200000")
+	AM_RANGE(0x10300000, 0x10300003) AM_WRITE(sound_w)
+	AM_RANGE(0x30000000, 0x31ffffff) AM_RAM AM_SHARE("systememory") AM_MIRROR(0x02000000)
+ADDRESS_MAP_END
+
+
 /*
 static INPUT_PORTS_START( bballoon )
     PORT_START("10000000")
@@ -427,6 +455,75 @@
 	PORT_BIT( 0xFFFFFF50, IP_ACTIVE_LOW, IPT_UNUSED )
 INPUT_PORTS_END
 
+/*
+
+  Touryuumon
+
+  +----+----+----+----+----+
+  | 1  | 1  | 1  | FF | 1  |
+  +----+----+----+----+----+
+  | C  | G  | K  | Ti | Rn |
+  +----+----+----+----+----+
+  | D  | H  | L  | Po | Be |
+  +----+----+----+----+----+
+  | A  | E  | I  | M  | Kn |
+  +----+----+----+----+----+
+  | B  | F  | J  | N  | Re |
+  +----+----+----+----+----+----+----+
+  | Sv | Ts | Be | 2s | 1s | 2c | 1c |
+  +----+----+----+----+----+----+----+
+
+*/
+
+static INPUT_PORTS_START( touryuu )
+	PORT_START("10000000-08")
+	PORT_BIT( 0x00000001, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1 (5)")
+	PORT_BIT( 0x00000002, IP_ACTIVE_LOW, IPT_MAHJONG_FLIP_FLOP )
+	PORT_BIT( 0x00000004, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1 (3)")
+	PORT_BIT( 0x00000008, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1 (2)")
+	PORT_BIT( 0x00000010, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1 (1)")
+	PORT_BIT( 0xFFFFFFE0, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_START("10000000-09")
+	PORT_BIT( 0x00000001, IP_ACTIVE_LOW, IPT_MAHJONG_RON )
+	PORT_BIT( 0x00000002, IP_ACTIVE_LOW, IPT_MAHJONG_CHI ) // labeled "Ti" in test mode
+	PORT_BIT( 0x00000004, IP_ACTIVE_LOW, IPT_MAHJONG_K )
+	PORT_BIT( 0x00000008, IP_ACTIVE_LOW, IPT_MAHJONG_G )
+	PORT_BIT( 0x00000010, IP_ACTIVE_LOW, IPT_MAHJONG_C )
+	PORT_BIT( 0xFFFFFFE0, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_START("10000000-0A")
+	PORT_BIT( 0x00000001, IP_ACTIVE_LOW, IPT_MAHJONG_BET )
+	PORT_BIT( 0x00000002, IP_ACTIVE_LOW, IPT_MAHJONG_PON )
+	PORT_BIT( 0x00000004, IP_ACTIVE_LOW, IPT_MAHJONG_L )
+	PORT_BIT( 0x00000008, IP_ACTIVE_LOW, IPT_MAHJONG_H )
+	PORT_BIT( 0x00000010, IP_ACTIVE_LOW, IPT_MAHJONG_D )
+	PORT_BIT( 0xFFFFFFE0, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_START("10000000-0B")
+	PORT_BIT( 0x00000001, IP_ACTIVE_LOW, IPT_MAHJONG_KAN )
+	PORT_BIT( 0x00000002, IP_ACTIVE_LOW, IPT_MAHJONG_M )
+	PORT_BIT( 0x00000004, IP_ACTIVE_LOW, IPT_MAHJONG_I )
+	PORT_BIT( 0x00000008, IP_ACTIVE_LOW, IPT_MAHJONG_E )
+	PORT_BIT( 0x00000010, IP_ACTIVE_LOW, IPT_MAHJONG_A )
+	PORT_BIT( 0xFFFFFFE0, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_START("10000000-0C")
+	PORT_BIT( 0x00000001, IP_ACTIVE_LOW, IPT_MAHJONG_REACH )
+	PORT_BIT( 0x00000002, IP_ACTIVE_LOW, IPT_MAHJONG_N )
+	PORT_BIT( 0x00000004, IP_ACTIVE_LOW, IPT_MAHJONG_J )
+	PORT_BIT( 0x00000008, IP_ACTIVE_LOW, IPT_MAHJONG_F )
+	PORT_BIT( 0x00000010, IP_ACTIVE_LOW, IPT_MAHJONG_B )
+	PORT_BIT( 0xFFFFFFE0, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_START("10100000")
+	PORT_BIT( 0xFFFFFFFF, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_START("10200000")
+	PORT_BIT( 0x00000001, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x00000002, IP_ACTIVE_LOW, IPT_COIN2 )
+	PORT_BIT( 0x00000004, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x00000008, IP_ACTIVE_LOW, IPT_START2 )
+	PORT_BIT( 0x00000020, IP_ACTIVE_LOW, IPT_SERVICE1 )
+	PORT_BIT( 0x00000080, IP_ACTIVE_LOW, IPT_SERVICE2 )
+	PORT_BIT( 0xFFFFFF50, IP_ACTIVE_LOW, IPT_UNUSED )
+INPUT_PORTS_END
+
+
 static const s3c2410_interface bballoon_s3c2410_intf =
 {
 	// CORE (pin read / pin write)
@@ -443,11 +540,15 @@
 	{ s3c2410_nand_command_w, s3c2410_nand_address_w, s3c2410_nand_data_r, s3c2410_nand_data_w }
 };
 
-static const i2cmem_interface i2cmem_interface =
+static const i2cmem_interface bballoon_i2cmem_interface =
 {
 	I2CMEM_SLAVE_ADDRESS, 0, 256
 };
 
+static const i2cmem_interface touryuu_i2cmem_interface =
+{
+	I2CMEM_SLAVE_ADDRESS, 0, 1024
+};
 
 device_t* s3c2410;
 
@@ -482,11 +583,10 @@
 	s3c2410 = machine.device("s3c2410");
 }
 
-static MACHINE_CONFIG_START( bballoon, ghosteo_state )
+static MACHINE_CONFIG_START( ghosteo, ghosteo_state )
 
 	/* basic machine hardware */
 	MCFG_CPU_ADD("maincpu", ARM9, 200000000)
-	MCFG_CPU_PROGRAM_MAP(bballoon_map)
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -507,11 +607,23 @@
 //  MCFG_DEVICE_CONFIG(bballoon_nand_intf)
 
 //  MCFG_I2CMEM_ADD("i2cmem", 0xA0, 0, 0x100, NULL)
-	MCFG_I2CMEM_ADD("i2cmem", i2cmem_interface)
 
 	/* sound hardware */
 MACHINE_CONFIG_END
 
+static MACHINE_CONFIG_DERIVED( bballoon, ghosteo )
+	MCFG_CPU_MODIFY("maincpu")
+	MCFG_CPU_PROGRAM_MAP(bballoon_map)
+	MCFG_I2CMEM_ADD("i2cmem", bballoon_i2cmem_interface)
+MACHINE_CONFIG_END
+
+static MACHINE_CONFIG_DERIVED( touryuu, ghosteo )
+	MCFG_CPU_MODIFY("maincpu")
+	MCFG_CPU_PROGRAM_MAP(touryuu_map)
+	MCFG_I2CMEM_ADD("i2cmem", touryuu_i2cmem_interface)
+MACHINE_CONFIG_END
+
+
 /*
 Balloon & Balloon
 Eolith, 2003
@@ -617,4 +729,4 @@
 
 GAME( 2003, bballoon, 0, bballoon, bballoon, bballoon, ROT0, "Eolith", "BnB Arcade", GAME_NO_SOUND )
 GAME( 2005, hapytour, 0, bballoon, bballoon, bballoon, ROT0, "GAV Company", "Happy Tour", GAME_NO_SOUND )
-GAME( 200?, touryuu,  0, bballoon, bballoon, touryuu, ROT0, "Yuki Enterprise", "Touryuumon (V1.1)?", GAME_NOT_WORKING | GAME_NO_SOUND ) // no inputs, boots to test mode first time, endless reboot loop after that
+GAME( 2005, touryuu,  0, touryuu, touryuu, touryuu, ROT0, "Yuki Enterprise", "Touryuumon (V1.1)?", GAME_NO_SOUND ) // On first boot inputs won't work, TODO: hook-up default eeprom
diff -Nru src-old/mame/drivers/igs009.c src/mame/drivers/igs009.c
--- src-old/mame/drivers/igs009.c	2012-05-14 17:19:40.000000000 +0200
+++ src/mame/drivers/igs009.c	2012-06-23 18:32:56.000000000 +0200
@@ -1,8 +1,8 @@
 /***************************************************************************
 
-                      -= IGS009 Based Games =-
+                          -= IGS009 Based Games =-
 
-                        driver by Luca Elia
+                   driver by Luca Elia and David Haywood
 
 CPU     :   Z180
 Sound   :   M6295 + YM2413
@@ -13,6 +13,13 @@
   The interesting part is the background tilemap, that is designed specifically
   for simulating the nine reels of a slot machine.
 
+----------------------------------------------------------------------
+Year  Game                Manufacturer    Notes
+----------------------------------------------------------------------
+1995? Jingle Bell         IGS
+1998  Grand Prix '98      Romtec          1 reel gfx rom is bad
+----------------------------------------------------------------------
+
 ***************************************************************************/
 
 #include "emu.h"
@@ -269,7 +276,6 @@
 	state->m_gp98_reel2_tilemap->set_scroll_cols(128);
 	state->m_gp98_reel3_tilemap->set_scroll_cols(128);
 	state->m_gp98_reel4_tilemap->set_scroll_cols(128);
-
 }
 
 
@@ -507,42 +513,98 @@
 	PORT_DIPNAME( 0x02, 0x00, "W-Up Bonus" )
 	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )	// it's shown in attract mode
-	PORT_DIPUNKNOWN( 0x04, 0x04 )
-	PORT_DIPUNKNOWN( 0x08, 0x08 )
-	PORT_DIPUNKNOWN( 0x10, 0x10 )
-	PORT_DIPUNKNOWN( 0x20, 0x20 )
-	PORT_DIPUNKNOWN( 0x40, 0x40 )
-	PORT_DIPUNKNOWN( 0x80, 0x80 )
+	PORT_DIPNAME( 0x04, 0x04, "Min Bet" )
+	PORT_DIPSETTING(    0x04, "1" )
+	PORT_DIPSETTING(    0x00, "8" )
+	PORT_DIPNAME( 0x08, 0x08, "Spin Speed" )
+	PORT_DIPSETTING(    0x08, "Slow" )
+	PORT_DIPSETTING(    0x00, "Quick" )
+	PORT_DIPNAME( 0x10, 0x00, "Strip Girl" )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, "Payout Mode" )
+	PORT_DIPSETTING(    0x20, DEF_STR( Normal ) )
+	PORT_DIPSETTING(    0x00, "Auto" )
+	PORT_DIPNAME( 0xc0, 0xc0, "Player's Panel" )
+	PORT_DIPSETTING(    0x00, "Type A" )
+	PORT_DIPSETTING(    0xc0, "Type A" )
+	PORT_DIPSETTING(    0x80, "Type B" )
+	PORT_DIPSETTING(    0x40, "Type C" )
 
 	PORT_START("DSW2")
-	PORT_DIPUNKNOWN( 0x01, 0x01 )
-	PORT_DIPUNKNOWN( 0x02, 0x02 )
-	PORT_DIPUNKNOWN( 0x04, 0x04 )
-	PORT_DIPUNKNOWN( 0x08, 0x08 )
-	PORT_DIPUNKNOWN( 0x10, 0x10 )
-	PORT_DIPUNKNOWN( 0x20, 0x20 )
-	PORT_DIPUNKNOWN( 0x40, 0x40 )
-	PORT_DIPUNKNOWN( 0x80, 0x80 )
+	PORT_DIPNAME( 0x07, 0x07, "Main Game Rate (%)" )
+	PORT_DIPSETTING(    0x07, "89" )
+	PORT_DIPSETTING(    0x06, "90" )
+	PORT_DIPSETTING(    0x05, "91" )
+	PORT_DIPSETTING(    0x04, "92" )
+	PORT_DIPSETTING(    0x03, "93" )
+	PORT_DIPSETTING(    0x02, "94" )
+	PORT_DIPSETTING(    0x01, "95" )
+	PORT_DIPSETTING(    0x00, "96" )
+	PORT_DIPNAME( 0x38, 0x38, "W-Up Chance (%)" )
+	PORT_DIPSETTING(    0x38, "93" )
+	PORT_DIPSETTING(    0x30, "94" )
+	PORT_DIPSETTING(    0x28, "95" )
+	PORT_DIPSETTING(    0x20, "96" )
+	PORT_DIPSETTING(    0x18, "97" )
+	PORT_DIPSETTING(    0x10, "98" )
+	PORT_DIPSETTING(    0x08, "99" )
+	PORT_DIPSETTING(    0x00, "100" )
+	PORT_DIPNAME( 0xc0, 0xc0, "Key In Limit" )
+	PORT_DIPSETTING(    0xc0, "1k" )
+	PORT_DIPSETTING(    0x80, "3k" )
+	PORT_DIPSETTING(    0x40, "5k" )
+	PORT_DIPSETTING(    0x00, "10k" )
 
 	PORT_START("DSW3")
-	PORT_DIPUNKNOWN( 0x01, 0x01 )
-	PORT_DIPUNKNOWN( 0x02, 0x02 )
-	PORT_DIPUNKNOWN( 0x04, 0x04 )
-	PORT_DIPUNKNOWN( 0x08, 0x08 )
-	PORT_DIPUNKNOWN( 0x10, 0x10 )
-	PORT_DIPUNKNOWN( 0x20, 0x20 )
-	PORT_DIPUNKNOWN( 0x40, 0x40 )
-	PORT_DIPUNKNOWN( 0x80, 0x80 )
+	PORT_DIPNAME( 0x07, 0x07, "Key In Rate" )
+	PORT_DIPSETTING(    0x07, "1" )
+	PORT_DIPSETTING(    0x06, "5" )
+	PORT_DIPSETTING(    0x05, "10" )
+	PORT_DIPSETTING(    0x04, "30" )
+	PORT_DIPSETTING(    0x03, "50" )
+	PORT_DIPSETTING(    0x02, "100" )
+	PORT_DIPSETTING(    0x01, "200" )
+	PORT_DIPSETTING(    0x00, "500" )
+	PORT_DIPNAME( 0x38, 0x38, "Coin 1 Rate" )
+	PORT_DIPSETTING(    0x38, "1" )
+	PORT_DIPSETTING(    0x30, "2" )
+	PORT_DIPSETTING(    0x28, "5" )
+	PORT_DIPSETTING(    0x20, "10" )
+	PORT_DIPSETTING(    0x18, "20" )
+	PORT_DIPSETTING(    0x10, "25" )
+	PORT_DIPSETTING(    0x08, "50" )
+	PORT_DIPSETTING(    0x00, "100" )
+	PORT_DIPNAME( 0xc0, 0xc0, "System Limit" )
+	PORT_DIPSETTING(    0xc0, "5k" )
+	PORT_DIPSETTING(    0x80, "10k" )
+	PORT_DIPSETTING(    0x40, "30k" )
+	PORT_DIPSETTING(    0x00, "50k" )
 
 	PORT_START("DSW4")
-	PORT_DIPUNKNOWN( 0x01, 0x01 )
-	PORT_DIPUNKNOWN( 0x02, 0x02 )
-	PORT_DIPUNKNOWN( 0x04, 0x04 )
-	PORT_DIPUNKNOWN( 0x08, 0x08 )
-	PORT_DIPUNKNOWN( 0x10, 0x10 )
-	PORT_DIPUNKNOWN( 0x20, 0x20 )
-	PORT_DIPUNKNOWN( 0x40, 0x40 )
-	PORT_DIPUNKNOWN( 0x80, 0x80 )
+	PORT_DIPNAME( 0x01, 0x01, "Min Play For Fever" )
+	PORT_DIPSETTING(    0x01, "8" )
+	PORT_DIPSETTING(    0x00, "16" )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, "16" )
+	PORT_DIPSETTING(    0x00, "32" )
+	PORT_DIPNAME( 0x1c, 0x1c, "Coin 2 Rate" )
+	PORT_DIPSETTING(    0x1c, "1" )
+	PORT_DIPSETTING(    0x18, "2" )
+	PORT_DIPSETTING(    0x14, "5" )
+	PORT_DIPSETTING(    0x10, "10" )
+	PORT_DIPSETTING(    0x0c, "20" )
+	PORT_DIPSETTING(    0x08, "40" )
+	PORT_DIPSETTING(    0x04, "50" )
+	PORT_DIPSETTING(    0x00, "100" )
+	PORT_DIPNAME( 0x60, 0x60, "Key Out Rate" )
+	PORT_DIPSETTING(    0x60, "1" )
+	PORT_DIPSETTING(    0x40, "10" )
+	PORT_DIPSETTING(    0x20, "50" )
+	PORT_DIPSETTING(    0x00, "100" )
+	PORT_DIPNAME( 0x80, 0x80, "Play Line" )
+	PORT_DIPSETTING(    0x80, "8" )
+	PORT_DIPSETTING(    0x00, "16" )
 
 	PORT_START("DSW5")
 	PORT_DIPUNKNOWN( 0x01, 0x01 )
@@ -556,40 +618,40 @@
 
 	PORT_START("SERVICE")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SERVICE1 ) PORT_NAME("Memory Clear")	// stats, memory
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SERVICE1 )      PORT_NAME("Memory Clear")	// stats, memory
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF,igs009_state,hopper_r, (void *)0 )	// hopper sensor
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_GAMBLE_PAYOUT ) PORT_NAME("Pay Out")
 	PORT_SERVICE_NO_TOGGLE( 0x20, IP_ACTIVE_LOW )	// test (press during boot)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_GAMBLE_BOOK ) PORT_NAME("Records")
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_GAMBLE_BOOK )   PORT_NAME("Records")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN  )
 
 	PORT_START("COINS")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_GAMBLE_KEYIN )
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1         )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN       )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN2         )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_GAMBLE_KEYIN  )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_GAMBLE_KEYOUT ) PORT_NAME("Key Down")	// pays out
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("BUTTONS1")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SLOT_STOP1 )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SLOT_STOP2 )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SLOT_STOP3 )
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_CODE(KEYCODE_V) PORT_NAME("Stop")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SLOT_STOP1    )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SLOT_STOP2    )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SLOT_STOP3    )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_SLOT_STOP_ALL )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("BUTTONS2")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1  ) PORT_NAME("Start / H_Dup")
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_GAMBLE_LOW ) PORT_NAME("Small")
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("Left Bet / H_Dup")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1      ) PORT_NAME("Start / H_Dup")
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_GAMBLE_LOW  ) PORT_NAME("Small")
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON1     ) PORT_NAME("Left Bet / D_Dup")
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_GAMBLE_TAKE )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("Right Bet / Dup")
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON2     ) PORT_NAME("Right Bet / Dup")
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_GAMBLE_HIGH ) PORT_NAME("Big")
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -626,8 +688,8 @@
 };
 
 static GFXDECODE_START( jingbell )
-	GFXDECODE_ENTRY( "gfx1", 0, layout_8x32x6, 0, 16 )
-	GFXDECODE_ENTRY( "gfx2", 0, layout_8x8x6,  0, 16 )
+	GFXDECODE_ENTRY( "reels", 0, layout_8x32x6, 0, 16 )
+	GFXDECODE_ENTRY( "tiles", 0, layout_8x8x6,  0, 16 )
 GFXDECODE_END
 
 static const gfx_layout tiles8x8_layout =
@@ -637,7 +699,7 @@
 	6,
 	{ RGN_FRAC(2,3)+0, RGN_FRAC(2,3)+1, RGN_FRAC(1,3)+0, RGN_FRAC(1,3)+1, RGN_FRAC(0,3)+0, RGN_FRAC(0,3)+1 },
 	{ 8,10,12,14, 0, 2, 4, 6, },
-	{ 0*16, 1*16, 2*16, 3*16, 4*16, 5*16, 6*16, 7*16 },
+	{ STEP8(0,16) },
 	16*8
 };
 
@@ -648,13 +710,13 @@
 	6,
 	{ RGN_FRAC(2,3)+0, RGN_FRAC(2,3)+1, RGN_FRAC(1,3)+0, RGN_FRAC(1,3)+1, RGN_FRAC(0,3)+0, RGN_FRAC(0,3)+1 },
 	{ 8,10,12,14, 0, 2, 4, 6, },
-	{ 0*16, 1*16, 2*16, 3*16, 4*16, 5*16, 6*16, 7*16,8*16,9*16,10*16,11*16,12*16,13*16,14*16,15*16,16*16,17*16,18*16,19*16,20*16,21*16,22*16,23*16,24*16,25*16,26*16,27*16,28*16,29*16,30*16,31*16 },
+	{ STEP32(0,16) },
 	32*16
 };
 
 static GFXDECODE_START( gp98 )
-	GFXDECODE_ENTRY( "gfx1", 0, tiles8x32_layout, 0, 16 )
-	GFXDECODE_ENTRY( "gfx2", 0, tiles8x8_layout, 0, 16 )
+	GFXDECODE_ENTRY( "reels", 0, tiles8x32_layout, 0, 16 )
+	GFXDECODE_ENTRY( "tiles", 0, tiles8x8_layout, 0, 16 )
 GFXDECODE_END
 
 
@@ -720,7 +782,7 @@
 /***************************************************************************
 
 Jingle Bell
-(C) 1998 IGS
+(C) IGS ("COPYRIGHT 1995" in ROM, "FEB. 23 1998" on sticker)
 
 CPU:
     1x HD64180RP8 (u18)(main)
@@ -760,12 +822,12 @@
 	ROM_REGION( 0x8000, "data", 0 )
 	ROM_LOAD( "jingle133i7.u43", 0x0000, 0x8000, CRC(a7affa15) SHA1(f9d33e32b57ad267d383e075663994e0af0b3016) )
 
-	ROM_REGION( 0x30000, "gfx1", 0 )
+	ROM_REGION( 0x30000, "reels", 0 )
 	ROM_LOAD( "jingle133i1.u17", 0x00000, 0x10000, CRC(cadd7910) SHA1(aa514ddb29c8c9a77478d56bea4ae71995fdd518) )
 	ROM_LOAD( "jingle133i2.u16", 0x10000, 0x10000, CRC(a9e1f5aa) SHA1(68d7f4e9e9a5bbce0904e406ee6fe82e9e52a9ba) )
 	ROM_LOAD( "jingle133i3.u15", 0x20000, 0x10000, CRC(865b7d3a) SHA1(c1dff3a27d747ee499aaee0c4468534f0249a3e5) )
 
-	ROM_REGION( 0xc0000, "gfx2", 0 )
+	ROM_REGION( 0xc0000, "tiles", 0 )
 	ROM_LOAD( "jingle133i4.u25", 0x00000, 0x40000, CRC(7aa1d344) SHA1(141e27df93cb35ab852d9022e0b08bd596f1186b) )
 	ROM_LOAD( "jingle133i5.u24", 0x40000, 0x40000, CRC(021261d1) SHA1(5b23f9bd818193c343f9f4c9317955b17efb8cfa) )
 	ROM_LOAD( "jingle133i6.u23", 0x80000, 0x40000, CRC(c40228fd) SHA1(4dc05337d64ed2b8d66fc5f0ca8ffbf96799f768) )
@@ -809,6 +871,39 @@
 	rom[0x01f19] = 0x18;
 }
 
+/***************************************************************************
+
+Grand Prix '98
+
+PCB Layout
+----------
+
+|-----------------------------------------|
+|                 YM2413       DSW2  DSW4 |
+|                 3.579545MHz             |
+|   Z180                       DSW1  DSW3 |
+|                 PAL                     |
+|     PRG                                 |
+|   12MHz                                 |
+|J                   51        |-------|  |
+|A    6264                     |PLCC84 |  |
+|M                   50        |FPGA   |  |
+|M                             |       |  |
+|A                   49        |-------|  |
+|                                         |
+|                                         |
+|                                         |
+|                   6264                  |
+|                                         |
+|          62256                          |
+|-----------------------------------------|
+Z180 @ 12MHz
+YM2413 @ 3.579545MHz
+VSync 60Hz
+HSync 15.35kHz
+
+***************************************************************************/
+
 ROM_START( gp98 )
 	ROM_REGION( 0x20000, "maincpu", 0 )
 	ROM_LOAD( "prg", 0x00000, 0x20000, CRC(1c02b8cc) SHA1(b8a29cbd96581f8ae1c1028279b8ee703be29f5f) )
@@ -821,20 +916,19 @@
 	ROM_LOAD( "50", 0x080000, 0x80000, CRC(48f6190d) SHA1(b430131a258b4e2fc178ac0e3e3f0010a82eac65) )
 	ROM_LOAD( "51", 0x100000, 0x80000, CRC(30a2ef85) SHA1(38ea637acd83b175eccd2969ef21879265b88992) )
 
-	ROM_REGION( 0xc0000, "gfx1", 0 )
+	ROM_REGION( 0xc0000, "reels", 0 )
 	ROM_COPY( "tempgfx", 0x000000, 0x00000, 0x40000 )
 	ROM_COPY( "tempgfx", 0x080000, 0x40000, 0x40000 )
 	ROM_COPY( "tempgfx", 0x100000, 0x80000, 0x40000 )
 
-	ROM_REGION( 0xc0000, "gfx2", 0 )
+	ROM_REGION( 0xc0000, "tiles", 0 )
 	ROM_COPY( "tempgfx", 0x040000, 0x00000, 0x40000 )
 	ROM_COPY( "tempgfx", 0x0c0000, 0x40000, 0x40000 )
 	ROM_COPY( "tempgfx", 0x140000, 0x80000, 0x40000 )
 
-
 	ROM_REGION( 0x40000, "oki", ROMREGION_ERASE00 )
-	/* no OKI on this */
+	// no OKI on this
 ROM_END
 
-GAME( 1995?, jingbell, 0, jingbell, jingbell, jingbell, ROT0, "IGS", "Jingle Bell (Italy, V133I)", GAME_NOT_WORKING | GAME_IMPERFECT_GRAPHICS | GAME_UNEMULATED_PROTECTION )
-GAME( 1998,  gp98,     0,     gp98, jingbell,        0, ROT0, "Romtec Co. Ltd", "Grand Prix '98",GAME_NOT_WORKING| GAME_NO_SOUND )
+GAME( 1995?, jingbell, 0, jingbell, jingbell, jingbell, ROT0, "IGS",            "Jingle Bell (Italy, V133I)", 0 )
+GAME( 1998,  gp98,     0, gp98,     jingbell, 0,        ROT0, "Romtec Co. Ltd", "Grand Prix '98 (V100K)",     GAME_NOT_WORKING | GAME_IMPERFECT_GRAPHICS )
diff -Nru src-old/mame/drivers/igs011.c src/mame/drivers/igs011.c
--- src-old/mame/drivers/igs011.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/igs011.c	2012-07-02 09:06:11.000000000 +0200
@@ -32,13 +32,13 @@
 96 Long Hu Bang II V185H   NO-0115    M6295 YM2413  IGS011 8255
 96 Wan Li Chang Cheng      ?
 96 Xing Yen Man Guan       ?
-98 Mj Nenrikishu SP        NO-0115-5  M6295 YM2413  IGS011 8255
+98 Mj Nenrikishu SP V250J  NO-0115-5  M6295 YM2413  IGS011 8255
 ---------------------------------------------------------------------------
 
 To do:
 
 - Implement the I/O part of IGS003 as an 8255
-- IGS003 parametric bitswap protection in lhb2, vbowl (instead of patching the roms)
+- IGS003 parametric bitswap protection in lhb2, nkishusp, vbowl (instead of patching the roms)
 - Interrupt controller at 838000 or a38000 (there's a preliminary implementation for lhb)
 - A few graphical bugs
 
@@ -432,12 +432,13 @@
 					blitter.x,blitter.y,blitter.w,blitter.h,blitter.gfx_hi,blitter.gfx_lo,blitter.depth,blitter.pen,blitter.flags);
 #endif
 
-	dest	=	m_layer[	   blitter.flags & 0x0007	];
+	dest	=	m_layer[   blitter.flags & 0x0007	];
 	opaque	=			 !(blitter.flags & 0x0008);
 	clear	=			   blitter.flags & 0x0010;
 	flipx	=			   blitter.flags & 0x0020;
 	flipy	=			   blitter.flags & 0x0040;
-	if					(!(blitter.flags & 0x0400)) return;
+	if					(!(blitter.flags & 0x0400))
+		return;
 
 	pen_hi	=	(m_lhb2_pen_hi & 0x07) << 5;
 
@@ -544,7 +545,8 @@
 	for (i = 0; i < NUM; i++)
 		if ((~m_igs_dips_sel) & (1 << i) )
 			ret = ioport(dipnames[i])->read();
-	/* 0x0100 is blitter busy */
+
+	// 0x0100 is blitter busy
 	return	(ret & 0xff) | 0x0000;
 }
 
@@ -729,18 +731,9 @@
 }
 
 
-// To be done (similar to lhb2?)
+// xor similar to ryukobou (both sets are Japan), address scrambling from lhb2
 static void nkishusp_decrypt(running_machine &machine)
 {
-//  lhb_decrypt(machine);
-//  dbc_decrypt(machine);
-//  lhb2_decrypt(machine);
-//  drgnwrld_type1_decrypt(machine);
-//  drgnwrld_type2_decrypt(machine);
-//  drgnwrld_type3_decrypt(machine);
-//  wlcc_decrypt(machine);
-//  vbowlj_decrypt(machine);
-
 	int i,j;
 	int rom_size = 0x80000;
 	UINT16 *src = (UINT16 *) (machine.root_device().memregion("maincpu")->base());
@@ -750,16 +743,24 @@
 	{
 		UINT16 x = src[i];
 
-		if ((i & 0x0054) != 0x0000 && (i & 0x0056) != 0x0010)
-			x ^= 0x0004;
+		// lhb2 address scrambling
+		j = BITSWAP24(i, 23,22,21,20,19,18,17,16,15,14,13, 8, 11,10, 9, 2, 7,6,5,4,3, 12, 1,0);
 
-//      if ((i & 0x0204) == 0x0000)
-//          x ^= 0x0008;
+		// ryukobou xor:
 
-		if ((i & 0x3080) != 0x3080 && (i & 0x3090) != 0x3010)
+//      if ( (j & 0x00100) && (j & 0x00400) )
+//          x ^= 0x0200;
+
+		if ( !(j & 0x00004) || !(j & 0x02000) || (!(j & 0x00080) && !(j & 0x00010) ) )
 			x ^= 0x0020;
 
-		j = BITSWAP24(i, 23,22,21,20,19,18,17,16,15,14,13, 8, 11,10, 9, 2, 7,6,5,4,3, 12, 1,0);
+		if ( (j & 0x00100) || (j & 0x00040) || ( (j & 0x00010)&&(j & 0x00002) ) )
+			x ^= 0x00004;
+
+		// additional xor:
+
+		if ( !(j & 0x4000) && (j & 0x1000) && (j & 0x00200) )
+			x ^= 0x0008;
 
 		result_data[j] = x;
 	}
@@ -1961,6 +1962,7 @@
 /*
     // PROTECTION CHECKS
     rom[0x04c42/2]  =   0x602e;     // 004C42: 6604         bne 4c48  (rom test error otherwise)
+
     rom[0x08694/2]  =   0x6008;     // 008694: 6408         bcc 869e  (fills screen with characters otherwise)
     rom[0x0a05e/2]  =   0x4e71;     // 00A05E: 6408         bcc a068  (fills screen with characters otherwise)
     rom[0x0bec2/2]  =   0x6008;     // 00BEC2: 6408         bcc becc  (fills screen with characters otherwise)
@@ -2062,6 +2064,7 @@
 	// PROTECTION CHECKS
 	rom[0x034f4/2]	=	0x4e71;		// 0034F4: 660E    bne 3504   (rom test, fills palette with white otherwise)
 	rom[0x03502/2]	=	0x6032;		// 003502: 6732    beq 3536   (rom test, fills palette with white otherwise)
+
 	rom[0x1afea/2]	=	0x6034;		// 01AFEA: 6734    beq 1b020  (fills palette with black otherwise)
 //  rom[0x24b8a/2]  =   0x6036;     // 024B8A: 6736    beq 24bc2  (fills palette with green otherwise)
 //  rom[0x29ef8/2]  =   0x6036;     // 029EF8: 6736    beq 29f30  (fills palette with red otherwise)
@@ -2123,9 +2126,31 @@
 
 static DRIVER_INIT( nkishusp )
 {
+	UINT16 *rom = (UINT16 *) machine.root_device().memregion("maincpu")->base();
+
 	nkishusp_decrypt(machine);
+	lhb2_decrypt_gfx(machine);
 
-	// PROTECTION CHECKS (similar to lhb2?)
+	// PROTECTION CHECKS (similar to lhb2)
+
+	rom[0x03624/2]	=	0x6042;		// 003624: 660E      bne     $3634 (ROM test)
+
+	rom[0x1a9d2/2]	=	0x6034;		// 01A9D2: 6734      beq     $1aa08
+	rom[0x26306/2]	=	0x6036;		// 026306: 6736      beq     $2633e
+	rom[0x29190/2]	=	0x6038;		// 029190: 6E38      bgt     $291ca (system error)
+	rom[0x2b82a/2]	=	0x6036;		// 02B82A: 6736      beq     $2b862
+	rom[0x2ff20/2]	=	0x6036;		// 02FF20: 6736      beq     $2ff58
+	rom[0x3151c/2]	=	0x6036;		// 03151C: 6736      beq     $31554
+	rom[0x33dfc/2]	=	0x6036;		// 033DFC: 6736      beq     $33e34
+	rom[0x3460e/2]	=	0x6038;		// 03460E: 6E38      bgt     $34648 (system error)
+	rom[0x3f09e/2]	=	0x6034;		// 03F09E: 6734      beq     $3f0d4
+	rom[0x406a8/2]	=	0x6036;		// 0406A8: 6736      beq     $406e0
+	rom[0x4376a/2]	=	0x6034;		// 04376A: 6734      beq     $437a0
+	rom[0x462d6/2]	=	0x6034;		// 0462D6: 6734      beq     $4630c
+	rom[0x471ec/2]	=	0x6036;		// 0471EC: 6E36      bgt     $47224 (system error)
+	rom[0x49c46/2]	=	0x6000;		// 049C46: 6700 0444 beq     $4a08c
+	rom[0x4a2b6/2]	=	0x6036;		// 04A2B6: 6736      beq     $4a2ee
+	rom[0x4c67a/2]	=	0x6038;		// 04C67A: 6E38      bgt     $4c6b4 (system error)
 }
 
 
@@ -2262,7 +2287,7 @@
 	AM_RANGE( 0x010000, 0x010001 ) AM_WRITE(lhb_okibank_w )
 
 	AM_RANGE( 0x010200, 0x0103ff ) AM_WRITE(igs011_prot2_inc_w			)	// inc  (33)
-	AM_RANGE( 0x010400, 0x0105ff ) AM_WRITE(lhb_igs011_prot2_swap_w	)	// swap (33)
+	AM_RANGE( 0x010400, 0x0105ff ) AM_WRITE(lhb_igs011_prot2_swap_w		)	// swap (33)
 	AM_RANGE( 0x010600, 0x0107ff ) AM_READ(lhb_igs011_prot2_r			)	// read
 	// no reset
 
@@ -2300,7 +2325,7 @@
 
 	AM_RANGE( 0x518000, 0x5181ff ) AM_WRITE(igs011_prot2_inc_w			)	// inc   (33)
 	AM_RANGE( 0x518200, 0x5183ff ) AM_WRITE(wlcc_igs011_prot2_swap_w	)	// swap  (33)
-	AM_RANGE( 0x518800, 0x5189ff ) AM_READ(igs011_prot2_reset_r		)	// reset
+	AM_RANGE( 0x518800, 0x5189ff ) AM_READ(igs011_prot2_reset_r			)	// reset
 	AM_RANGE( 0x519000, 0x5195ff ) AM_READ(lhb_igs011_prot2_r			)	// read
 
 	AM_RANGE( 0x000000, 0x07ffff ) AM_ROM
@@ -2338,8 +2363,8 @@
 //  AM_RANGE( 0x01ff88, 0x01ff89 ) AM_READ ( igs011_prot1_r )
 
 	AM_RANGE( 0x020000, 0x0201ff ) AM_WRITE(igs011_prot2_inc_w			)	// inc   (55)
-	AM_RANGE( 0x020200, 0x0203ff ) AM_WRITE(lhb_igs011_prot2_swap_w	)	// swap  (33)
-	AM_RANGE( 0x020400, 0x0205ff ) AM_READ(lhb2_igs011_prot2_r		)	// read
+	AM_RANGE( 0x020200, 0x0203ff ) AM_WRITE(lhb_igs011_prot2_swap_w		)	// swap  (33)
+	AM_RANGE( 0x020400, 0x0205ff ) AM_READ(lhb2_igs011_prot2_r			)	// read
 	AM_RANGE( 0x020600, 0x0207ff ) AM_WRITE(igs011_prot2_reset_w		)	// reset (55)
 
 	AM_RANGE( 0x000000, 0x07ffff ) AM_ROM
@@ -2370,6 +2395,50 @@
 	AM_RANGE( 0xa88000, 0xa88001 ) AM_READ(igs_3_dips_r )
 ADDRESS_MAP_END
 
+
+
+static ADDRESS_MAP_START( nkishusp, AS_PROGRAM, 16, igs011_state )
+//  nkishusp: IGS011 protection dynamically mapped at 1ff8x
+//  AM_RANGE( 0x01ff80, 0x01ff87 ) AM_WRITE(igs011_prot1_w )
+//  AM_RANGE( 0x01ff88, 0x01ff89 ) AM_READ ( igs011_prot1_r )
+
+	// to be done:
+	AM_RANGE( 0x023000, 0x0231ff ) AM_WRITE(igs011_prot2_inc_w			)	// inc   (55)
+	AM_RANGE( 0x023200, 0x0233ff ) AM_WRITE(lhb_igs011_prot2_swap_w		)	// swap  (33)
+	AM_RANGE( 0x023400, 0x0235ff ) AM_READ(lhb2_igs011_prot2_r			)	// read
+	AM_RANGE( 0x023600, 0x0237ff ) AM_WRITE(igs011_prot2_reset_w		)	// reset (55)
+
+	AM_RANGE( 0x000000, 0x07ffff ) AM_ROM
+	AM_RANGE( 0x100000, 0x103fff ) AM_RAM AM_SHARE("nvram")
+	AM_RANGE( 0x200000, 0x200001 ) AM_DEVREADWRITE8("oki", okim6295_device, read, write, 0x00ff )
+	AM_RANGE( 0x204000, 0x204003 ) AM_DEVWRITE8_LEGACY("ymsnd", ym2413_w, 0x00ff )
+	AM_RANGE( 0x208000, 0x208003 ) AM_WRITE(lhb2_igs003_w )
+	AM_RANGE( 0x208002, 0x208003 ) AM_READ(lhb2_igs003_r )
+	AM_RANGE( 0x20c000, 0x20cfff ) AM_RAM AM_SHARE("priority_ram")
+	AM_RANGE( 0x210000, 0x211fff ) AM_RAM_WRITE(igs011_palette ) AM_SHARE("paletteram")
+	AM_RANGE( 0x214000, 0x214001 ) AM_READ_PORT( "COIN" )
+	AM_RANGE( 0x300000, 0x3fffff ) AM_READWRITE(igs011_layers_r, igs011_layers_w )
+	AM_RANGE( 0xa20000, 0xa20001 ) AM_WRITE(igs011_priority_w )
+	AM_RANGE( 0xa38000, 0xa38001 ) AM_WRITE(lhb_irq_enable_w )
+	AM_RANGE( 0xa40000, 0xa40001 ) AM_WRITE(igs_dips_w )
+
+	AM_RANGE( 0xa50000, 0xa50001 ) AM_WRITE(igs011_prot_addr_w )
+//  AM_RANGE( 0xa50000, 0xa50005 ) AM_READ(igs011_prot_fake_r )
+
+	AM_RANGE( 0xa58000, 0xa58001 ) AM_WRITE(igs011_blit_x_w )
+	AM_RANGE( 0xa58800, 0xa58801 ) AM_WRITE(igs011_blit_y_w )
+	AM_RANGE( 0xa59000, 0xa59001 ) AM_WRITE(igs011_blit_w_w )
+	AM_RANGE( 0xa59800, 0xa59801 ) AM_WRITE(igs011_blit_h_w )
+	AM_RANGE( 0xa5a000, 0xa5a001 ) AM_WRITE(igs011_blit_gfx_lo_w )
+	AM_RANGE( 0xa5a800, 0xa5a801 ) AM_WRITE(igs011_blit_gfx_hi_w )
+	AM_RANGE( 0xa5b000, 0xa5b001 ) AM_WRITE(igs011_blit_flags_w )
+	AM_RANGE( 0xa5b800, 0xa5b801 ) AM_WRITE(igs011_blit_pen_w )
+	AM_RANGE( 0xa5c000, 0xa5c001 ) AM_WRITE(igs011_blit_depth_w )
+	AM_RANGE( 0xa88000, 0xa88001 ) AM_READ(igs_3_dips_r )
+ADDRESS_MAP_END
+
+
+
 /* trap15's note:
  * TODO: change this horrible device-> chain to be proper.
  */
@@ -2450,12 +2519,12 @@
 	AM_RANGE( 0x00d400, 0x00d43f ) AM_WRITE(igs011_prot2_dec_w				)	// dec   (33)
 	AM_RANGE( 0x00d440, 0x00d47f ) AM_WRITE(drgnwrld_igs011_prot2_swap_w	)	// swap  (33)
 	AM_RANGE( 0x00d480, 0x00d4bf ) AM_WRITE(igs011_prot2_reset_w			)	// reset (33)
-	AM_RANGE( 0x00d4c0, 0x00d4ff ) AM_READ(drgnwrldv20j_igs011_prot2_r	)	// read
+	AM_RANGE( 0x00d4c0, 0x00d4ff ) AM_READ(drgnwrldv20j_igs011_prot2_r		)	// read
 
 	AM_RANGE( 0x50f000, 0x50f1ff ) AM_WRITE(igs011_prot2_dec_w			)	// dec   (33)
 	AM_RANGE( 0x50f200, 0x50f3ff ) AM_WRITE(vbowl_igs011_prot2_swap_w	)	// swap  (33)
 	AM_RANGE( 0x50f400, 0x50f5ff ) AM_WRITE(igs011_prot2_reset_w		)	// reset (33)
-	AM_RANGE( 0x50f600, 0x50f7ff ) AM_READ(vbowl_igs011_prot2_r		)	// read
+	AM_RANGE( 0x50f600, 0x50f7ff ) AM_READ(vbowl_igs011_prot2_r			)	// read
 
 	AM_RANGE( 0x902000, 0x902fff ) AM_WRITE(igs012_prot_reset_w	)	// reset?
 //  AM_RANGE( 0x902000, 0x902005 ) AM_WRITE(igs012_prot_fake_r )
@@ -2800,13 +2869,13 @@
 	PORT_DIPSETTING(    0x02, "70" )
 	PORT_DIPSETTING(    0x01, "74" )
 	PORT_DIPSETTING(    0x00, "78" )
-	PORT_DIPNAME( 0x08, 0x08, "Odds Rate" )
-	PORT_DIPSETTING(    0x08, "1,2,3,5,8,15,30,50" )
+	PORT_DIPNAME( 0x08, 0x00, "Odds Rate" )
 	PORT_DIPSETTING(    0x00, "1,2,3,4,5,6,7,8" )
-	PORT_DIPNAME( 0x10, 0x10, "Max Bet" )
+	PORT_DIPSETTING(    0x08, "1,2,3,5,8,15,30,50" )
+	PORT_DIPNAME( 0x10, 0x00, "Max Bet" )
 	PORT_DIPSETTING(    0x00, "5" )
 	PORT_DIPSETTING(    0x10, "10" )
-	PORT_DIPNAME( 0x60, 0x60, "Min Credits To Start" )
+	PORT_DIPNAME( 0x60, 0x60, "Min Bet" )
 	PORT_DIPSETTING(    0x60, "1" )
 	PORT_DIPSETTING(    0x40, "2" )
 	PORT_DIPSETTING(    0x20, "3" )
@@ -2920,6 +2989,136 @@
 INPUT_PORTS_END
 
 
+static INPUT_PORTS_START( nkishusp )
+	PORT_START("DSW1")
+	PORT_DIPNAME( 0x07, 0x02, "Pay Out (%)" )
+	PORT_DIPSETTING(    0x07, "74" )
+	PORT_DIPSETTING(    0x06, "77" )
+	PORT_DIPSETTING(    0x05, "80" )
+	PORT_DIPSETTING(    0x04, "83" )
+	PORT_DIPSETTING(    0x03, "86" )
+	PORT_DIPSETTING(    0x02, "89" )
+	PORT_DIPSETTING(    0x01, "92" )
+	PORT_DIPSETTING(    0x00, "95" )
+	PORT_DIPNAME( 0x08, 0x00, "Odds Rate" )
+	PORT_DIPSETTING(    0x00, "1,2,3,4,5,6,7,8" )
+	PORT_DIPSETTING(    0x08, "1,2,3,5,8,15,30,50" )
+	PORT_DIPNAME( 0x10, 0x00, "Max Bet" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPSETTING(    0x10, "10" )
+	PORT_DIPNAME( 0x60, 0x60, "Min Bet" )
+	PORT_DIPSETTING(    0x60, "1" )
+	PORT_DIPSETTING(    0x40, "2" )
+	PORT_DIPSETTING(    0x20, "3" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x80, 0x00, "Credit Timer" )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW2")
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coinage ) )	// Only when bit 3 = 1
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )
+	PORT_DIPNAME( 0x04, 0x04, "Credits Per Note" )	// Only when bit 3 = 0
+	PORT_DIPSETTING(    0x04, "10" )
+	PORT_DIPSETTING(    0x00, "100" )
+	PORT_DIPNAME( 0x08, 0x08, "Money Type" )	// Decides whether to use bits 0&1 or bit 2
+	PORT_DIPSETTING(    0x08, "Coins" )
+	PORT_DIPSETTING(    0x00, "Notes" )
+	PORT_DIPNAME( 0x10, 0x10, "Auto Play" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Demo_Sounds ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, "Undress Girl" )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPUNKNOWN( 0x80, 0x80 )
+
+	PORT_START("DSW3")
+	PORT_DIPNAME( 0x03, 0x03, "Credit Limit" )
+	PORT_DIPSETTING(    0x03, "500" )
+	PORT_DIPSETTING(    0x02, "1000" )
+	PORT_DIPSETTING(    0x01, "2000" )
+	PORT_DIPSETTING(    0x00, "30000" )
+	PORT_DIPUNKNOWN( 0x04, 0x04 )
+	PORT_DIPUNKNOWN( 0x08, 0x08 )
+	PORT_DIPNAME( 0x70, 0x70, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x70, "1 : 1" )
+	PORT_DIPSETTING(    0x60, "1 : 2" )
+	PORT_DIPSETTING(    0x50, "1 : 5" )
+	PORT_DIPSETTING(    0x40, "1 : 6" )
+	PORT_DIPSETTING(    0x30, "1 : 7" )
+	PORT_DIPSETTING(    0x20, "1 : 8" )
+	PORT_DIPSETTING(    0x10, "1 : 9" )
+	PORT_DIPSETTING(    0x00, "1 : 10" )
+	PORT_DIPUNKNOWN( 0x80, 0x80 )
+
+	PORT_START("COIN")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1    )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SERVICE1 )	// data clear
+	PORT_SERVICE_NO_TOGGLE( 0x04, IP_ACTIVE_LOW )	// keep pressed while booting
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, igs011_state,igs_hopper_r, (void *)0)	// hopper switch
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE2 )	// stats
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER    ) PORT_NAME("Pay Out") PORT_CODE(KEYCODE_O)	// clear coin
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN  )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN  )
+
+	PORT_START("KEY0")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_A )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_E )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_I )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_M )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_KAN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )	// ? set to 0 both
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )	// ? and you can't start a game
+
+	PORT_START("KEY1")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_B )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_F )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_J )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_N )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_REACH )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_BET )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("KEY2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_C )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_G )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_K )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_CHI )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_RON )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("KEY3")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_D )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_H )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_L )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_PON )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("KEY4")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+INPUT_PORTS_END
+
+
 static INPUT_PORTS_START( wlcc )
 	PORT_START("DSW1")
 	PORT_DIPUNKNOWN( 0x01, 0x01 )
@@ -2937,7 +3136,7 @@
 	PORT_DIPSETTING(    0x02, "1500" )
 	PORT_DIPSETTING(    0x01, "2000" )
 	PORT_DIPSETTING(    0x00, "3000" )
-	PORT_DIPNAME( 0x0c, 0x0c, "Min Credits To Start" )
+	PORT_DIPNAME( 0x0c, 0x0c, "Min Bet" )
 	PORT_DIPSETTING(    0x0c, "1" )
 	PORT_DIPSETTING(    0x08, "2" )
 	PORT_DIPSETTING(    0x04, "3" )
@@ -3029,7 +3228,7 @@
 	PORT_DIPSETTING(    0x20, "2" )
 	PORT_DIPSETTING(    0x10, "3" )
 	PORT_DIPSETTING(    0x00, "4" )
-	PORT_DIPNAME( 0xc0, 0xc0, "Max Bet" )
+	PORT_DIPNAME( 0xc0, 0x80, "Max Bet" )
 	PORT_DIPSETTING(    0xc0, "1" )
 	PORT_DIPSETTING(    0x80, "5" )
 	PORT_DIPSETTING(    0x40, "10" )
@@ -3041,7 +3240,7 @@
 	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )
-	PORT_DIPNAME( 0x0c, 0x0c, "Min Credits To Start" )
+	PORT_DIPNAME( 0x0c, 0x0c, "Min Bet" )
 	PORT_DIPSETTING(    0x0c, "1" )
 	PORT_DIPSETTING(    0x08, "2" )
 	PORT_DIPSETTING(    0x04, "3" )
@@ -3424,7 +3623,7 @@
 	PORT_DIPSETTING(    0x02, "1500" )
 	PORT_DIPSETTING(    0x01, "2000" )
 	PORT_DIPSETTING(    0x00, "3000" )
-	PORT_DIPNAME( 0x0c, 0x0c, "Min Credits To Start" )
+	PORT_DIPNAME( 0x0c, 0x0c, "Min Bet" )
 	PORT_DIPSETTING(    0x0c, "1" )
 	PORT_DIPSETTING(    0x08, "2" )
 	PORT_DIPSETTING(    0x04, "3" )
@@ -3610,7 +3809,7 @@
 MACHINE_CONFIG_END
 
 
-static TIMER_DEVICE_CALLBACK ( drgnworld_timer_irq_cb )
+static TIMER_DEVICE_CALLBACK ( lev5_timer_irq_cb )
 {
 	igs011_state *state = timer.machine().driver_data<igs011_state>();
 
@@ -3621,9 +3820,9 @@
 	MCFG_CPU_MODIFY("maincpu")
 	MCFG_CPU_PROGRAM_MAP(drgnwrld)
 	MCFG_CPU_VBLANK_INT("screen",irq6_line_hold)
-	MCFG_TIMER_ADD_PERIODIC("timer_irq", drgnworld_timer_irq_cb, attotime::from_hz(240)) // lev5 frequency drives the music tempo
+	MCFG_TIMER_ADD_PERIODIC("timer_irq", lev5_timer_irq_cb, attotime::from_hz(240)) // lev5 frequency drives the music tempo
 
-	MCFG_SOUND_ADD("ymsnd", YM3812, 3579545)
+	MCFG_SOUND_ADD("ymsnd", YM3812, XTAL_3_579545MHz)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 2.0)
 MACHINE_CONFIG_END
 
@@ -3662,7 +3861,7 @@
 
 
 
-static TIMER_DEVICE_CALLBACK ( wlcc_timer_irq_cb )
+static TIMER_DEVICE_CALLBACK ( lev3_timer_irq_cb )
 {
 	igs011_state *state = timer.machine().driver_data<igs011_state>();
 
@@ -3674,7 +3873,7 @@
 	MCFG_CPU_MODIFY("maincpu")
 	MCFG_CPU_PROGRAM_MAP(wlcc)
 	MCFG_CPU_VBLANK_INT("screen",irq6_line_hold)
-	MCFG_TIMER_ADD_PERIODIC("timer_irq", wlcc_timer_irq_cb, attotime::from_hz(240)) // lev3 frequency drives the music tempo
+	MCFG_TIMER_ADD_PERIODIC("timer_irq", lev3_timer_irq_cb, attotime::from_hz(240)) // lev3 frequency drives the music tempo
 MACHINE_CONFIG_END
 
 
@@ -3683,7 +3882,7 @@
 	MCFG_CPU_MODIFY("maincpu")
 	MCFG_CPU_PROGRAM_MAP(xymg)
 	MCFG_CPU_VBLANK_INT("screen",irq6_line_hold)
-	MCFG_TIMER_ADD_PERIODIC("timer_irq", wlcc_timer_irq_cb, attotime::from_hz(240)) // lev3 frequency drives the music tempo
+	MCFG_TIMER_ADD_PERIODIC("timer_irq", lev3_timer_irq_cb, attotime::from_hz(240)) // lev3 frequency drives the music tempo
 MACHINE_CONFIG_END
 
 
@@ -3692,11 +3891,27 @@
 	MCFG_CPU_MODIFY("maincpu")
 	MCFG_CPU_PROGRAM_MAP(lhb2)
 	MCFG_CPU_VBLANK_INT("screen",irq6_line_hold)
-	MCFG_TIMER_ADD_PERIODIC("timer_irq", drgnworld_timer_irq_cb, attotime::from_hz(240)) // lev5 frequency drives the music tempo
+	MCFG_TIMER_ADD_PERIODIC("timer_irq", lev5_timer_irq_cb, attotime::from_hz(240)) // lev5 frequency drives the music tempo
+
+//  MCFG_GFXDECODE(igs011_hi)
+
+	MCFG_SOUND_ADD("ymsnd", YM2413, XTAL_3_579545MHz)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 2.0)
+MACHINE_CONFIG_END
+
+
+
+static MACHINE_CONFIG_DERIVED( nkishusp, igs011_base )
+	MCFG_CPU_MODIFY("maincpu")
+	MCFG_CPU_PROGRAM_MAP(nkishusp)
+	MCFG_CPU_VBLANK_INT("screen",irq6_line_hold)
+	MCFG_TIMER_ADD_PERIODIC("timer_irq", lev3_timer_irq_cb, attotime::from_hz(240)) // lev3 frequency drives the music tempo
+
+	// VSync 60.0052Hz, HSync 15.620kHz
 
 //  MCFG_GFXDECODE(igs011_hi)
 
-	MCFG_SOUND_ADD("ymsnd", YM2413, 3579545)
+	MCFG_SOUND_ADD("ymsnd", YM2413, XTAL_3_579545MHz)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 2.0)
 MACHINE_CONFIG_END
 
@@ -3711,7 +3926,7 @@
 	MCFG_CPU_MODIFY("maincpu")
 	MCFG_CPU_PROGRAM_MAP(vbowl)
 	MCFG_CPU_VBLANK_INT("screen",irq6_line_hold)
-	MCFG_TIMER_ADD_PERIODIC("timer_irq", wlcc_timer_irq_cb, attotime::from_hz(240)) // lev3 frequency drives the music tempo
+	MCFG_TIMER_ADD_PERIODIC("timer_irq", lev3_timer_irq_cb, attotime::from_hz(240)) // lev3 frequency drives the music tempo
 	// irq 5 points to a debug function (all routines are clearly patched out)
 	// irq 4 points to an apparently unneeded routine
 
@@ -3985,9 +4200,9 @@
 	ROM_LOAD16_WORD_SWAP( "wlcc4096.rom", 0x00000, 0x80000, CRC(3b16729f) SHA1(4ef4e5cbd6ccc65775e36c2c8b459bc1767d6574) )
 	ROM_CONTINUE        (                 0x00000, 0x80000 ) // 1ST+2ND IDENTICAL
 
-	ROM_REGION( 0x280000, "blitter", ROMREGION_ERASE00 )
+	ROM_REGION( 0x280000, "blitter", 0 )
 	ROM_LOAD( "m0201-ig.160", 0x000000, 0x200000, CRC(ec54452c) SHA1(0ee7ffa3d4845af083944e64faf5a1c78247aaa2) )
-	ROM_LOAD( "wlcc.gfx",  0x200000, 0x080000, CRC(1f7ad299) SHA1(ab0a8fb31906519b9352ba172def48456e8d565c) )
+	ROM_LOAD( "wlcc.gfx",     0x200000, 0x080000, CRC(1f7ad299) SHA1(ab0a8fb31906519b9352ba172def48456e8d565c) )
 
 	ROM_REGION( 0x80000, "oki", 0 )
 	ROM_LOAD( "040-c3c2.snd", 0x00000, 0x80000, CRC(220949aa) SHA1(1e0dba168a0687d32aaaed42714ae24358f4a3e7) ) // 2 banks
@@ -4245,7 +4460,7 @@
 
 /***************************************************************************
 
-Mahjong Nenrikishu SP
+Mahjong Nenrikishu SP (V250J)
 IGS/Alta, 1998
 
 PCB Layout
@@ -4282,12 +4497,15 @@
 	ROM_REGION( 0x80000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "v250j.u29", 0x00000, 0x80000, CRC(500cb919) SHA1(76eed80b59c43e8cc1e258056cfe08b33a651852) )
 
-	ROM_REGION( 0x200000, "blitter", 0 )
-	ROM_LOAD( "m0501.u7", 0x00000, 0x200000, CRC(1c952bd6) SHA1(a6b6f1cdfb29647e81c032ffe59c94f1a10ceaf8) ) // Identical to igsm0501.u7
-
-	ROM_REGION( 0x80000, "blitter_hi", 0 ) // high order bit of graphics (5th bit)
-	ROM_LOAD( "m0502.u6", 0x000000, 0x80000, CRC(5d73ae99) SHA1(7283aa3d6b15ceb95db80756892be46eb997ef15) ) // Identical to igsm0502.u4, igsm0502.u5
-	ROM_LOAD( "cg.u4",    0x000000, 0x80000, CRC(fe60f485) SHA1(d75e5f7a187161137a7f7b54d495d1cb3e1802a4) )
+	ROM_REGION( 0x800000, "blitter", ROMREGION_ERASEFF )
+	ROM_LOAD( "m0501.u7", 0x000000, 0x200000, CRC(1c952bd6) SHA1(a6b6f1cdfb29647e81c032ffe59c94f1a10ceaf8) ) // Identical to igsm0501.u7
+	// empty
+	ROM_LOAD( "cg.u4",    0x400000, 0x080000, CRC(fe60f485) SHA1(d75e5f7a187161137a7f7b54d495d1cb3e1802a4) )
+	// empty
+
+	ROM_REGION( 0x200000, "blitter_hi", ROMREGION_ERASEFF ) // high order bit of graphics (5th bit)
+	ROM_LOAD( "m0502.u6", 0x00000, 0x80000, CRC(5d73ae99) SHA1(7283aa3d6b15ceb95db80756892be46eb997ef15) ) // Identical to igsm0502.u4, igsm0502.u5
+	// empty
 
 	ROM_REGION( 0x80000, "oki", 0 )
 	ROM_LOAD( "sp.u38", 0x00000, 0x80000, CRC(d80e28e2) SHA1(c03441686e770227db6a2a41922fbb4284710571) )
@@ -4404,4 +4622,4 @@
 GAME( 1996, wlcc,         xymg,     wlcc,            wlcc,      wlcc,         ROT0, "IGS",        "Wan Li Chang Cheng (China, V638C)",    0 )
 GAME( 1996, vbowl,        0,        vbowl,           vbowl,     vbowl,        ROT0, "IGS",        "Virtua Bowling (World, V101XCM)",      GAME_IMPERFECT_SOUND )
 GAME( 1996, vbowlj,       vbowl,    vbowl,           vbowlj,    vbowlj,       ROT0, "IGS / Alta", "Virtua Bowling (Japan, V100JCM)",      GAME_IMPERFECT_SOUND )
-GAME( 1998, nkishusp,     lhb2,     lhb2,            lhb2,      nkishusp,     ROT0, "IGS / Alta", "Mahjong Nenrikishu SP",                GAME_NOT_WORKING )
+GAME( 1998, nkishusp,     lhb2,     nkishusp,        nkishusp,  nkishusp,     ROT0, "IGS / Alta", "Mahjong Nenrikishu SP (Japan, V250J)", 0 )
diff -Nru src-old/mame/drivers/igs017.c src/mame/drivers/igs017.c
--- src-old/mame/drivers/igs017.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/igs017.c	2012-06-17 16:59:42.000000000 +0200
@@ -1387,7 +1387,7 @@
 	if (ACCESSING_BITS_0_7)
 		m_irq1_enable = data & 1;
 
-	if (data != 0 && data != 0xff)
+	if (data != 0 && data != 1 && data != 0xff)
 		logerror("%s: irq1_enable = %04x\n", machine().describe_context(), data);
 }
 
@@ -1396,7 +1396,7 @@
 	if (ACCESSING_BITS_0_7)
 		m_irq2_enable = data & 1;
 
-	if (data != 0 && data != 0xff)
+	if (data != 0 && data != 1 && data != 0xff)
 		logerror("%s: irq2_enable = %04x\n", machine().describe_context(), data);
 }
 
@@ -4175,7 +4175,7 @@
 GAME( 1997,  tjsb,     0,       tjsb,     tjsb,     tjsb,     ROT0, "IGS",              "Mahjong Tian Jiang Shen Bing (V137C)",        GAME_UNEMULATED_PROTECTION )
 GAME( 1998,  mgcs,     0,       mgcs,     mgcs,     mgcs,     ROT0, "IGS",              "Mahjong Man Guan Cai Shen (V103CS)",          GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_IMPERFECT_SOUND )
 GAME( 1998,  lhzb2,    0,       lhzb2,    lhzb2,     lhzb2,   ROT0, "IGS",              "Mahjong Long Hu Zheng Ba 2 (set 1)",          GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION )
-GAME( 1998,  lhzb2a,   lhzb2,   lhzb2a,   lhzb2a,    lhzb2a,  ROT0, "IGS",              "Mahjong Long Hu Zheng Ba 2 (VS221M)",         GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION )
+GAME( 1998,  lhzb2a,   lhzb2,   lhzb2a,   lhzb2a,    lhzb2a,  ROT0, "IGS",              "Mahjong Long Hu Zheng Ba 2 (VS221M)",         0 )
 GAME( 1998,  slqz2,    0,       slqz2,    slqz2,    slqz2,    ROT0, "IGS",              "Mahjong Shuang Long Qiang Zhu 2 (VS203J)",    GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION )
 GAME( 1999?, tarzan,   0,       iqblocka, iqblocka, tarzan,   ROT0, "IGS",              "Tarzan (V109C)",                              GAME_NOT_WORKING )
 GAME( 1999?, tarzana,  tarzan,  iqblocka, iqblocka, tarzana,  ROT0, "IGS",              "Tarzan (V107)",                               GAME_NOT_WORKING )
diff -Nru src-old/mame/drivers/jaguar.c src/mame/drivers/jaguar.c
--- src-old/mame/drivers/jaguar.c	2012-06-05 19:52:54.000000000 +0200
+++ src/mame/drivers/jaguar.c	2012-06-18 03:25:49.000000000 +0200
@@ -1806,7 +1806,7 @@
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 1.0)
 
 	/* quickload */
-	MCFG_QUICKLOAD_ADD("quickload", jaguar, "abs,bin,cof,jag,prg", 0)
+	MCFG_QUICKLOAD_ADD("quickload", jaguar, "abs,bin,cof,jag,prg", 2)
 
 	/* cartridge */
 	MCFG_CARTSLOT_ADD("cart")
diff -Nru src-old/mame/drivers/limenko.c src/mame/drivers/limenko.c
--- src-old/mame/drivers/limenko.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/drivers/limenko.c	2012-07-02 09:06:11.000000000 +0200
@@ -18,7 +18,6 @@
   - Happy Hunter (shooting themed prize game)
 
   To Do:
-  - QDSP QS1000 sound core
   - Legend of Heroes link up, 2 cabinets can be linked for a 4 player game
 
 */
@@ -26,8 +25,8 @@
 #include "emu.h"
 #include "cpu/e132xs/e132xs.h"
 #include "machine/eeprom.h"
+#include "sound/qs1000.h"
 #include "sound/okim6295.h"
-#include "cpu/mcs51/mcs51.h"
 
 
 class limenko_state : public driver_device
@@ -64,6 +63,7 @@
 	DECLARE_WRITE32_MEMBER(md_videoram_w);
 	DECLARE_WRITE32_MEMBER(fg_videoram_w);
 	DECLARE_WRITE32_MEMBER(spotty_soundlatch_w);
+	DECLARE_WRITE32_MEMBER(limenko_soundlatch_w);
 	DECLARE_WRITE32_MEMBER(spriteram_buffer_w);
 	DECLARE_WRITE8_MEMBER(spotty_sound_cmd_w);
 	DECLARE_READ8_MEMBER(spotty_sound_cmd_r);
@@ -73,6 +73,11 @@
 	DECLARE_READ32_MEMBER(sb2003_speedup_r);
 	DECLARE_READ32_MEMBER(spotty_speedup_r);
 	DECLARE_CUSTOM_INPUT_MEMBER(spriteram_bit_r);
+
+    DECLARE_READ8_MEMBER(qs1000_p1_r);
+    DECLARE_WRITE8_MEMBER(qs1000_p1_w);
+    DECLARE_WRITE8_MEMBER(qs1000_p2_w);
+    DECLARE_WRITE8_MEMBER(qs1000_p3_w);
 };
 
 
@@ -123,11 +128,6 @@
 	m_fg_tilemap->mark_tile_dirty(offset);
 }
 
-WRITE32_MEMBER(limenko_state::spotty_soundlatch_w)
-{
-	soundlatch_byte_w(space, 0, (data >> 16) & 0xff);
-}
-
 CUSTOM_INPUT_MEMBER(limenko_state::spriteram_bit_r)
 {
 	return m_spriteram_bit;
@@ -159,6 +159,54 @@
 }
 
 /*****************************************************************************************************
+ SOUND FUNCTIONS
+ *****************************************************************************************************/
+
+WRITE32_MEMBER(limenko_state::limenko_soundlatch_w)
+{
+	qs1000_device *qs1000 = machine().device<qs1000_device>("qs1000");
+
+	soundlatch_byte_w(space, 0, data >> 16);
+	qs1000->set_irq(ASSERT_LINE);
+
+	machine().scheduler().boost_interleave(attotime::zero, attotime::from_usec(100));
+}
+
+WRITE32_MEMBER(limenko_state::spotty_soundlatch_w)
+{
+	soundlatch_byte_w(space, 0, data >> 16);
+}
+
+READ8_MEMBER(limenko_state::qs1000_p1_r)
+{
+	return soundlatch_byte_r(space, 0);
+}
+
+WRITE8_MEMBER(limenko_state::qs1000_p1_w)
+{
+
+}
+
+WRITE8_MEMBER(limenko_state::qs1000_p2_w)
+{
+	// Unknown. Often written with 0
+}
+
+WRITE8_MEMBER(limenko_state::qs1000_p3_w)
+{
+	// .... .xxx - Data ROM bank (64kB)
+	// ...x .... - ?
+	// ..x. .... - /IRQ clear
+
+	qs1000_device *qs1000 = machine().device<qs1000_device>("qs1000");
+
+	membank("qs1000:bank")->set_entry(data & 0x07);
+
+	if (!BIT(data, 5))
+		qs1000->set_irq(CLEAR_LINE);
+}
+
+/*****************************************************************************************************
   MEMORY MAPS
 *****************************************************************************************************/
 
@@ -183,7 +231,7 @@
 	AM_RANGE(0x1000, 0x1003) AM_READ_PORT("IN2")
 	AM_RANGE(0x4000, 0x4003) AM_WRITE(limenko_coincounter_w)
 	AM_RANGE(0x4800, 0x4803) AM_WRITE_PORT("EEPROMOUT")
-	AM_RANGE(0x5000, 0x5003) AM_WRITENOP // sound latch
+	AM_RANGE(0x5000, 0x5003) AM_WRITE(limenko_soundlatch_w)
 ADDRESS_MAP_END
 
 
@@ -672,6 +720,26 @@
 
 
 /*****************************************************************************************************
+ INTERFACES
+ *****************************************************************************************************/
+
+static QS1000_INTERFACE( qs1000_intf )
+{
+	/* External ROM */
+	true,
+
+	/* P1-P3 read handlers */
+	DEVCB_DRIVER_MEMBER(limenko_state, qs1000_p1_r),
+	DEVCB_NULL,
+	DEVCB_NULL,
+
+	/* P1-P3 write handlers */
+	DEVCB_DRIVER_MEMBER(limenko_state, qs1000_p1_w),
+	DEVCB_DRIVER_MEMBER(limenko_state, qs1000_p2_w),
+	DEVCB_DRIVER_MEMBER(limenko_state, qs1000_p3_w),
+};
+
+/*****************************************************************************************************
   MACHINE DRIVERS
 *****************************************************************************************************/
 
@@ -698,6 +766,11 @@
 	MCFG_VIDEO_START(limenko)
 
 	/* sound hardware */
+	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
+
+	MCFG_QS1000_ADD("qs1000", XTAL_24MHz, qs1000_intf)
+	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
+	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
 
 static MACHINE_CONFIG_START( spotty, limenko_state )
@@ -775,11 +848,9 @@
 	ROM_REGION32_BE( 0x400000, "user2", ROMREGION_ERASEFF )
 	ROM_LOAD16_WORD_SWAP( "rom.u5", 0x000000, 0x200000, CRC(7e837adf) SHA1(8613fa187b8d4574b3935aa439aec2515033d64c) )
 
-	ROM_REGION( 0x220000, "cpu1", 0 ) /* sound cpu + data */
-	ROM_LOAD( "rom.u16", 0x000000, 0x020000, CRC(f66d7e4d) SHA1(44f1851405ba525f1ed53521f4de12545ea9c46a) )
-	ROM_LOAD( "rom.u17", 0x020000, 0x080000, CRC(20f2417c) SHA1(1bdc0b03215f5002eed4c25d670bbb5411189907) )
-	ROM_LOAD( "rom.u18", 0x020000, 0x080000, CRC(50d76732) SHA1(6179c7365b62df620a10a1253d524807408821de) )
-	// u19 empty
+	ROM_REGION( 0x80000, "qs1000:cpu", 0 ) /* QS1000 CPU */
+	ROM_LOAD( "rom.u16", 0x00000, 0x20000, CRC(f66d7e4d) SHA1(44f1851405ba525f1ed53521f4de12545ea9c46a) )
+	ROM_FILL(            0x20000, 0x60000, 0xff)
 
 	ROM_REGION( 0x800000, "gfx1", 0 )
 	ROM_LOAD32_BYTE( "rom.u1", 0x000000, 0x200000, CRC(bf33eff6) SHA1(089b6d88d6d744bcfa036c6869f0444d6ceb26c9) )
@@ -787,10 +858,12 @@
 	ROM_LOAD32_BYTE( "rom.u3", 0x000002, 0x200000, CRC(ec094b12) SHA1(13c105df066ff308cc7e1842907644790946e5b5) )
 	ROM_LOAD32_BYTE( "rom.u4", 0x000003, 0x200000, CRC(88b24e3c) SHA1(5f267f08144b413b55ef5e15c52e9cda096b80e7) )
 
-	ROM_REGION( 0x200000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1003.u4",    0x000000, 0x200000, CRC(19e4b469) SHA1(9460e5b6a0fbf3fdd6a9fa0dcbf5062a2e07fe02) )
-
-	// u20 empty
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP wavetable ROMs */
+    ROM_LOAD( "rom.u18",  0x000000, 0x080000, CRC(50d76732) SHA1(6179c7365b62df620a10a1253d524807408821de) )
+    ROM_LOAD( "rom.u17",  0x080000, 0x080000, CRC(20f2417c) SHA1(1bdc0b03215f5002eed4c25d670bbb5411189907) )
+	ROM_LOAD( "qs1003.u4",0x200000, 0x200000, CRC(19e4b469) SHA1(9460e5b6a0fbf3fdd6a9fa0dcbf5062a2e07fe02) )
+	// U19 empty
+	// U20 empty
 ROM_END
 
 ROM_START( sb2003 ) /* No specific Country/Region */
@@ -800,11 +873,9 @@
 	ROM_REGION32_BE( 0x400000, "user2", ROMREGION_ERASEFF )
 	// u5 empty
 
-	ROM_REGION( 0x220000, "cpu1", 0 ) /* sound cpu + data */
-	ROM_LOAD( "07.u16", 0x000000, 0x020000, CRC(78acc607) SHA1(30a1aed40d45233dce88c6114989c71aa0f99ff7) )
-	// u17 empty
-	ROM_LOAD( "06.u18", 0x020000, 0x200000, CRC(b6ad0d32) SHA1(33e73963ea25e131801dc11f25be6ab18bef03ed) )
-	// u19 empty
+	ROM_REGION( 0x80000, "qs1000:cpu", 0 ) /* QS1000 CPU */
+	ROM_LOAD( "07.u16", 0x00000, 0x20000, CRC(78acc607) SHA1(30a1aed40d45233dce88c6114989c71aa0f99ff7) )
+	ROM_FILL(           0x20000, 0x60000, 0xff)
 
 	ROM_REGION( 0x800000, "gfx1", 0 )
 	ROM_LOAD32_BYTE( "01.u1", 0x000000, 0x200000, CRC(d2c7091a) SHA1(deff050eb0aee89f60d5ad13053e4f1bd4d35961) )
@@ -812,10 +883,12 @@
 	ROM_LOAD32_BYTE( "03.u3", 0x000002, 0x200000, CRC(0f020280) SHA1(2c10baec8dbb201ee5e1c4c9d6b962e2ed02df7d) )
 	ROM_LOAD32_BYTE( "04.u4", 0x000003, 0x200000, CRC(fc2222b9) SHA1(c7ee8cffbbee1673a9f107f3f163d029c3900230) )
 
-	ROM_REGION( 0x200000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1003.u4",    0x000000, 0x200000, CRC(19e4b469) SHA1(9460e5b6a0fbf3fdd6a9fa0dcbf5062a2e07fe02) )
-
-	// u20 (S-ROM) empty
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP wavetable ROMs */
+	ROM_LOAD( "06.u18",    0x000000, 0x200000, CRC(b6ad0d32) SHA1(33e73963ea25e131801dc11f25be6ab18bef03ed) )
+	ROM_LOAD( "qs1003.u4", 0x200000, 0x200000, CRC(19e4b469) SHA1(9460e5b6a0fbf3fdd6a9fa0dcbf5062a2e07fe02) )
+    // U17 empty
+	// U19 empty
+	// U20 (S-ROM) empty
 ROM_END
 
 ROM_START( sb2003a ) /* Asia Region */
@@ -825,11 +898,9 @@
 	ROM_REGION32_BE( 0x400000, "user2", ROMREGION_ERASEFF )
 	// u5 empty
 
-	ROM_REGION( 0x220000, "cpu1", 0 ) /* sound cpu + data */
-	ROM_LOAD( "07.u16", 0x000000, 0x020000, CRC(78acc607) SHA1(30a1aed40d45233dce88c6114989c71aa0f99ff7) )
-	// u17 empty
-	ROM_LOAD( "06.u18", 0x020000, 0x200000, CRC(b6ad0d32) SHA1(33e73963ea25e131801dc11f25be6ab18bef03ed) )
-	// u19 empty
+	ROM_REGION( 0x80000, "qs1000:cpu", 0 ) /* QS1000 CPU */
+	ROM_LOAD( "07.u16", 0x00000, 0x20000, CRC(78acc607) SHA1(30a1aed40d45233dce88c6114989c71aa0f99ff7) )
+	ROM_FILL(           0x20000, 0x60000, 0xff)
 
 	ROM_REGION( 0x800000, "gfx1", 0 )
 	ROM_LOAD32_BYTE( "01.u1", 0x000000, 0x200000, CRC(d2c7091a) SHA1(deff050eb0aee89f60d5ad13053e4f1bd4d35961) )
@@ -837,10 +908,12 @@
 	ROM_LOAD32_BYTE( "03.u3", 0x000002, 0x200000, CRC(0f020280) SHA1(2c10baec8dbb201ee5e1c4c9d6b962e2ed02df7d) )
 	ROM_LOAD32_BYTE( "04.u4", 0x000003, 0x200000, CRC(fc2222b9) SHA1(c7ee8cffbbee1673a9f107f3f163d029c3900230) )
 
-	ROM_REGION( 0x200000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1003.u4",    0x000000, 0x200000, CRC(19e4b469) SHA1(9460e5b6a0fbf3fdd6a9fa0dcbf5062a2e07fe02) )
-
-	// u20 (S-ROM) empty
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP wavetable ROM */
+	ROM_LOAD( "06.u18",   0x000000, 0x200000, CRC(b6ad0d32) SHA1(33e73963ea25e131801dc11f25be6ab18bef03ed) )
+	ROM_LOAD( "qs1003.u4",0x200000, 0x200000, CRC(19e4b469) SHA1(9460e5b6a0fbf3fdd6a9fa0dcbf5062a2e07fe02) )
+	// U17 empty
+	// U19 empty
+	// U20 (S-ROM) empty
 ROM_END
 
 /*
@@ -864,7 +937,7 @@
 || |                             |SYS     |              | ||
 || |           |------|          |L2D_HYP |              | ||
 || | QS1003    |QS1000|          |VER1.0  |              | ||
-|| |           |      |24kHz     |--------| IC41C16256   | ||
+|| |           |      |24MHz     |--------| IC41C16256   | ||
 || |           |------|                                  | ||
 || |                             32MHz     20MHz         | ||
 || |                                                     | ||
@@ -942,13 +1015,13 @@
 	ROM_LOAD32_BYTE( "04.cg_rom32",  0x1000002, 0x080000, CRC(3f486cab) SHA1(6507d4bb9b4aa7d43f1026e932c82629d4fa44dd) )
 	ROM_LOAD32_BYTE( "05.cg_rom42",  0x1000003, 0x080000, CRC(5d807bec) SHA1(c72c77ed0478f705018519cf68a54d22524d05fd) )
 
-	ROM_REGION( 0x200000, "sfx", 0 ) /* sounds */
-	ROM_LOAD( "sou_prg.06",   0x000000, 0x80000, CRC(bfafe7aa) SHA1(3e65869fe0970bafb59a0225642834042fdedfa6) )
-	ROM_LOAD( "sou_rom.07",   0x000000, 0x80000, CRC(4c6eb6d2) SHA1(58bced7bd944e03b0e3dfe1107c01819a33b2b31) )
-	ROM_LOAD( "sou_rom.08",   0x000000, 0x80000, CRC(42c32dd5) SHA1(4702771288ba40119de63feb67eed85667235d81) )
+	ROM_REGION( 0x80000, "qs1000:cpu", 0 ) /* QS1000 CPU */
+	ROM_LOAD( "sou_prg.06", 0x000000, 0x80000, CRC(bfafe7aa) SHA1(3e65869fe0970bafb59a0225642834042fdedfa6) )
 
-	ROM_REGION( 0x200000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1003.u4",    0x000000, 0x200000, CRC(19e4b469) SHA1(9460e5b6a0fbf3fdd6a9fa0dcbf5062a2e07fe02) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* QDSP wavetable ROMs */
+	ROM_LOAD( "sou_rom.07", 0x000000, 0x080000, CRC(4c6eb6d2) SHA1(58bced7bd944e03b0e3dfe1107c01819a33b2b31) )
+	ROM_LOAD( "sou_rom.08", 0x080000, 0x080000, CRC(42c32dd5) SHA1(4702771288ba40119de63feb67eed85667235d81) )
+	ROM_LOAD( "qs1003.u4",  0x200000, 0x200000, CRC(19e4b469) SHA1(9460e5b6a0fbf3fdd6a9fa0dcbf5062a2e07fe02) )
 ROM_END
 
 /*
@@ -1039,12 +1112,23 @@
 	return m_mainram[0x6626c/4];
 }
 
+static DRIVER_INIT( common )
+{
+	limenko_state *state = machine.driver_data<limenko_state>();
+
+	// Set up the QS1000 program ROM banking, taking care not to overlap the internal RAM
+	machine.device("qs1000:cpu")->memory().space(AS_IO)->install_read_bank(0x0100, 0xffff, "bank");
+	state->membank("qs1000:bank")->configure_entries(0, 8, state->memregion("qs1000:cpu")->base()+0x100, 0x10000);
+
+	state->m_spriteram_bit = 1;
+}
+
 static DRIVER_INIT( dynabomb )
 {
 	limenko_state *state = machine.driver_data<limenko_state>();
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0xe2784, 0xe2787, read32_delegate(FUNC(limenko_state::dynabomb_speedup_r), state));
 
-	state->m_spriteram_bit = 1;
+	DRIVER_INIT_CALL(common);
 }
 
 static DRIVER_INIT( legendoh )
@@ -1052,7 +1136,7 @@
 	limenko_state *state = machine.driver_data<limenko_state>();
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0x32ab0, 0x32ab3, read32_delegate(FUNC(limenko_state::legendoh_speedup_r), state));
 
-	state->m_spriteram_bit = 1;
+	DRIVER_INIT_CALL(common);
 }
 
 static DRIVER_INIT( sb2003 )
@@ -1060,9 +1144,10 @@
 	limenko_state *state = machine.driver_data<limenko_state>();
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0x135800, 0x135803, read32_delegate(FUNC(limenko_state::sb2003_speedup_r), state));
 
-	state->m_spriteram_bit = 1;
+	DRIVER_INIT_CALL(common);
 }
 
+
 static DRIVER_INIT( spotty )
 {
 	limenko_state *state = machine.driver_data<limenko_state>();
@@ -1084,10 +1169,10 @@
 	state->m_spriteram_bit = 1;
 }
 
-GAME( 2000, dynabomb, 0,      limenko, sb2003,   dynabomb, ROT0, "Limenko", "Dynamite Bomber (Korea, Rev 1.5)",   GAME_NO_SOUND )
-GAME( 2000, legendoh, 0,      limenko, legendoh, legendoh, ROT0, "Limenko", "Legend of Heroes",                   GAME_NO_SOUND )
-GAME( 2003, sb2003,   0,      limenko, sb2003,   sb2003,   ROT0, "Limenko", "Super Bubble 2003 (World, Ver 1.0)", GAME_NO_SOUND )
-GAME( 2003, sb2003a,  sb2003, limenko, sb2003,   sb2003,   ROT0, "Limenko", "Super Bubble 2003 (Asia, Ver 1.0)",  GAME_NO_SOUND )
+GAME( 2000, dynabomb, 0,      limenko, sb2003,   dynabomb, ROT0, "Limenko", "Dynamite Bomber (Korea, Rev 1.5)",   GAME_IMPERFECT_SOUND )
+GAME( 2000, legendoh, 0,      limenko, legendoh, legendoh, ROT0, "Limenko", "Legend of Heroes",                   GAME_IMPERFECT_SOUND )
+GAME( 2003, sb2003,   0,      limenko, sb2003,   sb2003,   ROT0, "Limenko", "Super Bubble 2003 (World, Ver 1.0)", GAME_IMPERFECT_SOUND )
+GAME( 2003, sb2003a,  sb2003, limenko, sb2003,   sb2003,   ROT0, "Limenko", "Super Bubble 2003 (Asia, Ver 1.0)",  GAME_IMPERFECT_SOUND )
 
 // this game only use the same graphics chip used in limenko's system
 GAME( 2001, spotty,   0,      spotty,  spotty,   spotty,   ROT0, "Prince Co.", "Spotty (Ver. 2.0.2)",             GAME_NO_SOUND )
diff -Nru src-old/mame/drivers/magictg.c src/mame/drivers/magictg.c
--- src-old/mame/drivers/magictg.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/magictg.c	2012-07-02 08:20:21.000000000 +0200
@@ -137,7 +137,7 @@
 
 	required_device<cpu_device>			m_mips;
 	required_device<adsp2181_device>	m_adsp;
-	required_device<pci_bus_device>		m_pci;
+	required_device<pci_bus_legacy_device>		m_pci;
 
 
 	/* ASIC */
@@ -614,12 +614,12 @@
 		}
 		case 0xcf8:
 		{
-			pci_32le_w(m_pci, 0, data, mem_mask);
+			m_pci->write(space, 0, data, mem_mask);
 			break;
 		}
 		case 0xcfc:
 		{
-			pci_32le_w(m_pci, 1, data, mem_mask);
+			m_pci->write(space, 1, data, mem_mask);
 			break;
 		}
 //      default:
@@ -651,12 +651,12 @@
 
 		case 0xcf8:
 		{
-			val = pci_32le_r(m_pci, 0, FLIPENDIAN_INT32(mem_mask));
+			val = m_pci->read(space, 0, FLIPENDIAN_INT32(mem_mask));
 			break;
 		}
 		case 0xcfc:
 		{
-			val = pci_32le_r(m_pci, 1, FLIPENDIAN_INT32(mem_mask));
+			val = m_pci->read(space, 1, FLIPENDIAN_INT32(mem_mask));
 			break;
 		}
 //      default:
@@ -924,14 +924,14 @@
 	MCFG_SOUND_ADD("dac2", DMADAC, 0)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 1.0)
 
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(0, NULL, pci_dev0_r, pci_dev0_w)
-	MCFG_PCI_BUS_DEVICE(7, "voodoo_0", voodoo_0_pci_r, voodoo_0_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(0, NULL, pci_dev0_r, pci_dev0_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(7, "voodoo_0", voodoo_0_pci_r, voodoo_0_pci_w)
 
 #if defined(USE_TWO_3DFX)
-	MCFG_PCI_BUS_DEVICE(8, "voodoo_1", voodoo_1_pci_r, voodoo_1_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(8, "voodoo_1", voodoo_1_pci_r, voodoo_1_pci_w)
 #endif
-	MCFG_PCI_BUS_DEVICE(9, "zr36120", zr36120_pci_r, zr36120_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(9, "zr36120", zr36120_pci_r, zr36120_pci_w)
 
 	MCFG_3DFX_VOODOO_1_ADD("voodoo_0", STD_VOODOO_1_CLOCK, 2, "screen")
 	MCFG_3DFX_VOODOO_CPU("mips")
diff -Nru src-old/mame/drivers/mediagx.c src/mame/drivers/mediagx.c
--- src-old/mame/drivers/mediagx.c	2012-05-27 18:19:39.000000000 +0200
+++ src/mame/drivers/mediagx.c	2012-07-02 08:20:21.000000000 +0200
@@ -960,7 +960,7 @@
 	AM_RANGE(0x0378, 0x037b) AM_READWRITE(parallel_port_r, parallel_port_w)
 	AM_RANGE(0x03f0, 0x03ff) AM_READWRITE(fdc_r, fdc_w)
 	AM_RANGE(0x0400, 0x04ff) AM_READWRITE(ad1847_r, ad1847_w)
-	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE_LEGACY("pcibus", pci_32le_r,	pci_32le_w)
+	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_bus_legacy_device, read, write)
 ADDRESS_MAP_END
 
 /*****************************************************************************/
@@ -1160,8 +1160,8 @@
 	MCFG_MACHINE_START(mediagx)
 	MCFG_MACHINE_RESET(mediagx)
 
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(18, NULL, cx5510_pci_r, cx5510_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(18, NULL, cx5510_pci_r, cx5510_pci_w)
 
 	MCFG_PIT8254_ADD( "pit8254", mediagx_pit8254_config )
 
diff -Nru src-old/mame/drivers/midqslvr.c src/mame/drivers/midqslvr.c
--- src-old/mame/drivers/midqslvr.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/midqslvr.c	2012-07-02 08:20:21.000000000 +0200
@@ -558,7 +558,7 @@
 	AM_RANGE(0x01f0, 0x01f7) AM_READWRITE(ide_r, ide_w)
 	AM_RANGE(0x03f0, 0x03f7) AM_READWRITE(fdc_r, fdc_w)
 
-	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE_LEGACY("pcibus", pci_32le_r,	pci_32le_w)
+	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_bus_legacy_device, read, write)
 ADDRESS_MAP_END
 
 static const struct pit8253_config midqslvr_pit8254_config =
@@ -702,9 +702,9 @@
 
 	MCFG_MC146818_ADD( "rtc", MC146818_STANDARD )
 
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE( 0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
-	MCFG_PCI_BUS_DEVICE(31, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE( 0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(31, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
 
 	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL, true)
 
diff -Nru src-old/mame/drivers/midvunit.c src/mame/drivers/midvunit.c
--- src-old/mame/drivers/midvunit.c	2012-05-23 09:50:33.000000000 +0200
+++ src/mame/drivers/midvunit.c	2012-07-02 09:06:11.000000000 +0200
@@ -7,7 +7,7 @@
     Games supported:
         * Cruis'n USA (1994)        [3 sets]
         * Cruis'n World (1996)      [4 sets]
-        * War Gods (1996)
+        * War Gods (1996)           [3 sets]
         * Off Road Challenge (1997) [4 sets]
 
     Known bugs:
@@ -15,6 +15,10 @@
         * rendering needs to be looked at a little more closely to fix some holes
         * in Cruis'n World attract mode, right side of sky looks like it has wrapped
         * Off Road Challenge has polygon sorting issues, among other problems
+        * Issues for the Wargods sets:
+           Sound D/RAM      ERROR EE (during boot diag)
+           Listen for Tone  ERROR E1 (during boot diag)
+           All sets report as Game Type: 452 (12/11/1995) [which is wrong for newer sets]
 
 **************************************************************************/
 
@@ -564,32 +568,35 @@
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("DSW")
-	PORT_DIPNAME( 0x0001, 0x0000, "Link Status" )
+	/* DSW2 at U97 */
+	PORT_DIPNAME( 0x0001, 0x0000, "Link Status" )		PORT_DIPLOCATION("SW2:8")
 	PORT_DIPSETTING(      0x0000, "Master" )
 	PORT_DIPSETTING(      0x0001, "Slave" )
-	PORT_DIPNAME( 0x0002, 0x0002, "Link???" )
+	PORT_DIPNAME( 0x0002, 0x0002, "Link???" )		PORT_DIPLOCATION("SW2:7") /* Listed as Not Used in the manual */
 	PORT_DIPSETTING(      0x0002, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0004, 0x0004, "Linking" )
+	PORT_DIPNAME( 0x0004, 0x0004, "Linking" )		PORT_DIPLOCATION("SW2:6")
 	PORT_DIPSETTING(      0x0004, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0008, 0x0008, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x0008, 0x0008, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:5") /* Listed as Not Used in the manual */
 	PORT_DIPSETTING(      0x0008, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0010, 0x0010, "Freeze" )
+	PORT_DIPNAME( 0x0010, 0x0010, "Freeze" )		PORT_DIPLOCATION("SW2:4") /* Listed as Not Used in the manual */
 	PORT_DIPSETTING(      0x0010, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0020, 0x0020, DEF_STR( Cabinet ) )
+	PORT_DIPNAME( 0x0020, 0x0020, DEF_STR( Cabinet ) )	PORT_DIPLOCATION("SW2:3")
 	PORT_DIPSETTING(      0x0020, DEF_STR( Upright ) )
 	PORT_DIPSETTING(      0x0000, "Sitdown" )
-	PORT_DIPNAME( 0x0040, 0x0040, "Enable Motion" )
+	PORT_DIPNAME( 0x0040, 0x0040, "Enable Motion" )		PORT_DIPLOCATION("SW2:2")
 	PORT_DIPSETTING(      0x0040, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_SERVICE( 0x0080, IP_ACTIVE_LOW )
-	PORT_DIPNAME( 0x0100, 0x0100, "Coin Counters" )
+	PORT_SERVICE_DIPLOC(  0x0080, IP_ACTIVE_LOW, "SW2:1" ) /* Listed as Not Used in the manual */
+
+	/* DSW3 at U19 */
+	PORT_DIPNAME( 0x0100, 0x0100, "Coin Counters" )		PORT_DIPLOCATION("SW3:8")
 	PORT_DIPSETTING(      0x0100, "1" )
 	PORT_DIPSETTING(      0x0000, "2" )
-	PORT_DIPNAME( 0xfe00, 0xf800, DEF_STR( Coinage ) )
+	PORT_DIPNAME( 0xfe00, 0xf800, DEF_STR( Coinage ) )	PORT_DIPLOCATION("SW3:7,6,5,4,3,2,1")
 	PORT_DIPSETTING(      0xfe00, "USA-1" )
 	PORT_DIPSETTING(      0xfa00, "USA-3" )
 	PORT_DIPSETTING(      0xfc00, "USA-7" )
@@ -696,29 +703,30 @@
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("DSW")
-	PORT_DIPNAME( 0x0003, 0x0000, "Link Number" )
+	/* DSW2 at U97 */
+	PORT_DIPNAME( 0x0003, 0x0000, "Link Number" )		PORT_DIPLOCATION("SW2:8,7")
 	PORT_DIPSETTING(      0x0000, "1" )
 	PORT_DIPSETTING(      0x0001, "2" )
 	PORT_DIPSETTING(      0x0002, "3" )
 	PORT_DIPSETTING(      0x0003, "4" )
-	PORT_DIPNAME( 0x0004, 0x0004, "Linking" )
+	PORT_DIPNAME( 0x0004, 0x0004, "Linking" )		PORT_DIPLOCATION("SW2:6")
 	PORT_DIPSETTING(      0x0004, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0018, 0x0008, "Games Linked" )
+	PORT_DIPNAME( 0x0018, 0x0008, "Games Linked" )		PORT_DIPLOCATION("SW2:5,4")
 	PORT_DIPSETTING(      0x0008, "2" )
 	PORT_DIPSETTING(      0x0010, "3" )
 	PORT_DIPSETTING(      0x0018, "4" )
-	PORT_DIPNAME( 0x0020, 0x0020, DEF_STR( Cabinet ) )
+	PORT_DIPNAME( 0x0020, 0x0020, DEF_STR( Cabinet ) )	PORT_DIPLOCATION("SW2:3")
 	PORT_DIPSETTING(      0x0020, DEF_STR( Upright ) )
 	PORT_DIPSETTING(      0x0000, "Sitdown" )
-	PORT_DIPNAME( 0x0040, 0x0040, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(      0x0040, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_SERVICE( 0x0080, IP_ACTIVE_LOW )
-	PORT_DIPNAME( 0x0100, 0x0100, "Coin Counters" )
+	PORT_DIPUNUSED_DIPLOC( 0x0040, 0x0040, "SW2:2" )		/* Manual shows Not Used */
+	PORT_SERVICE_DIPLOC(  0x0080, IP_ACTIVE_LOW, "SW2:1" )
+
+	/* DSW3 at U19 */
+	PORT_DIPNAME( 0x0100, 0x0100, "Coin Counters" )		PORT_DIPLOCATION("SW3:8")
 	PORT_DIPSETTING(      0x0100, "1" )
 	PORT_DIPSETTING(      0x0000, "2" )
-	PORT_DIPNAME( 0xfe00, 0xf800, DEF_STR( Coinage ) )
+	PORT_DIPNAME( 0xfe00, 0xf800, DEF_STR( Coinage ) )	PORT_DIPLOCATION("SW3:7,6,5,4,3,2,1")
 	PORT_DIPSETTING(      0xfe00, "USA-1" )
 	PORT_DIPSETTING(      0xfa00, "USA-3" )
 	PORT_DIPSETTING(      0xfc00, "USA-7" )
@@ -825,39 +833,32 @@
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("DSW")
-	PORT_DIPNAME( 0x0001, 0x0001, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(      0x0001, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0002, 0x0000, "Shifter" )
-	PORT_DIPSETTING(      0x0002, "Closed" )
-	PORT_DIPSETTING(      0x0000, "Open" )
-	PORT_DIPNAME( 0x0004, 0x0004, "Girls" )
-	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0004, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0008, 0x0008, "Road Kill" )
-	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0008, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0010, 0x0010, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(      0x0010, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0020, 0x0020, "Link" )
+	/* DSW2 at U97 */
+	PORT_DIPUNUSED_DIPLOC( 0x0001, 0x0001, "SW2:8" )		/* Manual shows Not Used & "No Effect" for both On & Off */
+	PORT_DIPNAME( 0x0002, 0x0000, "Gear Shifter Switch" )		PORT_DIPLOCATION("SW2:7")
+	PORT_DIPSETTING(      0x0002, "Normally Closed" )
+	PORT_DIPSETTING(      0x0000, "Normally Open" )
+	PORT_DIPNAME( 0x0004, 0x0004, "Added Attractions" )		PORT_DIPLOCATION("SW2:6")
+	PORT_DIPSETTING(      0x0004, "Girls Present" )
+	PORT_DIPSETTING(      0x0000, "Girls Missing" )
+	PORT_DIPNAME( 0x0008, 0x0008, "Graphic Effects" )		PORT_DIPLOCATION("SW2:5")
+	PORT_DIPSETTING(      0x0008, "Roadkill Present" )
+	PORT_DIPSETTING(      0x0000, "Roadkill Missing" )
+	PORT_DIPUNUSED_DIPLOC( 0x0010, 0x0010, "SW2:4" )		/* Manual shows Not Used & "No Effect" for both On & Off */
+	PORT_DIPNAME( 0x0020, 0x0020, "Link" )				PORT_DIPLOCATION("SW2:3")
 	PORT_DIPSETTING(      0x0020, "Disabled" )
 	PORT_DIPSETTING(      0x0000, "Enabled" )
-	PORT_DIPNAME( 0x00c0, 0x00c0, "Link Machine" )
+	PORT_DIPNAME( 0x00c0, 0x00c0, "Link Machine" )			PORT_DIPLOCATION("SW2:2,1")
 	PORT_DIPSETTING(      0x00c0, "1" )
 	PORT_DIPSETTING(      0x0080, "2" )
 	PORT_DIPSETTING(      0x0040, "3" )
 	PORT_DIPSETTING(      0x0000, "4" )
-	PORT_DIPNAME( 0x0100, 0x0100, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(      0x0100, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0200, 0x0200, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(      0x0200, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0400, 0x0400, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(      0x0400, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0xf800, 0xf800, DEF_STR( Coinage ) )
+
+	/* DSW3 at U19 */
+	PORT_DIPUNUSED_DIPLOC( 0x0100, 0x0100, "SW3:8" )	/* Manual states "Switches 6, 7 and 8 are not active. We recommend */
+	PORT_DIPUNUSED_DIPLOC( 0x0200, 0x0200, "SW3:7" )	/* they be set to the facorty default (OFF) positions."            */
+	PORT_DIPUNUSED_DIPLOC( 0x0400, 0x0400, "SW3:6" )
+	PORT_DIPNAME( 0xf800, 0xf800, DEF_STR( Coinage ) )		PORT_DIPLOCATION("SW3:5,4,3,2,1")
 	PORT_DIPSETTING(      0xf800, "USA 1" )
 	PORT_DIPSETTING(      0xf000, "German 1" )
 	PORT_DIPSETTING(      0xe800, "French 1" )
@@ -891,34 +892,34 @@
 
 static INPUT_PORTS_START( wargods )
 	PORT_START("DIPS")
-	PORT_DIPNAME( 0x0001, 0x0001, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(      0x0001, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0002, 0x0002, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x0001, 0x0001, "CRT Type / Resolution" )		PORT_DIPLOCATION("SW1:1") /* This only works for the Dual Res version */
+	PORT_DIPSETTING(      0x0001, "Medium Res (24Khz)" )
+	PORT_DIPSETTING(      0x0000, "Standard Res (15Khz)" )
+	PORT_DIPNAME( 0x0002, 0x0002, DEF_STR( Unknown ) )		PORT_DIPLOCATION("SW1:2") /* Manual shows Not Used (must be Off) */
 	PORT_DIPSETTING(      0x0002, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0004, 0x0004, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x0004, 0x0004, DEF_STR( Unknown ) )		PORT_DIPLOCATION("SW1:3") /* Manual shows Not Used (must be Off) */
 	PORT_DIPSETTING(      0x0004, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0008, 0x0008, "Blood" )
+	PORT_DIPNAME( 0x0008, 0x0008, "Blood" )				PORT_DIPLOCATION("SW1:4")
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0010, 0x0010, "Graphics" )
+	PORT_DIPNAME( 0x0010, 0x0010, "Graphics" )			PORT_DIPLOCATION("SW1:5")
 	PORT_DIPSETTING(      0x0010, DEF_STR( Normal ) )
 	PORT_DIPSETTING(      0x0000, "Family" )
-	PORT_DIPNAME( 0x0020, 0x0020, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x0020, 0x0020, DEF_STR( Unknown ) )		PORT_DIPLOCATION("SW1:6") /* Manual shows Not Used */
 	PORT_DIPSETTING(      0x0020, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0040, 0x0040, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x0040, 0x0040, DEF_STR( Unknown ) )		PORT_DIPLOCATION("SW1:7") /* Manual shows Not Used */
 	PORT_DIPSETTING(      0x0040, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0080, 0x0080, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x0080, 0x0080, DEF_STR( Unknown ) )		PORT_DIPLOCATION("SW1:8") /* Manual shows Not Used */
 	PORT_DIPSETTING(      0x0080, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0100, 0x0100, "Coinage Source" )
+	PORT_DIPNAME( 0x0100, 0x0100, "Coinage Source" )		PORT_DIPLOCATION("SW2:1")
 	PORT_DIPSETTING(      0x0100, "Dipswitch" )
 	PORT_DIPSETTING(      0x0000, "CMOS" )
-	PORT_DIPNAME( 0x3e00, 0x3e00, DEF_STR( Coinage ) )
+	PORT_DIPNAME( 0x3e00, 0x3e00, DEF_STR( Coinage ) )		PORT_DIPLOCATION("SW2:2,3,4,5,6")
 	PORT_DIPSETTING(      0x3e00, "USA-1" )
 	PORT_DIPSETTING(      0x3c00, "USA-2" )
 	PORT_DIPSETTING(      0x3a00, "USA-3" )
@@ -940,10 +941,10 @@
 	PORT_DIPSETTING(      0x1200, "French-12" )
 	PORT_DIPSETTING(      0x1600, "French-ECA" )
 	PORT_DIPSETTING(      0x3000, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x4000, 0x4000, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x4000, 0x4000, DEF_STR( Unknown ) )		PORT_DIPLOCATION("SW2:7") /* Manual shows Not Used */
 	PORT_DIPSETTING(      0x4000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x8000, 0x8000, "Test Switch" )
+	PORT_DIPNAME( 0x8000, 0x8000, "Test Switch" )			PORT_DIPLOCATION("SW2:8")
 	PORT_DIPSETTING(      0x8000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
 
@@ -993,6 +994,14 @@
 	PORT_BIT( 0xff80, IP_ACTIVE_LOW, IPT_UNUSED )
 INPUT_PORTS_END
 
+static INPUT_PORTS_START( wargodsa ) /* For Medium Res only versions */
+	PORT_INCLUDE(wargods)
+
+	PORT_MODIFY("DIPS")
+	PORT_DIPNAME( 0x0001, 0x0001, DEF_STR( Unknown ) )		PORT_DIPLOCATION("SW1:1") /* Manual shows Not Used (must be Off) */
+	PORT_DIPSETTING(      0x0001, DEF_STR( Off ) )
+	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
+INPUT_PORTS_END
 
 
 /*************************************
@@ -1597,7 +1606,18 @@
 |-----------------------------|  |---------------------------------------|  |---------------------------------------|
 */
 
-ROM_START( wargods ) /* Boot EPROM Version 1.0, Game Type: 452 (12/11/1995) */
+ROM_START( wargods ) /* Boot EPROM Version 1.0, Game Type: 452 (10/09/1996) */
+	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* sound data */
+	ROM_LOAD16_BYTE( "u2.rom",   0x000000, 0x8000, CRC(bec7d3ae) SHA1(db80aa4a645804a4574b07b9f34dec6b6b64190d) )
+
+	ROM_REGION32_LE( 0x1000000, "user1", 0 )
+	ROM_LOAD( "u41.rom", 0x000000, 0x20000, CRC(398c54cc) SHA1(6c4b5d6ec5c844dcbf181f9d86a9196a088ed2db) )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE( "wargods_10-09-1996", 0, SHA1(7585bc65b1038589cb59d3e7c56e08ca9d7015b8) )
+ROM_END
+
+ROM_START( wargodsa ) /* Boot EPROM Version 1.0, Game Type: 452 (08/15/1996) */
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* sound data */
 	ROM_LOAD16_BYTE( "u2.rom",   0x000000, 0x8000, CRC(bec7d3ae) SHA1(db80aa4a645804a4574b07b9f34dec6b6b64190d) )
 
@@ -1605,7 +1625,18 @@
 	ROM_LOAD( "u41.rom", 0x000000, 0x20000, CRC(398c54cc) SHA1(6c4b5d6ec5c844dcbf181f9d86a9196a088ed2db) )
 
 	DISK_REGION( "drive_0" )
-	DISK_IMAGE( "wargods", 0, SHA1(141063f95867fdcc4b15c844e510696604a70c6a) )
+	DISK_IMAGE( "wargods_08-15-1996", 0, SHA1(5dee00be40c315fbb1d6e3994dae8e498ab87fb2) )
+ROM_END
+
+ROM_START( wargodsb ) /* Boot EPROM Version 1.0, Game Type: 452 (12/11/1995) */
+	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* sound data */
+	ROM_LOAD16_BYTE( "u2.rom",   0x000000, 0x8000, CRC(bec7d3ae) SHA1(db80aa4a645804a4574b07b9f34dec6b6b64190d) )
+
+	ROM_REGION32_LE( 0x1000000, "user1", 0 )
+	ROM_LOAD( "u41.rom", 0x000000, 0x20000, CRC(398c54cc) SHA1(6c4b5d6ec5c844dcbf181f9d86a9196a088ed2db) )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE( "wargods_12-11-1995", 0, SHA1(141063f95867fdcc4b15c844e510696604a70c6a) )
 ROM_END
 
 
@@ -1728,10 +1759,12 @@
 GAME( 1996, crusnwld17, crusnwld, midvunit, crusnwld, crusnwld, ROT0, "Midway", "Cruis'n World (rev L1.7)", GAME_SUPPORTS_SAVE )
 GAME( 1996, crusnwld13, crusnwld, midvunit, crusnwld, crusnwld, ROT0, "Midway", "Cruis'n World (rev L1.3)", GAME_SUPPORTS_SAVE )
 
-GAME( 1997, offroadc,  0,        midvunit, offroadc, offroadc, ROT0, "Midway", "Off Road Challenge (v1.63)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
-GAME( 1997, offroadc5, offroadc, midvunit, offroadc, offroadc, ROT0, "Midway", "Off Road Challenge (v1.50)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
-GAME( 1997, offroadc4, offroadc, midvunit, offroadc, offroadc, ROT0, "Midway", "Off Road Challenge (v1.40)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
-GAME( 1997, offroadc3, offroadc, midvunit, offroadc, offroadc, ROT0, "Midway", "Off Road Challenge (v1.30)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
-GAME( 1997, offroadc1, offroadc, midvunit, offroadc, offroadc, ROT0, "Midway", "Off Road Challenge (v1.10)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
-
-GAME( 1995, wargods,  0,        midvplus, wargods,  wargods,  ROT0, "Midway", "War Gods", GAME_SUPPORTS_SAVE )
+GAME( 1997, offroadc,  0,        midvunit, offroadc, offroadc, ROT0, "Midway", "Off Road Challenge (v1.63)", GAME_SUPPORTS_SAVE )
+GAME( 1997, offroadc5, offroadc, midvunit, offroadc, offroadc, ROT0, "Midway", "Off Road Challenge (v1.50)", GAME_SUPPORTS_SAVE )
+GAME( 1997, offroadc4, offroadc, midvunit, offroadc, offroadc, ROT0, "Midway", "Off Road Challenge (v1.40)", GAME_SUPPORTS_SAVE )
+GAME( 1997, offroadc3, offroadc, midvunit, offroadc, offroadc, ROT0, "Midway", "Off Road Challenge (v1.30)", GAME_SUPPORTS_SAVE )
+GAME( 1997, offroadc1, offroadc, midvunit, offroadc, offroadc, ROT0, "Midway", "Off Road Challenge (v1.10)", GAME_SUPPORTS_SAVE )
+
+GAME( 1995, wargods,   0,        midvplus, wargods,  wargods,  ROT0, "Midway", "War Gods (HD 10/09/1996 - Dual Resolution)", GAME_SUPPORTS_SAVE )
+GAME( 1995, wargodsa,  wargods,  midvplus, wargodsa, wargods,  ROT0, "Midway", "War Gods (HD 08/15/1996)", GAME_SUPPORTS_SAVE )
+GAME( 1995, wargodsb,  wargods,  midvplus, wargodsa, wargods,  ROT0, "Midway", "War Gods (HD 12/11/1995)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/midyunit.c src/mame/drivers/midyunit.c
--- src-old/mame/drivers/midyunit.c	2012-05-25 16:38:46.000000000 +0200
+++ src/mame/drivers/midyunit.c	2012-06-29 00:59:24.000000000 +0200
@@ -2357,7 +2357,7 @@
 
 	/* A 'NIBBLE BOARD' daughtercard holding a GAL16V8A-2SP, 27C040 EPROM and a 9.8304MHz XTAL plugs into the U89 socket */
 	ROM_REGION16_LE( 0x100000, "user1", 0 )	/* 34010 code */
-	ROM_LOAD16_BYTE( "turbo30.u105", 0x00000, 0x80000, CRC(29680b34) SHA1(a4c911b9872be38597913f946a4bcc1039e7d85d) )
+	ROM_LOAD16_BYTE( "turbo30.u105", 0x00000, 0x80000, CRC(59747c59) SHA1(69e1450a6b2b41b8939ce84903cb35c1906b81e2) )
 	ROM_LOAD16_BYTE(  "turbo30.u89", 0x00001, 0x80000, CRC(84d66a75) SHA1(11ee7ae7fc1c13cafa8312f101878393ae6fd8b7) )
         ROM_REGION( 0x800000, "gfx1", 0 )
 	ROM_LOAD ( "mkg-u111.rom",  0x000000, 0x80000, CRC(d17096c4) SHA1(01ef390a372c9d94adf138f9543ebb88b89f4c38) )
diff -Nru src-old/mame/drivers/missile.c src/mame/drivers/missile.c
--- src-old/mame/drivers/missile.c	2012-05-28 02:43:41.000000000 +0200
+++ src/mame/drivers/missile.c	2012-07-02 09:06:11.000000000 +0200
@@ -6,7 +6,7 @@
         * Missile Command
 
     Known issues:
-        * none at this time
+        * bootleg sets don't work yet
 
 ******************************************************************************************
 
@@ -320,10 +320,10 @@
                                 On  ( Unused )
                                 Off ( Unused )
 
-    -there are 2 different versions of the Super Missile Attack board.  It's not known if
+    There are 2 different versions of the Super Missile Attack board.  It's not known if
     the roms are different.  The SMA manual mentions a set 3(035822-03E) that will work
     as well as set 2. Missile Command set 1 will not work with the SMA board. It would
-        appear set 1 and set 2 as labeled by mame are reversed.
+    appear set 1 and set 2 as labeled by mame are reversed.
 
 ****************************************************************************
 
@@ -356,10 +356,14 @@
 {
 public:
 	missile_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) ,
-		m_videoram(*this, "videoram"){ }
+		: driver_device(mconfig, type, tag),
+		m_maincpu(*this,"maincpu"),
+		m_videoram(*this, "videoram")
+	{ }
 
+	required_device<m6502_device> m_maincpu;
 	required_shared_ptr<UINT8> m_videoram;
+
 	const UINT8 *m_writeprom;
 	emu_timer *m_irq_timer;
 	emu_timer *m_cpu_timer;
@@ -368,6 +372,7 @@
 	UINT8 m_flipscreen;
 	UINT8 m_madsel_delay;
 	UINT16 m_madsel_lastpc;
+
 	DECLARE_WRITE8_MEMBER(missile_w);
 	DECLARE_READ8_MEMBER(missile_r);
 	DECLARE_CUSTOM_INPUT_MEMBER(get_vblank);
@@ -387,16 +392,6 @@
 #define VBEND			(25)	/* 24 causes a garbage line at the top of the screen */
 
 
-/*************************************
- *
- *  Globals
- *
- *************************************/
-
-
-
-
-
 
 /*************************************
  *
@@ -443,7 +438,7 @@
 
 	/* assert the IRQ if not already asserted */
 	state->m_irq_state = (~curv >> 5) & 1;
-	cputag_set_input_line(machine, "maincpu", 0, state->m_irq_state ? ASSERT_LINE : CLEAR_LINE);
+	device_set_input_line(state->m_maincpu, 0, state->m_irq_state ? ASSERT_LINE : CLEAR_LINE);
 
 	/* force an update while we're here */
 	machine.primary_screen->update_partial(v_to_scanline(state, curv));
@@ -475,9 +470,9 @@
 
 	/* starting at scanline 224, the CPU runs at half speed */
 	if (curv == 224)
-		machine.device("maincpu")->set_unscaled_clock(MASTER_CLOCK/16);
+		state->m_maincpu->set_unscaled_clock(MASTER_CLOCK/16);
 	else
-		machine.device("maincpu")->set_unscaled_clock(MASTER_CLOCK/8);
+		state->m_maincpu->set_unscaled_clock(MASTER_CLOCK/8);
 
 	/* scanline for the next run */
 	curv ^= 224;
@@ -513,12 +508,13 @@
 static MACHINE_START( missile )
 {
 	missile_state *state = machine.driver_data<missile_state>();
+
 	/* initialize globals */
 	state->m_writeprom = state->memregion("proms")->base();
 	state->m_flipscreen = 0;
 
 	/* set up an opcode base handler since we use mapped handlers for RAM */
-	address_space *space = machine.device<m6502_device>("maincpu")->space(AS_PROGRAM);
+	address_space *space = state->m_maincpu->space(AS_PROGRAM);
 	space->set_direct_update_handler(direct_update_delegate(FUNC(missile_state::missile_direct_handler), state));
 
 	/* create a timer to speed/slow the CPU */
@@ -542,7 +538,7 @@
 static MACHINE_RESET( missile )
 {
 	missile_state *state = machine.driver_data<missile_state>();
-	cputag_set_input_line(machine, "maincpu", 0, CLEAR_LINE);
+	device_set_input_line(state->m_maincpu, 0, CLEAR_LINE);
 	state->m_irq_state = 0;
 }
 
@@ -761,7 +757,7 @@
 	{
 		if (m_irq_state)
 		{
-			cputag_set_input_line(machine(), "maincpu", 0, CLEAR_LINE);
+			device_set_input_line(m_maincpu, 0, CLEAR_LINE);
 			m_irq_state = 0;
 		}
 	}
@@ -1146,6 +1142,31 @@
 
 /*
 
+Missile Command Multigame, produced by Braze Technologies
+from 2005(1st version) to 2007(version 1d). This kit combines
+Missile Command and Super Missile Attack on a daughterboard
+plugged into the main pcb cpu slot.
+
+- M6502 CPU (from main pcb)
+- 27C512 64KB EPROM
+- 93C46P E2PROM for saving highscore/settings
+- two 74LS chips (labels sandpapered off)
+
+*/
+
+ROM_START( missilem )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00 ) // banked, decrypted rom goes here
+
+	ROM_REGION( 0x10000, "user1", 0 )
+	ROM_LOAD("mcm001d.512", 0x00000, 0x10000, CRC(0a5845b5) SHA1(4828866018a984e7cd7f55a33613f43ece5d8d63) )
+
+	ROM_REGION( 0x0020, "proms", 0 )
+	ROM_LOAD( "035826-01.l6", 0x0000, 0x0020, CRC(86a22140) SHA1(2beebf7855e29849ada1823eae031fc98220bc43) )
+ROM_END
+
+
+/*
+
 Missile Combat bootlegs by 'Videotron'
 
 1x 6502A (main)
@@ -1279,6 +1300,26 @@
 	}
 }
 
+static DRIVER_INIT( missilem )
+{
+	UINT8 *src = machine.root_device().memregion("user1")->base();
+	UINT8 *dest = machine.root_device().memregion("maincpu")->base();
+
+	// decrypt rom and put in maincpu region (result looks correct, but is untested)
+	for (int i = 0; i < 0x10000; i++)
+	{
+		int a = BITSWAP16(i, 15,2,3,0,8,9,7,5,1,4,6,14,13,12,10,11);
+		int d = BITSWAP8(src[a], 3,2,4,5,6,1,7,0);
+
+		a = i;
+		a ^= (~a >> 1 & 0x400);
+		a ^= (~a >> 4 & 0x100);
+		a ^= ( a >> 7 & 0x100);
+
+		dest[a] = d;
+	}
+}
+
 
 /*************************************
  *
@@ -1293,6 +1334,7 @@
 GAME( 1981, suprmatkd,missile, missile, suprmatk,        0, ROT0, "Atari / General Computer Corporation", "Super Missile Attack (not encrypted)", GAME_SUPPORTS_SAVE )
 
 /* the bootlegs are on different hardware and don't work */
-GAME( 198?, mcombat,  missile, missile, missile,         0, ROT0, "bootleg (Videotron)", "Missile Combat (Videotron bootleg, set 1)", GAME_NOT_WORKING )
-GAME( 198?, mcombata, missile, missile, missile,         0, ROT0, "bootleg (Videotron)", "Missile Combat (Videotron bootleg, set 2)", GAME_NOT_WORKING )
-GAME( 198?, mcombats, missile, missile, missile,         0, ROT0, "bootleg (Sidam)", "Missile Combat (Sidam bootleg)", GAME_NOT_WORKING )
+GAME( 1980, mcombat,  missile, missile, missile,         0, ROT0, "bootleg (Videotron)", "Missile Combat (Videotron bootleg, set 1)", GAME_NOT_WORKING )
+GAME( 1980, mcombata, missile, missile, missile,         0, ROT0, "bootleg (Videotron)", "Missile Combat (Videotron bootleg, set 2)", GAME_NOT_WORKING )
+GAME( 1980, mcombats, missile, missile, missile,         0, ROT0, "bootleg (Sidam)", "Missile Combat (Sidam bootleg)", GAME_NOT_WORKING )
+GAME( 2005, missilem, missile, missile, missile,  missilem, ROT0, "hack (Braze Technologies)", "Missile Command Multigame", GAME_NOT_WORKING )
diff -Nru src-old/mame/drivers/mw8080bw.c src/mame/drivers/mw8080bw.c
--- src-old/mame/drivers/mw8080bw.c	2012-05-05 22:08:22.000000000 +0200
+++ src/mame/drivers/mw8080bw.c	2012-06-18 00:19:06.000000000 +0200
@@ -2515,11 +2515,6 @@
  *
  *************************************/
 
-#define INVADERS_COIN_INPUT_PORT_TAG	("COIN")
-#define INVADERS_SW6_SW7_PORT_TAG		("SW6SW7")
-#define INVADERS_SW5_PORT_TAG			("SW5")
-
-
 static MACHINE_START( invaders )
 {
 	mw8080bw_state *state = machine.driver_data<mw8080bw_state>();
diff -Nru src-old/mame/drivers/pacman.c src/mame/drivers/pacman.c
--- src-old/mame/drivers/pacman.c	2012-05-21 08:24:12.000000000 +0200
+++ src/mame/drivers/pacman.c	2012-07-02 09:06:11.000000000 +0200
@@ -289,6 +289,8 @@
   Masaya Nakamura is the founder of Namco who originally produced Pac-Man in Japan.
   General Computer Corporation designed Ms. Pac-Man and licensed it to Midway for manufacture in North America.
 
+- Super ABC shows developer credits at boot if IN1 is diconnected.
+
 Boards:
 -------
 - puckman is the same as pacman except they are slotted to break a part and have ribbon cables to connect the halves.
@@ -340,6 +342,7 @@
 #include "cpu/z80/z80.h"
 #include "includes/pacman.h"
 #include "cpu/s2650/s2650.h"
+#include "machine/nvram.h"
 #include "sound/namco.h"
 #include "sound/ay8910.h"
 #include "sound/sn76496.h"
@@ -383,6 +386,12 @@
 	machine.root_device().membank("bank2")->set_entry(whichbank);
 }
 
+static MACHINE_RESET( superabc )
+{
+	pacman_state *state = machine.driver_data<pacman_state>();
+	state->superabc_bank_w(*state->m_maincpu->memory().space(AS_PROGRAM), 0, 0);
+}
+
 
 
 /*************************************
@@ -391,10 +400,31 @@
  *
  *************************************/
 
+static INTERRUPT_GEN( vblank_irq )
+{
+	pacman_state *state = device->machine().driver_data<pacman_state>();
+
+	if(state->m_irq_mask)
+		device_set_input_line(device, 0, HOLD_LINE);
+}
+
+static INTERRUPT_GEN( vblank_nmi )
+{
+	pacman_state *state = device->machine().driver_data<pacman_state>();
+
+	if(state->m_irq_mask)
+		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
+}
+
+WRITE8_MEMBER(pacman_state::irq_mask_w)
+{
+	m_irq_mask = data & 1;
+}
+
 WRITE8_MEMBER(pacman_state::pacman_interrupt_vector_w)
 {
-	device_set_input_line_vector(machine().device("maincpu"), 0, data);
-	cputag_set_input_line(machine(), "maincpu", 0, CLEAR_LINE);
+	device_set_input_line_vector(m_maincpu, 0, data);
+	device_set_input_line(m_maincpu, 0, CLEAR_LINE);
 }
 
 
@@ -458,7 +488,7 @@
 {
 	if (data == 0xfa) data = 0x78;
 	if (data == 0xfc) data = 0xfc;
-	device_set_input_line_vector(machine().device("maincpu"), 0, data );
+	device_set_input_line_vector(m_maincpu, 0, data );
 }
 
 
@@ -467,10 +497,11 @@
 	if (data == 0xbf) data = 0x3c;
 	if (data == 0xc6) data = 0x40;
 	if (data == 0xfc) data = 0xfc;
-	device_set_input_line_vector(machine().device("maincpu"), 0, data );
+	device_set_input_line_vector(m_maincpu, 0, data );
 }
 
 
+
 /*************************************
  *
  *  LEDs/coin counters
@@ -514,7 +545,6 @@
 		pacman_sound_w(machine().device("namco"), offset - 0x10, data);
 }
 
-
 READ8_MEMBER(pacman_state::alibaba_mystery_1_r)
 {
 	/* The return value determines what the mystery item is.  Each bit corresponds
@@ -560,7 +590,6 @@
 	return data;
 }
 
-
 READ8_MEMBER(pacman_state::maketrax_special_port3_r)
 {
 	int pc = cpu_get_previouspc(&space.device());
@@ -624,6 +653,7 @@
 	}
 }
 
+
 /*************************************
  *
  *  Zola kludge
@@ -635,13 +665,13 @@
 	return m_counter++;
 }
 
+
 /************************************
  *
  *  Big Bucks questions roms handlers
  *
  ************************************/
 
-
 WRITE8_MEMBER(pacman_state::bigbucks_bank_w)
 {
 	m_bigbucks_bank = data;
@@ -658,6 +688,7 @@
 	return ret;
 }
 
+
 /************************************
  *
  *  S2650 cpu based games
@@ -721,7 +752,6 @@
  *
  ************************************/
 
-
 READ8_MEMBER(pacman_state::rocktrv2_prot1_data_r)
 {
 	return m_rocktrv2_prot_data[0] >> 4;
@@ -760,17 +790,44 @@
 }
 
 
-READ8_MEMBER(pacman_state::pacman_read_nop)
+/************************************
+ *
+ *  Super ABC
+ *
+ ************************************/
+
+/*
+  This is a kit that upgrades an original Midway Pacman PCB to allow it to run many Pacman games.
+  It includes two small PCBs and two PROMs. The large PCB plugs into the CPU socket at 6B and the
+  Sync Bus Controller socket at 6D. The CPU that was in the socket at 6B plugs into the Super ABC PCB.
+
+  The large PCB contains the following parts.....
+  - Z80 CPU
+  - 27C040 EPROM at U14
+  - 82S123 PROM at U18
+  - 28C16 2KB EEPROM at U17
+  - several logic chips
+
+  The small PCB contains just one 27C010 EPROM for the characters. There's a small cable that joins
+  this PCB to the other large PCB.
+
+  The two PROMs on the main board at 7F and 4A are also replaced with PROMs from the kit
+*/
+
+WRITE8_MEMBER(pacman_state::superabc_bank_w)
 {
-	// Return value of reading the bus with no devices enabled.
-	// This seems to be common but more tests are needed. Ms Pacman reads bytes in sequence
-	// until it hits a 0 for a delimiter, including empty areas.  It writes to "random"
-	// addresses each time. This causes the maze to invert sometimes.  See code at $95c3 where
-	// level($4e13)=134. DW
-	// tests on exactly what determines the value returned have thus far proved inconclusive
-	//return 0xff;
-	return 0xbf;
+	// d4-d6: bank
+	int bank = data >> 4 & 7;
+	membank("bank1")->set_base(memregion("maincpu")->base() + bank * 0x10000 + 0x0000);
+	membank("bank2")->set_base(memregion("maincpu")->base() + bank * 0x10000 + 0x4000);
+	membank("bank3")->set_base(memregion("maincpu")->base() + bank * 0x10000 + 0xa000); // looks like a15 is not connected and a16-onwards is shifted 1 bit
 
+	if (bank != m_charbank)
+	{
+		m_spritebank = bank;
+		m_charbank = bank;
+		m_bg_tilemap->mark_all_dirty();
+	}
 }
 
 
@@ -857,6 +914,18 @@
 WRITE8_MEMBER(pacman_state::mspacman_enable_decode_w){ mspacman_enable_decode_latch(machine()); }
 
 
+READ8_MEMBER(pacman_state::pacman_read_nop)
+{
+	// Return value of reading the bus with no devices enabled.
+	// This seems to be common but more tests are needed. Ms Pacman reads bytes in sequence
+	// until it hits a 0 for a delimiter, including empty areas.  It writes to "random"
+	// addresses each time. This causes the maze to invert sometimes.  See code at $95c3 where
+	// level($4e13)=134. DW
+	// tests on exactly what determines the value returned have thus far proved inconclusive
+	return 0xbf;
+}
+
+
 
 /*************************************
  *
@@ -864,12 +933,6 @@
  *
  *************************************/
 
-WRITE8_MEMBER(pacman_state::irq_mask_w)
-{
-
-	m_irq_mask = data & 1;
-}
-
 static ADDRESS_MAP_START( pacman_map, AS_PROGRAM, 8, pacman_state )
 	//A lot of games don't have an a15 at the cpu.  Generally only games with a cpu daughter board can access the full 32k of romspace.
 	AM_RANGE(0x0000, 0x3fff) AM_MIRROR(0x8000) AM_ROM
@@ -890,14 +953,15 @@
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
-	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")		/* IN0 */
-	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")		/* IN1 */
-	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")		/* DSW1 */
-	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")		/* DSW2 */
+	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")
+	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")
+	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")
+	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")
 ADDRESS_MAP_END
 // The Pacman code uses $5004 and $5005 for LED's and $5007 for coin lockout.  This hardware does not
 // exist on any Pacman or Puckman board I have seen.  DW
 
+
 static ADDRESS_MAP_START( birdiy_map, AS_PROGRAM, 8, pacman_state )
 	AM_RANGE(0x0000, 0x3fff) AM_MIRROR(0x8000) AM_ROM
 	AM_RANGE(0x4000, 0x43ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_videoram_w) AM_SHARE("videoram")
@@ -917,12 +981,13 @@
 //  AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 //  AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
-	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")		/* IN0 */
-	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")		/* IN1 */
-	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")		/* DSW1 */
-	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")		/* DSW2 */
+	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")
+	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")
+	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")
+	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")
 ADDRESS_MAP_END
 
+
 static ADDRESS_MAP_START( mspacman_map, AS_PROGRAM, 8, pacman_state )
 	AM_RANGE(0x4000, 0x43ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_videoram_w) AM_SHARE("videoram")
 	AM_RANGE(0x4400, 0x47ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_colorram_w) AM_SHARE("colorram")
@@ -941,10 +1006,10 @@
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
-	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")		/* IN0 */
-	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")		/* IN1 */
-	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")		/* DSW1 */
-	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")		/* DSW2 */
+	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")
+	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")
+	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")
+	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")
 
 	/* overlay decode enable/disable on top */
 	AM_RANGE(0x0038, 0x003f) AM_READWRITE(mspacman_disable_decode_r_0x0038,mspacman_disable_decode_w)
@@ -981,10 +1046,10 @@
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
-	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")		/* IN0 */
-	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")		/* IN1 */
-	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")		/* DSW1 */
-	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")		/* DSW2 */
+	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")
+	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")
+	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")
+	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")
 	AM_RANGE(0x8000, 0xbfff) AM_ROM
 ADDRESS_MAP_END
 
@@ -1009,9 +1074,9 @@
 	AM_RANGE(0x50c1, 0x50c1) AM_MIRROR(0xaf00) AM_WRITE(pacman_flipscreen_w)
 	AM_RANGE(0x50c2, 0x50c2) AM_MIRROR(0xaf00) AM_WRITE(irq_mask_w)
 	AM_RANGE(0x50c3, 0x50ff) AM_MIRROR(0xaf00) AM_WRITENOP
-	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")		/* IN0 */
-	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")		/* IN1 */
-	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")		/* DSW1 */
+	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")
+	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")
+	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf00) AM_READ(alibaba_mystery_1_r)
 	AM_RANGE(0x50c1, 0x50c1) AM_MIRROR(0xaf00) AM_READ(alibaba_mystery_2_r)
 	AM_RANGE(0x50c2, 0x50ff) AM_MIRROR(0xaf00) AM_READ(pacman_read_nop)
@@ -1039,10 +1104,10 @@
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
-	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")		/* IN0 */
-	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")		/* IN1 */
-	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")		/* DSW1 */
-	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")		/* DSW2 */
+	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")
+	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")
+	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")
+	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")
 	AM_RANGE(0x8000, 0xbfff) AM_ROM
 
 	/* vanvan: probably a leftover from development: the Sanritsu version writes
@@ -1070,10 +1135,10 @@
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
-	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")		/* IN0 */
-	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")		/* IN1 */
-	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")		/* DSW1 */
-	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")		/* DSW2 */
+	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")
+	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")
+	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")
+	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")
 ADDRESS_MAP_END
 
 
@@ -1120,10 +1185,10 @@
 	AM_RANGE(0x50c0, 0x50c0) AM_WRITE(watchdog_reset_w)
 	AM_RANGE(0x5fe0, 0x5fe3) AM_WRITE(rocktrv2_prot_data_w) AM_SHARE("rocktrv2_prot")
 	AM_RANGE(0x5ff0, 0x5ff0) AM_WRITE(rocktrv2_question_bank_w)
-	AM_RANGE(0x5000, 0x5000) AM_READ_PORT("IN0")		/* IN0 */
-	AM_RANGE(0x5040, 0x507f) AM_READ_PORT("IN1")		/* IN1 */
-	AM_RANGE(0x5080, 0x5080) AM_READ_PORT("DSW1")		/* DSW1 */
-	AM_RANGE(0x50c0, 0x50c0) AM_READ_PORT("DSW2")		/* DSW2 */
+	AM_RANGE(0x5000, 0x5000) AM_READ_PORT("IN0")
+	AM_RANGE(0x5040, 0x507f) AM_READ_PORT("IN1")
+	AM_RANGE(0x5080, 0x5080) AM_READ_PORT("DSW1")
+	AM_RANGE(0x50c0, 0x50c0) AM_READ_PORT("DSW2")
 	AM_RANGE(0x5fe0, 0x5fe0) AM_READ(rocktrv2_prot1_data_r)
 	AM_RANGE(0x5fe4, 0x5fe4) AM_READ(rocktrv2_prot2_data_r)
 	AM_RANGE(0x5fe8, 0x5fe8) AM_READ(rocktrv2_prot3_data_r)
@@ -1145,10 +1210,10 @@
 	AM_RANGE(0x5007, 0x5007) AM_WRITENOP /*?*/
 	AM_RANGE(0x5040, 0x505f) AM_DEVWRITE_LEGACY("namco", pacman_sound_w)
 	AM_RANGE(0x50c0, 0x50c0) AM_WRITE(watchdog_reset_w)
-	AM_RANGE(0x5000, 0x503f) AM_READ_PORT("IN0")		/* IN0 */
-	AM_RANGE(0x5040, 0x507f) AM_READ_PORT("IN1")		/* IN1 */
-	AM_RANGE(0x5080, 0x50bf) AM_READ_PORT("DSW1")		/* DSW1 */
-	AM_RANGE(0x50c0, 0x50ff) AM_READ_PORT("DSW2")		/* DSW2 */
+	AM_RANGE(0x5000, 0x503f) AM_READ_PORT("IN0")
+	AM_RANGE(0x5040, 0x507f) AM_READ_PORT("IN1")
+	AM_RANGE(0x5080, 0x50bf) AM_READ_PORT("DSW1")
+	AM_RANGE(0x50c0, 0x50ff) AM_READ_PORT("DSW2")
 	AM_RANGE(0x5100, 0x5100) AM_WRITENOP /*?*/
 	AM_RANGE(0x6000, 0x6000) AM_WRITE(bigbucks_bank_w)
 	AM_RANGE(0x8000, 0x9fff) AM_ROM
@@ -1174,15 +1239,41 @@
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
-	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")		/* IN0 */
-	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")		/* IN1 */
-	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")		/* DSW1 */
-	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")		/* DSW2 */
+	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")
+	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")
+	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")
+	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank2")
 ADDRESS_MAP_END
 
+
+static ADDRESS_MAP_START( superabc_map, AS_PROGRAM, 8, pacman_state )
+	AM_RANGE(0x0000, 0x3fff) AM_ROMBANK("bank1")
+	AM_RANGE(0x4000, 0x43ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_videoram_w) AM_SHARE("videoram")
+	AM_RANGE(0x4400, 0x47ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_colorram_w) AM_SHARE("colorram")
+	AM_RANGE(0x4800, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_SHARE("28c16.u17") // nvram
+	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf38) AM_WRITE(irq_mask_w)
+	AM_RANGE(0x5001, 0x5001) AM_MIRROR(0xaf38) AM_DEVWRITE_LEGACY("namco", pacman_sound_enable_w)
+	AM_RANGE(0x5002, 0x5002) AM_MIRROR(0xaf3c) AM_WRITE(superabc_bank_w)
+	AM_RANGE(0x5003, 0x5003) AM_MIRROR(0xaf38) AM_WRITE(pacman_flipscreen_w)
+	AM_RANGE(0x5004, 0x5005) AM_MIRROR(0xaf38) AM_WRITE(pacman_leds_w)
+	AM_RANGE(0x5007, 0x5007) AM_MIRROR(0xaf38) AM_WRITE(pacman_coin_counter_w)
+	AM_RANGE(0x5040, 0x505f) AM_MIRROR(0xaf00) AM_DEVWRITE_LEGACY("namco", pacman_sound_w)
+	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_SHARE("spriteram2")
+	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
+	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
+	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
+	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf3f) AM_READ_PORT("IN0")
+	AM_RANGE(0x5040, 0x5040) AM_MIRROR(0xaf3f) AM_READ_PORT("IN1")
+	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW1")
+	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_READ_PORT("DSW2")
+	AM_RANGE(0x8000, 0x9fff) AM_ROMBANK("bank2")
+	AM_RANGE(0xa000, 0xbfff) AM_ROMBANK("bank3")
+ADDRESS_MAP_END
+
+
 static ADDRESS_MAP_START( crushs_map, AS_PROGRAM, 8, pacman_state )
-	//A lot of games don't have an a15 at the cpu.  Generally only games with a cpu daughter board can access the full 32k of romspace.
 	AM_RANGE(0x0000, 0x3fff) AM_MIRROR(0x8000) AM_ROM
 	AM_RANGE(0x4000, 0x43ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_videoram_w) AM_SHARE("videoram")
 	AM_RANGE(0x4400, 0x47ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_colorram_w) AM_SHARE("colorram")
@@ -1265,7 +1356,7 @@
 static ADDRESS_MAP_START( drivfrcp_portmap, AS_IO, 8, pacman_state )
 	AM_RANGE(0x00, 0x00) AM_READNOP
 	AM_RANGE(0x01, 0x01) AM_READ(drivfrcp_port1_r)
-	AM_RANGE(S2650_SENSE_PORT, S2650_SENSE_PORT) AM_READ_PORT("Sense")
+	AM_RANGE(S2650_SENSE_PORT, S2650_SENSE_PORT) AM_READ_PORT("SENSE")
 	AM_IMPORT_FROM(s2650games_writeport)
 ADDRESS_MAP_END
 
@@ -1273,13 +1364,13 @@
 	AM_RANGE(0x00, 0x00) AM_READNOP
 	AM_RANGE(0x01, 0x01) AM_READ(_8bpm_port1_r)
 	AM_RANGE(0xe0, 0xe0) AM_READNOP
-	AM_RANGE(S2650_SENSE_PORT, S2650_SENSE_PORT) AM_READ_PORT("Sense")
+	AM_RANGE(S2650_SENSE_PORT, S2650_SENSE_PORT) AM_READ_PORT("SENSE")
 	AM_IMPORT_FROM(s2650games_writeport)
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( porky_portmap, AS_IO, 8, pacman_state )
 	AM_RANGE(0x01, 0x01) AM_READ(porky_port1_r)
-	AM_RANGE(S2650_SENSE_PORT, S2650_SENSE_PORT) AM_READ_PORT("Sense")
+	AM_RANGE(S2650_SENSE_PORT, S2650_SENSE_PORT) AM_READ_PORT("SENSE")
 	AM_IMPORT_FROM(s2650games_writeport)
 ADDRESS_MAP_END
 
@@ -1348,7 +1439,6 @@
 
 	PORT_START("DSW2")
 	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_UNUSED )
-
 INPUT_PORTS_END
 
 
@@ -1402,7 +1492,6 @@
 
 	PORT_START("DSW2")
 	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_UNUSED )
-
 INPUT_PORTS_END
 
 
@@ -1521,6 +1610,20 @@
 	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
 INPUT_PORTS_END
 
+
+static INPUT_PORTS_START( superabc )
+	PORT_INCLUDE( pacman )
+
+	PORT_MODIFY("DSW1")
+	PORT_DIPNAME( 0x30, 0x00, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW:5,6")
+	PORT_DIPSETTING(    0x00, "10000, Allow Continue" )	// also free game in Ultra Pac-Man
+	PORT_DIPSETTING(    0x10, "15000, Allow Continue" )	// also free game in Ultra Pac-Man
+	PORT_DIPSETTING(    0x20, "20000, No Continue" )	// also free life in Ultra Pac-Man
+	PORT_DIPSETTING(    0x30, "None, No Continue" )		// also free life in Ultra Pac-Man
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
+INPUT_PORTS_END
+
+
 static INPUT_PORTS_START( maketrax )
 	PORT_START("IN0")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY
@@ -2203,7 +2306,7 @@
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x00, "Invulnerability (Cheat)" ) PORT_CODE(KEYCODE_F1)
+	PORT_DIPNAME( 0x02, 0x00, "Invulnerability (Cheat)" )
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
 	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Unknown ) )
@@ -2272,15 +2375,10 @@
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_3C ) )
 
 	PORT_START("DSW2")
-	/* turning this on crashes puts the */
-	/* emulated machine in an infinite loop once in a while */
-#if 0
-	PORT_DIPNAME(    0x01, 0x00,"Invulnerability (Cheat)")
+	PORT_DIPNAME( 0x01, 0x00,"Invulnerability (Cheat)")		/* turning this on crashes the emulated machine in an infinite loop once in a while */
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
-	PORT_DIPNAME( 0xff, 0x00, DEF_STR( Unused ) )
-#endif
-	PORT_BIT( 0xfe, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0xfe, IP_ACTIVE_HIGH, IPT_UNUSED )
 INPUT_PORTS_END
 
 
@@ -2805,7 +2903,7 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 
-	PORT_START("Sense")
+	PORT_START("SENSE")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
@@ -2857,7 +2955,7 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 
-	PORT_START("Sense")
+	PORT_START("SENSE")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
@@ -2909,7 +3007,7 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 
-	PORT_START("Sense")
+	PORT_START("SENSE")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
@@ -3098,6 +3196,12 @@
 GFXDECODE_END
 
 
+static GFXDECODE_START( superabc )
+	GFXDECODE_ENTRY( "gfx1", 0x0000, tilelayout,   0, 128 )
+	GFXDECODE_ENTRY( "gfx1", 0x8000, spritelayout, 0, 128 )
+GFXDECODE_END
+
+
 static GFXDECODE_START( crush4 )
 	GFXDECODE_ENTRY( "gfx1", 0x0000, crush4_tilelayout,   0, 128 )
 	GFXDECODE_ENTRY( "gfx1", 0x1000, crush4_spritelayout, 0, 128 )
@@ -3125,22 +3229,6 @@
  *
  *************************************/
 
-static INTERRUPT_GEN( vblank_irq )
-{
-	pacman_state *state = device->machine().driver_data<pacman_state>();
-
-	if(state->m_irq_mask)
-		device_set_input_line(device, 0, HOLD_LINE);
-}
-
-static INTERRUPT_GEN( vblank_nmi )
-{
-	pacman_state *state = device->machine().driver_data<pacman_state>();
-
-	if(state->m_irq_mask)
-		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
-}
-
 static MACHINE_CONFIG_START( pacman, pacman_state )
 
 	/* basic machine hardware */
@@ -3365,6 +3453,21 @@
 MACHINE_CONFIG_END
 
 
+static MACHINE_CONFIG_DERIVED( superabc, pacman )
+
+	/* basic machine hardware */
+	MCFG_CPU_MODIFY("maincpu")
+	MCFG_CPU_PROGRAM_MAP(superabc_map)
+
+	MCFG_NVRAM_ADD_0FILL("28c16.u17")
+
+	MCFG_MACHINE_RESET(superabc)
+
+	/* video hardware */
+	MCFG_GFXDECODE(superabc)
+MACHINE_CONFIG_END
+
+
 static MACHINE_CONFIG_DERIVED( crush4, mschamp )
 
 	/* basic machine hardware */
@@ -4196,6 +4299,50 @@
 ROM_END
 
 
+ROM_START( superabc )
+	ROM_REGION( 0x80000, "maincpu", 0 )
+	ROM_LOAD( "superabc.u14", 0x00000, 0x80000, CRC(a560efe6) SHA1(c7d43cc3bb3b1b10d06403462276231bfc8542dd) )	/* banked */
+
+	ROM_REGION( 0x10000, "gfx1", ROMREGION_ERASE00 ) // descrambled rom goes here
+
+	ROM_REGION( 0x20000, "user1", 0 )
+	ROM_LOAD( "char5e5f.u1",  0x00000, 0x20000, CRC(45caace0) SHA1(f850bd09ec68b0263ac8b30ae38c3878c7978ace) )
+
+	ROM_REGION( 0x0120, "proms", 0 )	/* color PROMs */
+	ROM_LOAD( "82s123.7f",  0x0000, 0x0020, CRC(3a188666) SHA1(067386e477ce48bbde3cf71f744a78a42238d236) )
+	ROM_LOAD( "82s129.4a",  0x0020, 0x0100, CRC(4382c049) SHA1(5e535b1a6852260f38ae1e5cd57290a85cb6927f) )
+
+	ROM_REGION( 0x0200, "namco", 0 )	/* sound PROMs */
+	ROM_LOAD( "82s126.1m",  0x0000, 0x0100, CRC(a9cc86bf) SHA1(bbcec0570aeceb582ff8238a4bc8546a23430081) )
+	ROM_LOAD( "82s126.3m",  0x0100, 0x0100, CRC(77245b66) SHA1(0c4d0bee858b97632411c440bea6948a74759746) )	/* timing - not used */
+
+	ROM_REGION( 0x0020, "unknown", 0 )
+	ROM_LOAD( "82s123.u18", 0x0000, 0x0020, CRC(23b2863c) SHA1(e62f87d2145e94be06dbd90fa8d9a79760bfcc4b) )	/* prom on daughterboard, unknown function */
+ROM_END
+
+
+ROM_START( superabco )
+	ROM_REGION( 0x80000, "maincpu", 0 )
+	ROM_LOAD( "superabc.u14", 0x00000, 0x80000, CRC(62565ad8) SHA1(cb434c608ee463788b73152d84ce6173bdfa350d) )	/* banked */
+
+	ROM_REGION( 0x10000, "gfx1", ROMREGION_ERASE00 ) // descrambled rom goes here
+
+	ROM_REGION( 0x20000, "user1", 0 )
+	ROM_LOAD( "char5e5f.u1",  0x00000, 0x20000, CRC(45caace0) SHA1(f850bd09ec68b0263ac8b30ae38c3878c7978ace) )
+
+	ROM_REGION( 0x0120, "proms", 0 )	/* color PROMs */
+	ROM_LOAD( "82s123.7f",  0x0000, 0x0020, CRC(3a188666) SHA1(067386e477ce48bbde3cf71f744a78a42238d236) )
+	ROM_LOAD( "82s129.4a",  0x0020, 0x0100, CRC(4382c049) SHA1(5e535b1a6852260f38ae1e5cd57290a85cb6927f) )
+
+	ROM_REGION( 0x0200, "namco", 0 )	/* sound PROMs */
+	ROM_LOAD( "82s126.1m",  0x0000, 0x0100, CRC(a9cc86bf) SHA1(bbcec0570aeceb582ff8238a4bc8546a23430081) )
+	ROM_LOAD( "82s126.3m",  0x0100, 0x0100, CRC(77245b66) SHA1(0c4d0bee858b97632411c440bea6948a74759746) )	/* timing - not used */
+
+	ROM_REGION( 0x0020, "unknown", 0 )
+	ROM_LOAD( "82s123.u18", 0x0000, 0x0020, CRC(23b2863c) SHA1(e62f87d2145e94be06dbd90fa8d9a79760bfcc4b) )	/* prom on daughterboard, unknown function */
+ROM_END
+
+
 ROM_START( crush )
 	ROM_REGION( 2*0x10000, "maincpu", 0 )	/* 64k for code + 64k for opcode copy to hack protection */
 	ROM_LOAD( "crushkrl.6e",  0x0000, 0x1000, CRC(a8dd8f54) SHA1(4e3a973ea74a9e145c6997513b98fc80aa478442) )
@@ -4632,7 +4779,7 @@
  roms marked with a comment were in the set but we're not using them */
 ROM_START( eyeszacb )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-        ROM_LOAD( "zacb_11.bin",  0x0000, 0x0800, CRC(69c1602a) SHA1(47b0935406b7ee2f414de58da1d4e81c6277a0c2) ) // "no diagnostics, bad custom??" (unused)
+	ROM_LOAD( "zacb_11.bin",  0x0000, 0x0800, CRC(69c1602a) SHA1(47b0935406b7ee2f414de58da1d4e81c6277a0c2) ) // "no diagnostics, bad custom??" (unused)
 	ROM_LOAD( "zacb_1.bin",   0x0000, 0x0800, CRC(a4a9d7a0) SHA1(f0b807d2fa347e50df52971aa7539a88f342bad6) )
 	ROM_LOAD( "zacb_5.bin",   0x0800, 0x0800, CRC(c32b3f73) SHA1(80d2e987f0318b984e5c7c4d0b5faa262eebeca4) )
 	ROM_LOAD( "zacb_2.bin",   0x1000, 0x0800, CRC(195b9473) SHA1(62eb16af38cc9004787dc55433ed3db11af44a4b) )
@@ -4659,7 +4806,6 @@
 ROM_END
 
 
-
 /*
 Birdyi by Mama Top
 
@@ -5510,7 +5656,8 @@
 
 static void maketrax_rom_decode(running_machine &machine)
 {
-	address_space *space = machine.device("maincpu")->memory().space(AS_PROGRAM);
+	pacman_state *state = machine.driver_data<pacman_state>();
+	address_space *space = state->m_maincpu->memory().space(AS_PROGRAM);
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, 0x4000);
 	UINT8 *rom = machine.root_device().memregion("maincpu")->base();
 
@@ -5535,15 +5682,16 @@
 {
 	/* set up protection handlers */
 	pacman_state *state = machine.driver_data<pacman_state>();
-	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0x5080, 0x50bf, read8_delegate(FUNC(pacman_state::maketrax_special_port2_r),state));
-	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0x50c0, 0x50ff, read8_delegate(FUNC(pacman_state::maketrax_special_port3_r),state));
+	state->m_maincpu->memory().space(AS_PROGRAM)->install_read_handler(0x5080, 0x50bf, read8_delegate(FUNC(pacman_state::maketrax_special_port2_r),state));
+	state->m_maincpu->memory().space(AS_PROGRAM)->install_read_handler(0x50c0, 0x50ff, read8_delegate(FUNC(pacman_state::maketrax_special_port3_r),state));
 
 	maketrax_rom_decode(machine);
 }
 
 static void korosuke_rom_decode(running_machine &machine)
 {
-	address_space *space = machine.device("maincpu")->memory().space(AS_PROGRAM);
+	pacman_state *state = machine.driver_data<pacman_state>();
+	address_space *space = state->m_maincpu->memory().space(AS_PROGRAM);
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, 0x4000);
 	UINT8 *rom = machine.root_device().memregion("maincpu")->base();
 
@@ -5568,8 +5716,8 @@
 {
 	/* set up protection handlers */
 	pacman_state *state = machine.driver_data<pacman_state>();
-	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0x5080, 0x5080, read8_delegate(FUNC(pacman_state::korosuke_special_port2_r),state));
-	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0x50c0, 0x50ff, read8_delegate(FUNC(pacman_state::korosuke_special_port3_r),state));
+	state->m_maincpu->memory().space(AS_PROGRAM)->install_read_handler(0x5080, 0x5080, read8_delegate(FUNC(pacman_state::korosuke_special_port2_r),state));
+	state->m_maincpu->memory().space(AS_PROGRAM)->install_read_handler(0x50c0, 0x50ff, read8_delegate(FUNC(pacman_state::korosuke_special_port3_r),state));
 
 	korosuke_rom_decode(machine);
 }
@@ -5662,7 +5810,6 @@
 	int i;
 
 	/* copy forty 8-byte patches into Pac-Man code */
-
 	for (i = 0; i < 8; i++)
 	{
 		ROM[0x0410+i] = ROM[0x8008+i];
@@ -5873,12 +6020,21 @@
 {
 	// protection
 	pacman_state *state = machine.driver_data<pacman_state>();
-	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0x504d, 0x506f, read8_delegate(FUNC(pacman_state::mspacii_protection_r), state));
+	state->m_maincpu->memory().space(AS_PROGRAM)->install_read_handler(0x504d, 0x506f, read8_delegate(FUNC(pacman_state::mspacii_protection_r), state));
 }
 
-READ8_MEMBER(pacman_state::cannonbp_protection_r)
+static DRIVER_INIT( superabc )
 {
+	UINT8 *src = machine.root_device().memregion("user1")->base();
+	UINT8 *dest = machine.root_device().memregion("gfx1")->base();
+
+	// descramble gfx
+	for (int i = 0; i < 0x10000; i++)
+		dest[i] = src[BITSWAP24(i,23,22,21,20,19,18,17, 12,13,14,16,15, 11,10,9,8,7,6,5,4,3,2,1,0)];
+}
 
+READ8_MEMBER(pacman_state::cannonbp_protection_r)
+{
 	/* At 6p where a rom would usually be there is an epoxy resin chip with 'Novomatic Industrie' Cannon Ball tm 1984 label. */
 	/* As I have no clue about what shall be in this chip, what follows is only a simulation which is enough to play the game. */
 	switch (offset)
@@ -5923,12 +6079,13 @@
 
 static DRIVER_INIT( cannonbp )
 {
+	pacman_state *state = machine.driver_data<pacman_state>();
+
 	/* extra memory */
-	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_ram(0x4800, 0x4bff);
+	state->m_maincpu->memory().space(AS_PROGRAM)->install_ram(0x4800, 0x4bff);
 
 	/* protection? */
-	pacman_state *state = machine.driver_data<pacman_state>();
-	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0x3000, 0x3fff, read8_delegate(FUNC(pacman_state::cannonbp_protection_r),state));
+	state->m_maincpu->memory().space(AS_PROGRAM)->install_read_handler(0x3000, 0x3fff, read8_delegate(FUNC(pacman_state::cannonbp_protection_r),state));
 }
 
 
@@ -6014,7 +6171,7 @@
 GAME( 1983, acitya,   bwcasino, acitya,   acitya,   0,        ROT90,  "Epos Corporation", "Atlantic City Action", GAME_SUPPORTS_SAVE )
 GAME( 1983, theglobp, suprglob, theglobp, theglobp, 0,        ROT90,  "Epos Corporation", "The Glob (Pac-Man hardware)", GAME_SUPPORTS_SAVE )
 GAME( 1983, sprglobp, suprglob, theglobp, theglobp, 0,        ROT90,  "Epos Corporation", "Super Glob (Pac-Man hardware)", GAME_SUPPORTS_SAVE )
-GAME( 1983, sprglbpg, suprglob, pacman,   theglobp, 0,        ROT90,  "bootleg", "Super Glob (Pac-Man hardware) German", GAME_SUPPORTS_SAVE )
+GAME( 1983, sprglbpg, suprglob, pacman,   theglobp, 0,        ROT90,  "bootleg", "Super Glob (Pac-Man hardware) (German bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1984, beastf,   suprglob, theglobp, theglobp, 0,        ROT90,  "Epos Corporation", "Beastie Feastie", GAME_SUPPORTS_SAVE )
 GAME( 1984, drivfrcp, 0,        drivfrcp, drivfrcp, drivfrcp, ROT90,  "Shinkai Inc. (Magic Eletronics Inc. license)", "Driving Force (Pac-Man conversion)", GAME_SUPPORTS_SAVE )
 GAME( 1985, 8bpm,     8ballact, 8bpm,     8bpm,     8bpm,     ROT90,  "Seatongrove Ltd (Magic Eletronics USA license)", "Eight Ball Action (Pac-Man conversion)", GAME_SUPPORTS_SAVE )
@@ -6023,4 +6180,6 @@
 GAME( 1986, bigbucks, 0,        bigbucks, bigbucks, 0,        ROT90,  "Dynasoft Inc.", "Big Bucks", GAME_SUPPORTS_SAVE )
 GAME( 1992, mschamp,  mspacman, mschamp,  mschamp,  0,        ROT90,  "hack", "Ms. Pacman Champion Edition / Zola-Puc Gal", GAME_SUPPORTS_SAVE ) /* Rayglo version */
 GAME( 1995, mschamps, mspacman, mschamp,  mschamp,  0,        ROT90,  "hack", "Ms. Pacman Champion Edition / Super Zola-Puc Gal", GAME_SUPPORTS_SAVE )
-GAME( 198?, cannonbp, 0,        pacman,   cannonbp, cannonbp, ROT90,  "Novomatic", "Cannon Ball (Pacman Hardware)", GAME_WRONG_COLORS|GAME_SUPPORTS_SAVE )
+GAME( 198?, cannonbp, 0,        pacman,   cannonbp, cannonbp, ROT90,  "Novomatic", "Cannon Ball (Pac-Man Hardware)", GAME_WRONG_COLORS|GAME_SUPPORTS_SAVE )
+GAME( 1999, superabc, 0,        superabc, superabc, superabc, ROT90,  "hack (Two-Bit Score)", "Super ABC (Pac-Man multigame kit, Sep. 03 1999)", GAME_SUPPORTS_SAVE )
+GAME( 1999, superabco,superabc, superabc, superabc, superabc, ROT90,  "hack (Two-Bit Score)", "Super ABC (Pac-Man multigame kit, Mar. 08 1999)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/pgm2.c src/mame/drivers/pgm2.c
--- src-old/mame/drivers/pgm2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/pgm2.c	2012-07-02 09:06:11.000000000 +0200
@@ -1,14 +1,21 @@
-
-
 /* PGM 2 hardware.
 
  Motherboard is bare bones stuff, probably only contains the video processor, no ROMs.
 
- Makes use of internal ROM ASICS, newer than those found on the best protected PGM games.  Games actually boot to a warning screen even if you remove all program roms!
+ Makes use of internal ROM ASICS, newer than those found on the best protected PGM games.
+ Games actually boot to a warning screen even if you remove all program roms!
 
  Encrypted.
 
- I'm guessing it's ARM based, but not sure.
+ Likely ARM based, but until we can obtain decrypted data, we will not know for sure.
+
+
+PGM2 Motherboard Components:
+
+ IS61LV25616AL(SRAM)
+ IGS037(GFX PROCESSOR)
+ YMZ774-S(SOUND)
+ R5F21256SN(extra MCU for protection and ICcard communication)
 
 */
 
@@ -137,7 +144,7 @@
 	MCFG_VIDEO_START(pgm2)
 
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
-    MCFG_YMZ770_ADD("ymz770", 16384000)
+    MCFG_YMZ770_ADD("ymz770", 16384000)  // Actually a YMZ774 on-board
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/pinkiri8.c src/mame/drivers/pinkiri8.c
--- src-old/mame/drivers/pinkiri8.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/drivers/pinkiri8.c	2012-06-13 13:25:45.000000000 +0200
@@ -46,6 +46,8 @@
 		m_janshi_widthflags(*this, "widthflags"),
 		m_janshi_unk2(*this, "unk2"),
 		m_janshi_vram2(*this, "vram2"),
+		m_janshi_paletteram(*this, "paletteram"),
+		m_janshi_paletteram2(*this, "paletteram2"),
 		m_janshi_crtc_regs(*this, "crtc_regs"){ }
 
 	required_shared_ptr<UINT8> m_janshi_back_vram;
@@ -54,6 +56,8 @@
 	required_shared_ptr<UINT8> m_janshi_widthflags;
 	required_shared_ptr<UINT8> m_janshi_unk2;
 	required_shared_ptr<UINT8> m_janshi_vram2;
+	required_shared_ptr<UINT8> m_janshi_paletteram;
+	required_shared_ptr<UINT8> m_janshi_paletteram2;
 	required_shared_ptr<UINT8> m_janshi_crtc_regs;
 	UINT32 m_vram_addr;
 	int m_prev_writes;
@@ -73,24 +77,6 @@
 };
 
 
-static ADDRESS_MAP_START( janshi_vdp_map8, AS_0, 8, pinkiri8_state )
-
-	AM_RANGE(0xfc0000, 0xfc1fff) AM_RAM AM_SHARE("back_vram") // bg tilemap?
-	AM_RANGE(0xfc2000, 0xfc2fff) AM_RAM AM_SHARE("vram1") // xpos, colour, tile number etc.
-
-	AM_RANGE(0xfc3700, 0xfc377f) AM_RAM AM_SHARE("unk1") // ?? height related?
-	AM_RANGE(0xfc3780, 0xfc37bf) AM_RAM AM_SHARE("widthflags")
-	AM_RANGE(0xfc37c0, 0xfc37ff) AM_RAM AM_SHARE("unk2") // 2x increasing tables 00 10 20 30 etc.
-
-	AM_RANGE(0xfc3800, 0xfc3fff) AM_RAM AM_SHARE("vram2") // y pos + unknown
-
-	AM_RANGE(0xff0000, 0xff07ff) AM_RAM_WRITE(paletteram_xBBBBBGGGGGRRRRR_byte_split_lo_w) AM_SHARE("paletteram")
-	AM_RANGE(0xff2000, 0xff27ff) AM_RAM_WRITE(paletteram_xBBBBBGGGGGRRRRR_byte_split_hi_w) AM_SHARE("paletteram2")
-
-	AM_RANGE(0xff6000, 0xff601f) AM_RAM AM_SHARE("crtc_regs")
-ADDRESS_MAP_END
-
-
 
 /* VDP device to give us our own memory map */
 
@@ -106,10 +92,33 @@
 	virtual void device_reset();
 	virtual const address_space_config *memory_space_config(address_spacenum spacenum = AS_0) const;
 	address_space_config		m_space_config;
+
+
+
 };
 
+
+static ADDRESS_MAP_START( janshi_vdp_map8, AS_0, 8, janshi_vdp_device )
+
+	AM_RANGE(0xfc0000, 0xfc1fff) AM_RAM AM_SHARE("back_vram") // bg tilemap?
+	AM_RANGE(0xfc2000, 0xfc2fff) AM_RAM AM_SHARE("vram1") // xpos, colour, tile number etc.
+
+	AM_RANGE(0xfc3700, 0xfc377f) AM_RAM AM_SHARE("unk1") // ?? height related?
+	AM_RANGE(0xfc3780, 0xfc37bf) AM_RAM AM_SHARE("widthflags")
+	AM_RANGE(0xfc37c0, 0xfc37ff) AM_RAM AM_SHARE("unk2") // 2x increasing tables 00 10 20 30 etc.
+
+	AM_RANGE(0xfc3800, 0xfc3fff) AM_RAM AM_SHARE("vram2") // y pos + unknown
+
+	AM_RANGE(0xff0000, 0xff07ff) AM_RAM /*AM_RAM_WRITE(paletteram_xBBBBBGGGGGRRRRR_byte_split_lo_w)*/ AM_SHARE("paletteram")
+	AM_RANGE(0xff2000, 0xff27ff) AM_RAM /*AM_RAM_WRITE(paletteram_xBBBBBGGGGGRRRRR_byte_split_hi_w)*/ AM_SHARE("paletteram2")
+
+	AM_RANGE(0xff6000, 0xff601f) AM_RAM AM_SHARE("crtc_regs")
+ADDRESS_MAP_END
+
 const device_type JANSHIVDP = &device_creator<janshi_vdp_device>;
 
+
+
 janshi_vdp_device::janshi_vdp_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
 	: device_t(mconfig, JANSHIVDP, "JANSHIVDP", tag, owner, clock),
 	  device_memory_interface(mconfig, *this),
@@ -117,6 +126,10 @@
 {
 }
 
+
+
+
+
 void janshi_vdp_device::device_config_complete()
 {
 //  int address_bits = 24;
@@ -192,6 +205,16 @@
 	int col_bank;
 	const gfx_element *gfx = screen.machine().gfx[0];
 
+	/* update palette */
+	for (int pen = 0; pen < 0x800 ; pen++)
+	{
+		UINT16 val = (state->m_janshi_paletteram[pen]) | (state->m_janshi_paletteram2[pen]<<8);
+		int r = (val & 0x001f) >> 0;
+		int g = (val & 0x03e0) >> 5;
+		int b = (val & 0x7c00) >> 10;
+		palette_set_color_rgb(screen.machine(), pen, pal5bit(r), pal5bit(g), pal5bit(b));
+	}
+
 	int game_type_hack = 0;
 
 	if (!strcmp(screen.machine().system().name,"janshi")) game_type_hack = 1;
diff -Nru src-old/mame/drivers/qix.c src/mame/drivers/qix.c
--- src-old/mame/drivers/qix.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/qix.c	2012-06-20 00:57:02.000000000 +0200
@@ -630,26 +630,26 @@
 
 ROM_START( qix )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "u12", 0xc000, 0x0800, CRC(aad35508) SHA1(5fa72e00b4373de21e27a86b49a44a9769f769f4) )
-	ROM_LOAD( "u13", 0xc800, 0x0800, CRC(46c13504) SHA1(19c084c38b75f14bf5094b317afeecaca6870f7a) )
-	ROM_LOAD( "u14", 0xd000, 0x0800, CRC(5115e896) SHA1(8359a1700fff7a38e8ea4f92a4f18bc628cf1cb1) )
-	ROM_LOAD( "u15", 0xd800, 0x0800, CRC(ccd52a1b) SHA1(86d134cd769ef12820638b96a4ffedd8b15dffd2) )
-	ROM_LOAD( "u16", 0xe000, 0x0800, CRC(cd1c36ee) SHA1(b379b1fe3109947a12c9683cd0c2400c2ee845b3) )
-	ROM_LOAD( "u17", 0xe800, 0x0800, CRC(1acb682d) SHA1(a2c60964e8d838d09662f8a670c6da41ba850df9) )
-	ROM_LOAD( "u18", 0xf000, 0x0800, CRC(de77728b) SHA1(8e183bb27858aad9a996e4a2e5a95f0145d1f5b4) )
-	ROM_LOAD( "u19", 0xf800, 0x0800, CRC(c0994776) SHA1(9452a98c78a038679c4e58f4a9983adb28ea5e78) )
-
-	ROM_REGION( 0x10000, "videocpu", 0 )
-	ROM_LOAD( "u4",  0xc800, 0x0800, CRC(5b906a09) SHA1(84a2e817d6718e0276fcea702811a91bc054a670) )
-	ROM_LOAD( "u5",  0xd000, 0x0800, CRC(254a3587) SHA1(66045c71cc1d04d4e03c728e578f570fbf7c650d) )
-	ROM_LOAD( "u6",  0xd800, 0x0800, CRC(ace30389) SHA1(50c6275d13cfbca7750d5a3e725faedba7574e04) )
-	ROM_LOAD( "u7",  0xe000, 0x0800, CRC(8ebcfa7c) SHA1(21ccf5e74424ab5470473d1059ee6a43d144f685) )
-	ROM_LOAD( "u8",  0xe800, 0x0800, CRC(b8a3c8f9) SHA1(32ba771913ef44b1133ecfaedaae7f96dcc84343) )
-	ROM_LOAD( "u9",  0xf000, 0x0800, CRC(26cbcd55) SHA1(2e55e222f850548cd1d461ab5337e98dd817b567) )
-	ROM_LOAD( "u10", 0xf800, 0x0800, CRC(568be942) SHA1(8b6a01d983d355a64372fa76af810ab53e09d5df) )
+	ROM_LOAD( "qq12_rev2.u12", 0xc000, 0x0800, CRC(aad35508) SHA1(5fa72e00b4373de21e27a86b49a44a9769f769f4) )
+	ROM_LOAD( "qq13_rev2.u13", 0xc800, 0x0800, CRC(46c13504) SHA1(19c084c38b75f14bf5094b317afeecaca6870f7a) )
+	ROM_LOAD( "qq14_rev2.u14", 0xd000, 0x0800, CRC(5115e896) SHA1(8359a1700fff7a38e8ea4f92a4f18bc628cf1cb1) )
+	ROM_LOAD( "qq15_rev2.u15", 0xd800, 0x0800, CRC(ccd52a1b) SHA1(86d134cd769ef12820638b96a4ffedd8b15dffd2) )
+	ROM_LOAD( "qq16_rev2.u16", 0xe000, 0x0800, CRC(cd1c36ee) SHA1(b379b1fe3109947a12c9683cd0c2400c2ee845b3) )
+	ROM_LOAD( "qq17_rev2.u17", 0xe800, 0x0800, CRC(1acb682d) SHA1(a2c60964e8d838d09662f8a670c6da41ba850df9) )
+	ROM_LOAD( "qq18_rev2.u18", 0xf000, 0x0800, CRC(de77728b) SHA1(8e183bb27858aad9a996e4a2e5a95f0145d1f5b4) )
+	ROM_LOAD( "qq19_rev2.u19", 0xf800, 0x0800, CRC(c0994776) SHA1(9452a98c78a038679c4e58f4a9983adb28ea5e78) )
+
+	ROM_REGION( 0x10000, "videocpu", 0 )
+	ROM_LOAD( "qq4_rev2.u4",   0xc800, 0x0800, CRC(5b906a09) SHA1(84a2e817d6718e0276fcea702811a91bc054a670) )
+	ROM_LOAD( "qq5_rev2.u5",   0xd000, 0x0800, CRC(254a3587) SHA1(66045c71cc1d04d4e03c728e578f570fbf7c650d) )
+	ROM_LOAD( "qq6_rev2.u6",   0xd800, 0x0800, CRC(ace30389) SHA1(50c6275d13cfbca7750d5a3e725faedba7574e04) )
+	ROM_LOAD( "qq7_rev2.u7",   0xe000, 0x0800, CRC(8ebcfa7c) SHA1(21ccf5e74424ab5470473d1059ee6a43d144f685) )
+	ROM_LOAD( "qq8_rev2.u8",   0xe800, 0x0800, CRC(b8a3c8f9) SHA1(32ba771913ef44b1133ecfaedaae7f96dcc84343) )
+	ROM_LOAD( "qq9_rev2.u9",   0xf000, 0x0800, CRC(26cbcd55) SHA1(2e55e222f850548cd1d461ab5337e98dd817b567) )
+	ROM_LOAD( "qq10_rev2.u10", 0xf800, 0x0800, CRC(568be942) SHA1(8b6a01d983d355a64372fa76af810ab53e09d5df) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "u27", 0xf800, 0x0800, CRC(f3782bd0) SHA1(bfc6d29f9668e02857453e96c005c81568ae931d) )
+	ROM_LOAD( "qq27.u27", 0xf800, 0x0800, CRC(f3782bd0) SHA1(bfc6d29f9668e02857453e96c005c81568ae931d) )
 ROM_END
 
 // original taito board 08-00003-001
@@ -675,7 +675,7 @@
 	ROM_LOAD( "u10_", 0xf800, 0x0800, CRC(b40f084a) SHA1(16811b8f24b955a72f2a0950e9688cbd0e26afa4) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "u27",     0xf800, 0x0800, CRC(f3782bd0) SHA1(bfc6d29f9668e02857453e96c005c81568ae931d) )
+	ROM_LOAD( "qq27.u27", 0xf800, 0x0800, CRC(f3782bd0) SHA1(bfc6d29f9668e02857453e96c005c81568ae931d) )
 ROM_END
 
 // same set as above, but with larger roms
@@ -693,20 +693,20 @@
 	ROM_LOAD( "lk13.bin", 0xf000, 0x1000, CRC(51c9853b) SHA1(29a5221f2af866d2ee73110409ecddc2c96404fd) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "u27",      0xf800, 0x0800, CRC(f3782bd0) SHA1(bfc6d29f9668e02857453e96c005c81568ae931d) )
+	ROM_LOAD( "qq27.u27", 0xf800, 0x0800, CRC(f3782bd0) SHA1(bfc6d29f9668e02857453e96c005c81568ae931d) )
 ROM_END
 
 
-ROM_START( qixo )
+ROM_START( qixo ) /* ROMs might have the "QX" game prefix instead of "QU" this is verified */
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "qu12", 0xc000, 0x0800, CRC(1c55b44d) SHA1(6385e5e484e24cf396c14de86344170639c3cc65) )
 	ROM_LOAD( "qu13", 0xc800, 0x0800, CRC(20279e8c) SHA1(722da239636de3fe40318768ddbe687b19afcdb6) )
 	ROM_LOAD( "qu14", 0xd000, 0x0800, CRC(bafe3ce3) SHA1(648a54545a1b545c82c0ace5eb1ce17af5ea7391) )
 	/* d800-dfff empty */
-	ROM_LOAD( "qu16", 0xe000, 0x0800, CRC(db560753) SHA1(4acbe17f1e555f45606ddec197c5ab691ff46d39) )
+	ROM_LOAD( "qu16", 0xe000, 0x0800, CRC(db560753) SHA1(4acbe17f1e555f45606ddec197c5ab691ff46d39) ) /* The QX version labels this rom as QX16-1 */
 	ROM_LOAD( "qu17", 0xe800, 0x0800, CRC(8c7aeed8) SHA1(b7da2b0f34f72f9853cdf6ce55e604b09fcf4728) )
 	ROM_LOAD( "qu18", 0xf000, 0x0800, CRC(353be980) SHA1(a50e02fcc69771a13b238aa0e8dc3c56b01a58d5) )
-	ROM_LOAD( "qu19", 0xf800, 0x0800, CRC(f46a69ca) SHA1(dacb53c0318445da3fbb86f9a45914c5b7a4c4a1) )
+	ROM_LOAD( "qu19", 0xf800, 0x0800, CRC(f46a69ca) SHA1(dacb53c0318445da3fbb86f9a45914c5b7a4c4a1) ) /* The QX version labels this rom as QX19-1 */
 
 	ROM_REGION( 0x10000, "videocpu", 0 )
 	ROM_LOAD( "qu3",  0xc000, 0x0800, CRC(8b4c0ef0) SHA1(6d18d1052f342e3b3313f2174b20f2a179e2c6bd) )
@@ -719,7 +719,7 @@
 	ROM_LOAD( "qu10", 0xf800, 0x0800, CRC(88b45037) SHA1(e2e5fefe377def3f784026b921527898af8b83a9) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "u27",  0xf800, 0x0800, CRC(f3782bd0) SHA1(bfc6d29f9668e02857453e96c005c81568ae931d) )
+	ROM_LOAD( "qu27.u27", 0xf800, 0x0800, CRC(f3782bd0) SHA1(bfc6d29f9668e02857453e96c005c81568ae931d) )
 ROM_END
 
 
@@ -1326,7 +1326,7 @@
  *
  *************************************/
 
-GAME( 1981, qix,      0,        qix,      qix,      0,       ROT270, "Taito America Corporation", "Qix (set 1)", GAME_SUPPORTS_SAVE ) // newest set?  closest to 'qix2'
+GAME( 1981, qix,      0,        qix,      qix,      0,       ROT270, "Taito America Corporation", "Qix (Rev 2)", GAME_SUPPORTS_SAVE ) // newest set?  closest to 'qix2'
 GAME( 1981, qixa,     qix,      qix,      qix,      0,       ROT270, "Taito America Corporation", "Qix (set 2, smaller roms)", GAME_SUPPORTS_SAVE )
 GAME( 1981, qixb,     qix,      qix,      qix,      0,       ROT270, "Taito America Corporation", "Qix (set 2, larger roms)", GAME_SUPPORTS_SAVE )
 GAME( 1981, qixo,     qix,      qix,      qix,      0,       ROT270, "Taito America Corporation", "Qix (set 3, earlier)", GAME_SUPPORTS_SAVE ) // oldest set / prototype? has incorrect spelling 'deutch' and doesn't allow language selection to be changed
diff -Nru src-old/mame/drivers/quakeat.c src/mame/drivers/quakeat.c
--- src-old/mame/drivers/quakeat.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/quakeat.c	2012-06-15 16:46:41.000000000 +0200
@@ -106,7 +106,7 @@
 //  AM_RANGE(0x0278, 0x027b) AM_WRITE_LEGACY(pnp_config_w)
 //  AM_RANGE(0x03f0, 0x03ff) AM_DEVREADWRITE_LEGACY("ide", fdc_r, fdc_w)
 //  AM_RANGE(0x0a78, 0x0a7b) AM_WRITE_LEGACY(pnp_data_w)
-//  AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE_LEGACY("pcibus", pci_32le_r,  pci_32le_w)
+//  AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_bus_device, read, write)
 ADDRESS_MAP_END
 
 /*************************************************************
diff -Nru src-old/mame/drivers/queen.c src/mame/drivers/queen.c
--- src-old/mame/drivers/queen.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/queen.c	2012-07-02 08:20:21.000000000 +0200
@@ -542,7 +542,7 @@
 	AM_RANGE(0x01f0, 0x01f7) AM_READWRITE(ide_r, ide_w)
 	AM_RANGE(0x03f0, 0x03f7) AM_READWRITE(fdc_r, fdc_w)
 
-	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE_LEGACY("pcibus", pci_32le_r,	pci_32le_w)
+	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_bus_legacy_device, read, write)
 ADDRESS_MAP_END
 
 static const struct pit8253_config queen_pit8254_config =
@@ -689,9 +689,9 @@
 
 	MCFG_MC146818_ADD( "rtc", MC146818_STANDARD )
 
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
-	MCFG_PCI_BUS_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
 
 	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL, true)
 
diff -Nru src-old/mame/drivers/raiden.c src/mame/drivers/raiden.c
--- src-old/mame/drivers/raiden.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/drivers/raiden.c	2012-06-26 00:10:23.000000000 +0200
@@ -3,7 +3,7 @@
     Raiden                          (c) 1990 Seibu Kaihatsu
     Raiden (Alternate Hardware)     (c) 1990 Seibu Kaihatsu
     Raiden (Korean license)         (c) 1990 Seibu Kaihatsu
-    Raiden (Taiwanese license)          (c) 1990 Seibu Kaihatsu
+    Raiden (Taiwanese license)      (c) 1990 Seibu Kaihatsu
 
     driver by Oliver Bergmann, Bryan McPhail, Randy Mongenel
 
@@ -157,15 +157,15 @@
 	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )
 	/* Coin Mode B */
 	PORT_DIPNAME( 0x0006, 0x0006, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW", 0x0001, NOTEQUALS, 0x0001) PORT_DIPLOCATION("SW1:2,3")
-    PORT_DIPSETTING(      0x0000, "5C/1C or Free if Coin B too" )
-    PORT_DIPSETTING(      0x0002, DEF_STR( 3C_1C ) )
-    PORT_DIPSETTING(      0x0004, DEF_STR( 2C_1C ) )
-    PORT_DIPSETTING(      0x0006, DEF_STR( 1C_1C ) )
-    PORT_DIPNAME( 0x0018, 0x0018, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW", 0x0001, NOTEQUALS, 0x0001) PORT_DIPLOCATION("SW1:4,5")
-    PORT_DIPSETTING(      0x0018, DEF_STR( 1C_2C ) )
-    PORT_DIPSETTING(      0x0010, DEF_STR( 1C_3C ) )
-    PORT_DIPSETTING(      0x0008, DEF_STR( 1C_5C ) )
-    PORT_DIPSETTING(      0x0000, "1C/6C or Free if Coin A too" )
+	PORT_DIPSETTING(      0x0000, "5C/1C or Free if Coin B too" )
+	PORT_DIPSETTING(      0x0002, DEF_STR( 3C_1C ) )
+	PORT_DIPSETTING(      0x0004, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(      0x0006, DEF_STR( 1C_1C ) )
+	PORT_DIPNAME( 0x0018, 0x0018, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW", 0x0001, NOTEQUALS, 0x0001) PORT_DIPLOCATION("SW1:4,5")
+	PORT_DIPSETTING(      0x0018, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(      0x0010, DEF_STR( 1C_3C ) )
+	PORT_DIPSETTING(      0x0008, DEF_STR( 1C_5C ) )
+	PORT_DIPSETTING(      0x0000, "1C/6C or Free if Coin A too" )
 
 	PORT_DIPNAME( 0x0020, 0x0020, "Credits to Start" ) PORT_DIPLOCATION("SW1:6")
 	PORT_DIPSETTING(      0x0020, "1" )
@@ -300,210 +300,251 @@
 
 /***************************************************************************/
 
-ROM_START( raiden )
+/*
+
+Note: Seibu labeled the roms simply as 1 through 10 and didn't generally
+      change the labels at all between versions even though the data was
+      different between them.
+*/
+
+/* These versions use the same board and make use of the region byte at 0x1fffe (0x1fffd also may differ and is used for unknown purpose) */
+
+ROM_START( raiden ) /* from a board with 2 daughter cards, no official board #s? */
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* v30 main cpu */
-	ROM_LOAD16_BYTE( "rai1.bin",   0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
-	ROM_LOAD16_BYTE( "rai2.bin",   0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
-	ROM_LOAD16_BYTE( "rai3.bin",   0x0c0000, 0x20000, CRC(9d735bf5) SHA1(531981eac2ef0c0635f067a649899f98738d5c67) )
-	ROM_LOAD16_BYTE( "rai4.bin",   0x0c0001, 0x20000, CRC(8d184b99) SHA1(71cd4179aa2341d2ceecbb6a9c26f5919d46ca4c) )
+	ROM_LOAD16_BYTE( "1.u0253", 0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
+	ROM_LOAD16_BYTE( "2.u0252", 0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
+	ROM_LOAD16_BYTE( "3.u022",  0x0c0000, 0x20000, CRC(f6af09d0) SHA1(ecd49f3351359ea2d5cbd140c9962d45c5544ecd) ) /* both 3 & 4 had a red "dot" on label, 4 also had printed "J" */
+	ROM_LOAD16_BYTE( "4j.u023", 0x0c0001, 0x20000, CRC(505c4c5d) SHA1(07f61fd1ff24f482a1ae2f86c4c0f32850cbd539) ) /* 0x1fffd == 0x00, 0x1fffe == 0x04 */
 
 	ROM_REGION( 0x100000, "sub", 0 ) /* v30 sub cpu */
-	ROM_LOAD16_BYTE( "rai5.bin",   0x0c0000, 0x20000, CRC(7aca6d61) SHA1(4d80ec87e54d7495b9bdf819b9985b1c8183c80d) )
-	ROM_LOAD16_BYTE( "rai6a.bin",  0x0c0001, 0x20000, CRC(e3d35cc2) SHA1(4329865985aaf3fb524618e2e958563c8fa6ead5) )
+	ROM_LOAD16_BYTE( "5.u042", 0x0c0000, 0x20000, CRC(ed03562e) SHA1(bf6b44fb53fa2321cd52c00fcb43b8ceb6ceffff) )
+	ROM_LOAD16_BYTE( "6.u043", 0x0c0001, 0x20000, CRC(a19d5b5d) SHA1(aa5e5be60b737913e5677f88ebc218302245e5af) )
 
 	ROM_REGION( 0x20000, "audiocpu", 0 ) /* 64k code for sound Z80 */
-	ROM_LOAD( "rai6.bin",     0x000000, 0x08000, CRC(723a483b) SHA1(50e67945e83ea1748fb748de3287d26446d4e0a0) )
-	ROM_CONTINUE(             0x010000, 0x08000 )
+	ROM_LOAD( "8.u212",      0x000000, 0x08000, CRC(cbe055c7) SHA1(34a06a541d059c621d87fdf41546c9d052a61963) )
+	ROM_CONTINUE(            0x010000, 0x08000 )
 	ROM_COPY( "audiocpu", 0, 0x018000, 0x08000 )
 
-	ROM_REGION( 0x010000, "gfx1", 0 )
-	ROM_LOAD( "rai9.bin",     0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* chars */
-	ROM_LOAD( "rai10.bin",    0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) )
+	ROM_REGION( 0x010000, "gfx1", 0 ) /* Chars */
+	ROM_LOAD( "9",  0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* On some PCBs there is no explicit */
+	ROM_LOAD( "10", 0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) ) /* U location for these two roms     */
 
-	ROM_REGION( 0x080000, "gfx2", 0 )
-	ROM_LOAD( "raiu0919.bin", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* tiles */
+	ROM_REGION( 0x080000, "gfx2", 0 ) /* tiles */
+	ROM_LOAD( "sei420", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* tiles @ U105 on this PCB */
 
-	ROM_REGION( 0x080000, "gfx3", 0 )
-	ROM_LOAD( "raiu0920.bin", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* tiles */
+	ROM_REGION( 0x080000, "gfx3", 0 ) /* tiles */
+	ROM_LOAD( "sei430", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* tiles @ U115 on this PCB */
 
-	ROM_REGION( 0x090000, "gfx4", 0 )
-	ROM_LOAD( "raiu165.bin",  0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) ) /* sprites */
+	ROM_REGION( 0x090000, "gfx4", 0 ) /* sprites */
+	ROM_LOAD( "sei440",  0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) )
 
 	ROM_REGION( 0x40000, "oki", 0 )	 /* ADPCM samples */
-	ROM_LOAD( "rai7.bin", 0x00000, 0x10000, CRC(8f927822) SHA1(592f2719f2c448c3b4b239eeaec078b411e12dbb) )
-
-	ROM_REGION( 0x2000, "plds", 0 )
-	ROM_LOAD( "ep910pc-1.bin", 0x0000, 0x0884, NO_DUMP ) /* PAL is read protected */
-	ROM_LOAD( "ep910pc-2.bin", 0x1000, 0x0884, NO_DUMP ) /* PAL is read protected */
+	ROM_LOAD( "7.u203", 0x00000, 0x10000, CRC(8f927822) SHA1(592f2719f2c448c3b4b239eeaec078b411e12dbb) )
 ROM_END
 
 ROM_START( raidena )
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* v30 main cpu */
-	ROM_LOAD16_BYTE( "rai1.bin",     0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
-	ROM_LOAD16_BYTE( "rai2.bin",     0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
-	ROM_LOAD16_BYTE( "raiden03.rom", 0x0c0000, 0x20000, CRC(f6af09d0) SHA1(ecd49f3351359ea2d5cbd140c9962d45c5544ecd) )
-	ROM_LOAD16_BYTE( "raiden04.rom", 0x0c0001, 0x20000, CRC(6bdfd416) SHA1(7c3692d0c46c0fd360b9b2b5a8dc55d9217be357) )
+	ROM_LOAD16_BYTE( "1.u0253", 0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
+	ROM_LOAD16_BYTE( "2.u0252", 0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
+	ROM_LOAD16_BYTE( "3.u022",  0x0c0000, 0x20000, CRC(f6af09d0) SHA1(ecd49f3351359ea2d5cbd140c9962d45c5544ecd) )
+	ROM_LOAD16_BYTE( "4.u023",  0x0c0001, 0x20000, CRC(6bdfd416) SHA1(7c3692d0c46c0fd360b9b2b5a8dc55d9217be357) ) /* 0x1fffd == 0x00, 0x1fffe == 0x84 */
 
 	ROM_REGION( 0x100000, "sub", 0 ) /* v30 sub cpu */
-	ROM_LOAD16_BYTE( "raiden05.rom",   0x0c0000, 0x20000, CRC(ed03562e) SHA1(bf6b44fb53fa2321cd52c00fcb43b8ceb6ceffff) )
-	ROM_LOAD16_BYTE( "raiden06.rom",   0x0c0001, 0x20000, CRC(a19d5b5d) SHA1(aa5e5be60b737913e5677f88ebc218302245e5af) )
+	ROM_LOAD16_BYTE( "5.u042", 0x0c0000, 0x20000, CRC(ed03562e) SHA1(bf6b44fb53fa2321cd52c00fcb43b8ceb6ceffff) )
+	ROM_LOAD16_BYTE( "6.u043", 0x0c0001, 0x20000, CRC(a19d5b5d) SHA1(aa5e5be60b737913e5677f88ebc218302245e5af) )
 
 	ROM_REGION( 0x20000, "audiocpu", 0 ) /* 64k code for sound Z80 */
-	ROM_LOAD( "raiden08.rom", 0x000000, 0x08000, CRC(cbe055c7) SHA1(34a06a541d059c621d87fdf41546c9d052a61963) )
-	ROM_CONTINUE(             0x010000, 0x08000 )
+	ROM_LOAD( "8.u212",      0x000000, 0x08000, CRC(cbe055c7) SHA1(34a06a541d059c621d87fdf41546c9d052a61963) )
+	ROM_CONTINUE(            0x010000, 0x08000 )
 	ROM_COPY( "audiocpu", 0, 0x018000, 0x08000 )
 
-	ROM_REGION( 0x010000, "gfx1", 0 )
-	ROM_LOAD( "rai9.bin",     0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* chars */
-	ROM_LOAD( "rai10.bin",    0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) )
+	ROM_REGION( 0x010000, "gfx1", 0 ) /* Chars */
+	ROM_LOAD( "9",  0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* On some PCBs there is no explicit */
+	ROM_LOAD( "10", 0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) ) /* U location for these two roms     */
 
-	ROM_REGION( 0x080000, "gfx2", 0 )
-	ROM_LOAD( "raiu0919.bin", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* tiles */
+	ROM_REGION( 0x080000, "gfx2", 0 ) /* tiles */
+	ROM_LOAD( "sei420", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* tiles @ U105 on this PCB */
 
-	ROM_REGION( 0x080000, "gfx3", 0 )
-	ROM_LOAD( "raiu0920.bin", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* tiles */
+	ROM_REGION( 0x080000, "gfx3", 0 ) /* tiles */
+	ROM_LOAD( "sei430", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* tiles @ U115 on this PCB */
 
-	ROM_REGION( 0x090000, "gfx4", 0 )
-	ROM_LOAD( "raiu165.bin",  0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) ) /* sprites */
+	ROM_REGION( 0x090000, "gfx4", 0 ) /* sprites */
+	ROM_LOAD( "sei440",  0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) )
 
 	ROM_REGION( 0x40000, "oki", 0 )	 /* ADPCM samples */
-	ROM_LOAD( "rai7.bin", 0x00000, 0x10000, CRC(8f927822) SHA1(592f2719f2c448c3b4b239eeaec078b411e12dbb) )
+	ROM_LOAD( "7.u203", 0x00000, 0x10000, CRC(8f927822) SHA1(592f2719f2c448c3b4b239eeaec078b411e12dbb) )
 ROM_END
 
-ROM_START( raidenk )
+ROM_START( raident )
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* v30 main cpu */
-	ROM_LOAD16_BYTE( "rai1.bin",     0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
-	ROM_LOAD16_BYTE( "rai2.bin",     0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
-	ROM_LOAD16_BYTE( "raiden03.rom", 0x0c0000, 0x20000, CRC(f6af09d0) SHA1(ecd49f3351359ea2d5cbd140c9962d45c5544ecd) )
-	ROM_LOAD16_BYTE( "1i",           0x0c0001, 0x20000, CRC(fddf24da) SHA1(ececed0b0b96d070d85bfb6174029142bc96d5f0) )
+	ROM_LOAD16_BYTE( "1.u0253", 0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
+	ROM_LOAD16_BYTE( "2.u0252", 0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
+	ROM_LOAD16_BYTE( "3.u022",  0x0c0000, 0x20000, CRC(f6af09d0) SHA1(ecd49f3351359ea2d5cbd140c9962d45c5544ecd) )
+	ROM_LOAD16_BYTE( "4t.u023", 0x0c0001, 0x20000, CRC(61eefab1) SHA1(a886ce1eb1c6451b1cf9eb8dbdc2d484d9881ced) ) /* 0x1fffd == 0x02, 0x1fffe == 0x06 */
 
 	ROM_REGION( 0x100000, "sub", 0 ) /* v30 sub cpu */
-	ROM_LOAD16_BYTE( "raiden05.rom",   0x0c0000, 0x20000, CRC(ed03562e) SHA1(bf6b44fb53fa2321cd52c00fcb43b8ceb6ceffff) )
-	ROM_LOAD16_BYTE( "raiden06.rom",   0x0c0001, 0x20000, CRC(a19d5b5d) SHA1(aa5e5be60b737913e5677f88ebc218302245e5af) )
+	ROM_LOAD16_BYTE( "5.u042", 0x0c0000, 0x20000, CRC(ed03562e) SHA1(bf6b44fb53fa2321cd52c00fcb43b8ceb6ceffff) )
+	ROM_LOAD16_BYTE( "6.u043", 0x0c0001, 0x20000, CRC(a19d5b5d) SHA1(aa5e5be60b737913e5677f88ebc218302245e5af) )
 
 	ROM_REGION( 0x20000, "audiocpu", 0 ) /* 64k code for sound Z80 */
-	ROM_LOAD( "8b",           0x000000, 0x08000, CRC(99ee7505) SHA1(b97c8ee5e26e8554b5de506fba3b32cc2fde53c9) )
-	ROM_CONTINUE(             0x010000, 0x08000 )
+	ROM_LOAD( "8.u212",      0x000000, 0x08000, CRC(cbe055c7) SHA1(34a06a541d059c621d87fdf41546c9d052a61963) )
+	ROM_CONTINUE(            0x010000, 0x08000 )
 	ROM_COPY( "audiocpu", 0, 0x018000, 0x08000 )
 
-	ROM_REGION( 0x010000, "gfx1", 0 )
-	ROM_LOAD( "rai9.bin",     0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* chars */
-	ROM_LOAD( "rai10.bin",    0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) )
+	ROM_REGION( 0x010000, "gfx1", 0 ) /* Chars */
+	ROM_LOAD( "9",  0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* On some PCBs there is no explicit */
+	ROM_LOAD( "10", 0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) ) /* U location for these two roms     */
 
-	ROM_REGION( 0x080000, "gfx2", 0 )
-	ROM_LOAD( "raiu0919.bin", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* tiles */
+	ROM_REGION( 0x080000, "gfx2", 0 ) /* tiles */
+	ROM_LOAD( "sei420", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* tiles @ U105 on this PCB */
 
-	ROM_REGION( 0x080000, "gfx3", 0 )
-	ROM_LOAD( "raiu0920.bin", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* tiles */
+	ROM_REGION( 0x080000, "gfx3", 0 ) /* tiles */
+	ROM_LOAD( "sei430", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* tiles @ U115 on this PCB */
 
-	ROM_REGION( 0x090000, "gfx4", 0 )
-	ROM_LOAD( "raiu165.bin",  0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) ) /* sprites */
+	ROM_REGION( 0x090000, "gfx4", 0 ) /* sprites */
+	ROM_LOAD( "sei440",  0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) )
 
 	ROM_REGION( 0x40000, "oki", 0 )	 /* ADPCM samples */
-	ROM_LOAD( "rai7.bin", 0x00000, 0x10000, CRC(8f927822) SHA1(592f2719f2c448c3b4b239eeaec078b411e12dbb) )
+	ROM_LOAD( "7.u203", 0x00000, 0x10000, CRC(8f927822) SHA1(592f2719f2c448c3b4b239eeaec078b411e12dbb) )
 ROM_END
 
-ROM_START( raident )
+ROM_START( raidenu )
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* v30 main cpu */
-	ROM_LOAD16_BYTE( "rai1.bin",     0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
-	ROM_LOAD16_BYTE( "rai2.bin",     0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
-	ROM_LOAD16_BYTE( "raiden03.rom", 0x0c0000, 0x20000, CRC(f6af09d0) SHA1(ecd49f3351359ea2d5cbd140c9962d45c5544ecd) )
-	ROM_LOAD16_BYTE( "raid04t.023",  0x0c0001, 0x20000, CRC(61eefab1) SHA1(a886ce1eb1c6451b1cf9eb8dbdc2d484d9881ced) )
+	ROM_LOAD16_BYTE( "1.u0253", 0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
+	ROM_LOAD16_BYTE( "2.u0252", 0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
+	ROM_LOAD16_BYTE( "3a.u022", 0x0c0000, 0x20000, CRC(a8fadbdd) SHA1(a23729a51c45c1dba4e625503a37d111ae72ced0) ) /* Both 3A & 4A different for the US version */
+	ROM_LOAD16_BYTE( "4a.u023", 0x0c0001, 0x20000, CRC(bafb268d) SHA1(132d3ebf9d9d5fffa3040338106fad428c54dbaa) ) /* 0x1fffd == 0x01, 0x1fffe == 0x85 */
 
 	ROM_REGION( 0x100000, "sub", 0 ) /* v30 sub cpu */
-	ROM_LOAD16_BYTE( "raiden05.rom",   0x0c0000, 0x20000, CRC(ed03562e) SHA1(bf6b44fb53fa2321cd52c00fcb43b8ceb6ceffff) )
-	ROM_LOAD16_BYTE( "raiden06.rom",   0x0c0001, 0x20000, CRC(a19d5b5d) SHA1(aa5e5be60b737913e5677f88ebc218302245e5af) )
+	ROM_LOAD16_BYTE( "5.u042", 0x0c0000, 0x20000, CRC(ed03562e) SHA1(bf6b44fb53fa2321cd52c00fcb43b8ceb6ceffff) )
+	ROM_LOAD16_BYTE( "6.u043", 0x0c0001, 0x20000, CRC(a19d5b5d) SHA1(aa5e5be60b737913e5677f88ebc218302245e5af) )
 
 	ROM_REGION( 0x20000, "audiocpu", 0 ) /* 64k code for sound Z80 */
-	ROM_LOAD( "raid08.212",   0x000000, 0x08000, CRC(cbe055c7) SHA1(34a06a541d059c621d87fdf41546c9d052a61963) )
-	ROM_CONTINUE(             0x010000, 0x08000 )
+	ROM_LOAD( "8.u212",      0x000000, 0x08000, CRC(cbe055c7) SHA1(34a06a541d059c621d87fdf41546c9d052a61963) )
+	ROM_CONTINUE(            0x010000, 0x08000 )
 	ROM_COPY( "audiocpu", 0, 0x018000, 0x08000 )
 
-	ROM_REGION( 0x010000, "gfx1", 0 )
-	ROM_LOAD( "rai9.bin",     0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* chars */
-	ROM_LOAD( "rai10.bin",    0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) )
+	ROM_REGION( 0x010000, "gfx1", 0 ) /* Chars */
+	ROM_LOAD( "9",  0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* On some PCBs there is no explicit */
+	ROM_LOAD( "10", 0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) ) /* U location for these two roms     */
 
-	ROM_REGION( 0x080000, "gfx2", 0 )
-	ROM_LOAD( "raiu0919.bin", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* tiles */
+	ROM_REGION( 0x080000, "gfx2", 0 ) /* tiles */
+	ROM_LOAD( "sei420", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* tiles @ U105 on this PCB */
 
-	ROM_REGION( 0x080000, "gfx3", 0 )
-	ROM_LOAD( "raiu0920.bin", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* tiles */
+	ROM_REGION( 0x080000, "gfx3", 0 ) /* tiles */
+	ROM_LOAD( "sei430", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* tiles @ U115 on this PCB */
 
-	ROM_REGION( 0x090000, "gfx4", 0 )
-	ROM_LOAD( "raiu165.bin",  0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) ) /* sprites */
+	ROM_REGION( 0x090000, "gfx4", 0 ) /* sprites */
+	ROM_LOAD( "sei440",  0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) )
 
 	ROM_REGION( 0x40000, "oki", 0 )	 /* ADPCM samples */
-	ROM_LOAD( "rai7.bin", 0x00000, 0x10000, CRC(8f927822) SHA1(592f2719f2c448c3b4b239eeaec078b411e12dbb) )
+	ROM_LOAD( "7.u203", 0x00000, 0x10000, CRC(8f927822) SHA1(592f2719f2c448c3b4b239eeaec078b411e12dbb) )
 ROM_END
 
-
-ROM_START( raidenu )
+ROM_START( raidenk ) /* Same board as above. Not sure why the sound CPU would be decrypted */
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* v30 main cpu */
-	ROM_LOAD16_BYTE( "1.c8",     0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
-	ROM_LOAD16_BYTE( "2.c7",     0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
-	ROM_LOAD16_BYTE( "3dd.e8",   0x0c0000, 0x20000, CRC(b6f3bad2) SHA1(214474ab9fa65e2716155b77d7825951cc98148a) )
-	ROM_LOAD16_BYTE( "4dd.e7",   0x0c0001, 0x20000, CRC(d294dfc1) SHA1(03606ddfa35d5cb34c447fa370495e1fbb0cad0e) )
+	ROM_LOAD16_BYTE( "1.u0253", 0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
+	ROM_LOAD16_BYTE( "2.u0252", 0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
+	ROM_LOAD16_BYTE( "3.u022",  0x0c0000, 0x20000, CRC(f6af09d0) SHA1(ecd49f3351359ea2d5cbd140c9962d45c5544ecd) )
+	ROM_LOAD16_BYTE( "4k.u023", 0x0c0001, 0x20000, CRC(fddf24da) SHA1(ececed0b0b96d070d85bfb6174029142bc96d5f0) ) /* 0x1fffd == 0x02, 0x1fffe == 0xA4 */
 
 	ROM_REGION( 0x100000, "sub", 0 ) /* v30 sub cpu */
-	ROM_LOAD16_BYTE( "5.p8",   0x0c0000, 0x20000, CRC(15c1cf45) SHA1(daac732a1d3e8f36fa665f984e05651cbca74fef) )
-	ROM_LOAD16_BYTE( "6.p7",   0x0c0001, 0x20000, CRC(261c381b) SHA1(64a9e0ea9abcba6287829cf4abb806362b62c806) )
+	ROM_LOAD16_BYTE( "5.u042", 0x0c0000, 0x20000, CRC(ed03562e) SHA1(bf6b44fb53fa2321cd52c00fcb43b8ceb6ceffff) )
+	ROM_LOAD16_BYTE( "6.u043", 0x0c0001, 0x20000, CRC(a19d5b5d) SHA1(aa5e5be60b737913e5677f88ebc218302245e5af) )
 
 	ROM_REGION( 0x20000, "audiocpu", 0 ) /* 64k code for sound Z80 */
-	ROM_LOAD( "8.w8",   0x000000, 0x08000, CRC(105b9c11) SHA1(eb142806f8410d584d914b91207361a15ab18e6f) )
-	ROM_CONTINUE(                 0x10000, 0x08000 )
-	ROM_COPY( "audiocpu", 0,      0x18000, 0x08000 )
-
-	ROM_REGION( 0x010000, "gfx1", 0 )
-	ROM_LOAD( "9.u016",     0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* chars */
-	ROM_LOAD( "10.u017",    0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) )
+	ROM_LOAD( "8b.u212",     0x000000, 0x08000, CRC(99ee7505) SHA1(b97c8ee5e26e8554b5de506fba3b32cc2fde53c9) ) /* Not encrypted */
+	ROM_CONTINUE(            0x010000, 0x08000 )
+	ROM_COPY( "audiocpu", 0, 0x018000, 0x08000 )
 
-	ROM_REGION( 0x080000, "gfx2", 0 )
-	ROM_LOAD( "sei420.u011", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* tiles */
+	ROM_REGION( 0x010000, "gfx1", 0 ) /* Chars */
+	ROM_LOAD( "9",  0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* On some PCBs there is no explicit */
+	ROM_LOAD( "10", 0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) ) /* U location for these two roms     */
 
-	ROM_REGION( 0x080000, "gfx3", 0 )
-	ROM_LOAD( "sei430.u013", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* tiles */
+	ROM_REGION( 0x080000, "gfx2", 0 ) /* tiles */
+	ROM_LOAD( "sei420", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* tiles @ U105 on this PCB */
 
-	ROM_REGION( 0x090000, "gfx4", 0 )
-	ROM_LOAD( "sei440.u012",  0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) ) /* sprites */
+	ROM_REGION( 0x080000, "gfx3", 0 ) /* tiles */
+	ROM_LOAD( "sei430", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* tiles @ U115 on this PCB */
+
+	ROM_REGION( 0x090000, "gfx4", 0 ) /* sprites */
+	ROM_LOAD( "sei440",  0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) )
 
 	ROM_REGION( 0x40000, "oki", 0 )	 /* ADPCM samples */
-	ROM_LOAD( "7.x10", 0x00000, 0x10000, CRC(2051263e) SHA1(dff96caa11adf619360d88704e3af8427ddfe524) )
+	ROM_LOAD( "7.u203", 0x00000, 0x10000, CRC(8f927822) SHA1(592f2719f2c448c3b4b239eeaec078b411e12dbb) )
 ROM_END
 
-/* from a board with 2 daughter cards, no official board #s? */
-ROM_START( raidenua )
+ROM_START( raidenb )/* Different hardware, Main & Sub CPU code not encrypted. */
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* v30 main cpu */
-	ROM_LOAD16_BYTE( "1.uo253",     0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
-	ROM_LOAD16_BYTE( "2.uo252",     0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
-	ROM_LOAD16_BYTE( "3a.uo22",     0x0c0000, 0x20000, CRC(a8fadbdd) SHA1(a23729a51c45c1dba4e625503a37d111ae72ced0) )
-	ROM_LOAD16_BYTE( "4a.uo23",     0x0c0001, 0x20000, CRC(bafb268d) SHA1(132d3ebf9d9d5fffa3040338106fad428c54dbaa) )
+	ROM_LOAD16_BYTE( "1.u0253", 0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
+	ROM_LOAD16_BYTE( "2.u0252", 0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
+	ROM_LOAD16_BYTE( "3__(raidenb).u022", 0x0c0000, 0x20000, CRC(9d735bf5) SHA1(531981eac2ef0c0635f067a649899f98738d5c67) ) /* Simply labeled as 3 */
+	ROM_LOAD16_BYTE( "4__(raidenb).u023", 0x0c0001, 0x20000, CRC(8d184b99) SHA1(71cd4179aa2341d2ceecbb6a9c26f5919d46ca4c) ) /* Simply labeled as 4 */
 
 	ROM_REGION( 0x100000, "sub", 0 ) /* v30 sub cpu */
-	ROM_LOAD16_BYTE( "5.uo42",   0x0c0000, 0x20000, CRC(ed03562e) SHA1(bf6b44fb53fa2321cd52c00fcb43b8ceb6ceffff) )
-	ROM_LOAD16_BYTE( "6.uo43",   0x0c0001, 0x20000, CRC(a19d5b5d) SHA1(aa5e5be60b737913e5677f88ebc218302245e5af) )
+	ROM_LOAD16_BYTE( "5__(raidenb).u042", 0x0c0000, 0x20000, CRC(7aca6d61) SHA1(4d80ec87e54d7495b9bdf819b9985b1c8183c80d) ) /* Simply labeled as 5 */
+	ROM_LOAD16_BYTE( "6__(raidenb).u043", 0x0c0001, 0x20000, CRC(e3d35cc2) SHA1(4329865985aaf3fb524618e2e958563c8fa6ead5) ) /* Simply labeled as 6 */
 
 	ROM_REGION( 0x20000, "audiocpu", 0 ) /* 64k code for sound Z80 */
-	ROM_LOAD( "8.u214",   0x000000, 0x08000, CRC(cbe055c7) SHA1(34a06a541d059c621d87fdf41546c9d052a61963) ) // same as taiwan set
-	ROM_CONTINUE(             0x010000, 0x08000 )
+	ROM_LOAD( "rai6.u212",   0x000000, 0x08000, CRC(723a483b) SHA1(50e67945e83ea1748fb748de3287d26446d4e0a0) ) /* Should be labeled "8" ??? */
+	ROM_CONTINUE(            0x010000, 0x08000 )
 	ROM_COPY( "audiocpu", 0, 0x018000, 0x08000 )
 
-	ROM_REGION( 0x010000, "gfx1", 0 )
-	ROM_LOAD( "rai9.bin",     0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* chars */
-	ROM_LOAD( "rai10.bin",    0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) )
+	ROM_REGION( 0x010000, "gfx1", 0 ) /* Chars */
+	ROM_LOAD( "9",  0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* On some PCBs there is no explicit */
+	ROM_LOAD( "10", 0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) ) /* U location for these two roms     */
 
-	ROM_REGION( 0x080000, "gfx2", 0 )
-	ROM_LOAD( "raiu0919.bin", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* tiles */
+	ROM_REGION( 0x080000, "gfx2", 0 ) /* tiles */
+	ROM_LOAD( "sei420", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* U919 on this PCB */
 
-	ROM_REGION( 0x080000, "gfx3", 0 )
-	ROM_LOAD( "raiu0920.bin", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* tiles */
+	ROM_REGION( 0x080000, "gfx3", 0 ) /* tiles */
+	ROM_LOAD( "sei430", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* U920 on this PCB */
 
-	ROM_REGION( 0x090000, "gfx4", 0 )
-	ROM_LOAD( "raiu165.bin",  0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) ) /* sprites */
+	ROM_REGION( 0x090000, "gfx4", 0 ) /* Sprites */
+	ROM_LOAD( "sei440", 0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) ) /* U165 on this PCB */
 
 	ROM_REGION( 0x40000, "oki", 0 )	 /* ADPCM samples */
 	ROM_LOAD( "7.u203", 0x00000, 0x10000, CRC(8f927822) SHA1(592f2719f2c448c3b4b239eeaec078b411e12dbb) )
+
+	ROM_REGION( 0x2000, "plds", 0 )
+	ROM_LOAD( "ep910pc-1.bin", 0x0000, 0x0884, NO_DUMP ) /* PAL is read protected */
+	ROM_LOAD( "ep910pc-2.bin", 0x1000, 0x0884, NO_DUMP ) /* PAL is read protected */
+ROM_END
+
+ROM_START( raidenua )/* Different hardware, Main, Sub & sound CPU code not encrypted. */
+	ROM_REGION( 0x100000, "maincpu", 0 ) /* v30 main cpu */
+	ROM_LOAD16_BYTE( "1.c8",   0x0a0000, 0x10000, CRC(a4b12785) SHA1(446314e82ce01315cb3e3d1f323eaa2ad6fb48dd) )
+	ROM_LOAD16_BYTE( "2.c7",   0x0a0001, 0x10000, CRC(17640bd5) SHA1(5bbc99900426b1a072b52537ae9a50220c378a0d) )
+	ROM_LOAD16_BYTE( "3dd.e8", 0x0c0000, 0x20000, CRC(b6f3bad2) SHA1(214474ab9fa65e2716155b77d7825951cc98148a) )
+	ROM_LOAD16_BYTE( "4dd.e7", 0x0c0001, 0x20000, CRC(d294dfc1) SHA1(03606ddfa35d5cb34c447fa370495e1fbb0cad0e) )
+
+	ROM_REGION( 0x100000, "sub", 0 ) /* v30 sub cpu */
+	ROM_LOAD16_BYTE( "5.p8", 0x0c0000, 0x20000, CRC(15c1cf45) SHA1(daac732a1d3e8f36fa665f984e05651cbca74fef) )
+	ROM_LOAD16_BYTE( "6.p7", 0x0c0001, 0x20000, CRC(261c381b) SHA1(64a9e0ea9abcba6287829cf4abb806362b62c806) )
+
+	ROM_REGION( 0x20000, "audiocpu", 0 ) /* 64k code for sound Z80 */
+	ROM_LOAD( "8.w8",        0x00000, 0x08000, CRC(105b9c11) SHA1(eb142806f8410d584d914b91207361a15ab18e6f) )
+	ROM_CONTINUE(            0x10000, 0x08000 )
+	ROM_COPY( "audiocpu", 0, 0x18000, 0x08000 )
+
+	ROM_REGION( 0x010000, "gfx1", 0 ) /* Chars */
+	ROM_LOAD( "9",  0x00000, 0x08000, CRC(1922b25e) SHA1(da27122dd1c43770e7385ad602ef397c64d2f754) ) /* U016 on this PCB */
+	ROM_LOAD( "10", 0x08000, 0x08000, CRC(5f90786a) SHA1(4f63b07c6afbcf5196a433f3356bef984fe303ef) ) /* U017 on this PCB */
+
+	ROM_REGION( 0x080000, "gfx2", 0 ) /* tiles */
+	ROM_LOAD( "sei420", 0x00000, 0x80000, CRC(da151f0b) SHA1(02682497caf5f058331f18c652471829fa08d54f) ) /* U011 on this PCB */
+
+	ROM_REGION( 0x080000, "gfx3", 0 ) /* tiles */
+	ROM_LOAD( "sei430", 0x00000, 0x80000, CRC(ac1f57ac) SHA1(1de926a0db73b99904ef119ac816c53d1551156a) ) /* U013 on this PCB */
+
+	ROM_REGION( 0x090000, "gfx4", 0 ) /* Sprites */
+	ROM_LOAD( "sei440",  0x00000, 0x80000, CRC(946d7bde) SHA1(30e8755c2b1ca8bff6278710b8422b51f75eec10) ) /* U012 on this PCB */
+
+	ROM_REGION( 0x40000, "oki", 0 )	 /* ADPCM samples */
+	ROM_LOAD( "7.x10", 0x00000, 0x10000, CRC(2051263e) SHA1(dff96caa11adf619360d88704e3af8427ddfe524) )
 ROM_END
 
+
 /***************************************************************************/
 
 
@@ -529,18 +570,6 @@
 }
 #endif
 
-static DRIVER_INIT( raiden )
-{
-#ifdef SYNC_HACK
-	machine.device("sub")->memory().space(AS_PROGRAM)->install_legacy_read_handler(0x4008, 0x4009, FUNC(sub_cpu_spin_r));
-#endif
-}
-
-static DRIVER_INIT( raidenu )
-{
-	DRIVER_INIT_CALL(raiden);
-	seibu_sound_decrypt(machine,"audiocpu",0x20000);
-}
 
 /* This is based on code by Niclas Karlsson Mate, who figured out the
 encryption method! The technique is a combination of a XOR table plus
@@ -572,16 +601,32 @@
 	}
 }
 
-static DRIVER_INIT( raidenk )
+
+/***************************************************************************/
+
+static DRIVER_INIT( raidena ) /* Decrypt NOTHING! */
+{
+#ifdef SYNC_HACK
+	machine.device("sub")->memory().space(AS_PROGRAM)->install_legacy_read_handler(0x4008, 0x4009, FUNC(sub_cpu_spin_r));
+#endif
+}
+
+static DRIVER_INIT( raiden ) /* Decrypt Main / Sub / Sound code */
 {
-	DRIVER_INIT_CALL(raiden);
+	DRIVER_INIT_CALL(raidena);
 	common_decrypt(machine);
+	seibu_sound_decrypt(machine,"audiocpu",0x20000);
 }
 
-static DRIVER_INIT( raidena )
+static DRIVER_INIT( raidenk ) /* Decrypt Main / Sub code */
 {
-	DRIVER_INIT_CALL(raiden);
+	DRIVER_INIT_CALL(raidena);
 	common_decrypt(machine);
+}
+
+static DRIVER_INIT( raidenu ) /* Decrypt Sound only code */
+{
+	DRIVER_INIT_CALL(raidena);
 	seibu_sound_decrypt(machine,"audiocpu",0x20000);
 }
 
@@ -589,9 +634,17 @@
 
 /***************************************************************************/
 
-GAME( 1990, raiden,  0,      raiden,  raiden, raiden,  ROT270, "Seibu Kaihatsu", "Raiden", 0 ) // main/sub/sound not encrypted
-GAME( 1990, raidenu, raiden, raidenu, raiden, raidenu, ROT270, "Seibu Kaihatsu (Fabtek license)", "Raiden (US, set 1, SEI8904 + SEI9008 PCBs)", 0 ) // main/sub not encrypted
-GAME( 1990, raidenua,raiden, raidena, raiden, raidena, ROT270, "Seibu Kaihatsu (Fabtek license)", "Raiden (US, set 2)", 0 )
-GAME( 1990, raidena, raiden, raidena, raiden, raidena, ROT270, "Seibu Kaihatsu", "Raiden (alternate hardware)", 0 )
-GAME( 1990, raidenk, raiden, raidena, raiden, raidenk, ROT270, "Seibu Kaihatsu (IBL Corporation license)", "Raiden (Korea)", 0 ) // sound not encrypted
-GAME( 1990, raident, raiden, raidena, raiden, raidena, ROT270, "Seibu Kaihatsu (Liang HWA Electronics license)", "Raiden (Taiwan)", 0 )
+/* Same PCB, differ by region byte(s) */
+GAME( 1990, raiden,   0,      raidena, raiden, raiden, ROT270, "Seibu Kaihatsu",                                 "Raiden (set 1)", 0 )
+GAME( 1990, raidena,  raiden, raidena, raiden, raiden, ROT270, "Seibu Kaihatsu",                                 "Raiden (set 2)", 0 )
+GAME( 1990, raidenu,  raiden, raidena, raiden, raiden, ROT270, "Seibu Kaihatsu (Fabtek license)",                "Raiden (US, set 1)", 0 )
+GAME( 1990, raident,  raiden, raidena, raiden, raiden, ROT270, "Seibu Kaihatsu (Liang HWA Electronics license)", "Raiden (Taiwan)", 0 )
+
+/* Same as above, but the sound CPU code is not encrypted */
+GAME( 1990, raidenk,  raiden, raidena, raiden, raidenk, ROT270, "Seibu Kaihatsu (IBL Corporation license)",       "Raiden (Korea)", 0 )
+
+/* Alternate hardware. Main & Sub CPU code not encrypted */
+GAME( 1990, raidenua, raiden, raidenu, raiden, raidenu, ROT270, "Seibu Kaihatsu (Fabtek license)",                "Raiden (US, set 2, SEI8904 + SEI9008 PCBs)", 0 )
+
+/* Alternate hardware. Main, Sub & Sound CPU code not encrypted */
+GAME( 1990, raidenb,  raiden, raiden,  raiden, raidena, ROT270, "Seibu Kaihatsu",                                 "Raiden (set 3, Alternate hardware)", 0 )
diff -Nru src-old/mame/drivers/savquest.c src/mame/drivers/savquest.c
--- src-old/mame/drivers/savquest.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/savquest.c	2012-07-02 08:20:21.000000000 +0200
@@ -417,7 +417,7 @@
 	AM_RANGE(0x01f0, 0x01f7) AM_READWRITE(ide_r, ide_w)
 	AM_RANGE(0x03f0, 0x03f7) AM_READWRITE(fdc_r, fdc_w)
 
-	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE_LEGACY("pcibus", pci_32le_r,	pci_32le_w)
+	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_bus_legacy_device, read, write)
 
 //  AM_RANGE(0x5000, 0x5007) // routes to port $eb
 ADDRESS_MAP_END
@@ -553,9 +553,9 @@
 
 	MCFG_MC146818_ADD( "rtc", MC146818_STANDARD )
 
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
-	MCFG_PCI_BUS_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
 
 	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL, true)
 
diff -Nru src-old/mame/drivers/segae.c src/mame/drivers/segae.c
--- src-old/mame/drivers/segae.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/drivers/segae.c	2012-06-28 02:18:43.000000000 +0200
@@ -1062,6 +1062,6 @@
 GAME( 1986, astrofl,  transfrm, systeme, transfrm, 0,    ROT0,   "Sega", "Astro Flash (Japan)", 0 )
 GAME( 1986, ridleofp, 0,        systeme, ridleofp, 0,    ROT90,  "Sega / Nasco", "Riddle of Pythagoras (Japan)", 0 )
 GAME( 1987, opaopa,   0,        systeme, opaopa,   0,    ROT0,   "Sega", "Opa Opa (MC-8123, 317-0042)", 0 )
-GAME( 1988, fantzn2,  0,        systeme, fantzn2,  0,    ROT0,   "Sega", "Fantasy Zone 2 (MC-8123, 317-0057)", 0 )
+GAME( 1988, fantzn2,  0,        systeme, fantzn2,  0,    ROT0,   "Sega", "Fantasy Zone II - The Tears of Opa-Opa (MC-8123, 317-0057)", 0 )
 GAME( 1988, tetrisse, 0,        systeme, tetrisse, 0,    ROT0,   "Sega", "Tetris (Japan, System E)", 0 )
 
diff -Nru src-old/mame/drivers/segas16b.c src/mame/drivers/segas16b.c
--- src-old/mame/drivers/segas16b.c	2012-05-15 22:22:59.000000000 +0200
+++ src/mame/drivers/segas16b.c	2012-06-28 02:18:43.000000000 +0200
@@ -891,16 +891,17 @@
  *
  *************************************/
 
-#define MASTER_CLOCK_10MHz		XTAL_10MHz
-#define MASTER_CLOCK_8MHz		XTAL_8MHz
-#define MASTER_CLOCK_25MHz		XTAL_25_1748MHz
-
-#define ROM_BOARD_171_5358_SMALL    (0)	/* 171-5358 with smaller ROMs */
-#define ROM_BOARD_171_5358          (1)		/* 171-5358 */
-#define ROM_BOARD_171_5521          (2)		/* 171-5521 */
-#define ROM_BOARD_171_5704          (2)		/* 171-5704 - don't know any diff between this and 171-5521 */
-#define ROM_BOARD_ATOMICP           (3)		/* (custom Korean) */
-#define ROM_BOARD_171_5797          (4)		/* 171-5797 */
+#define MASTER_CLOCK_10MHz				XTAL_10MHz
+#define MASTER_CLOCK_8MHz				XTAL_8MHz
+#define MASTER_CLOCK_25MHz				XTAL_25_1748MHz
+
+#define ROM_BOARD_171_5358_SMALL		(0)		/* 171-5358 with smaller ROMs */
+#define ROM_BOARD_171_5358				(1)		/* 171-5358 */
+#define ROM_BOARD_171_5521				(2)		/* 171-5521 */
+#define ROM_BOARD_171_5704				(2)		/* 171-5704 - don't know any diff between this and 171-5521 */
+#define ROM_BOARD_ATOMICP				(3)		/* (custom Korean) */
+#define ROM_BOARD_171_5797				(4)		/* 171-5797 */
+#define ROM_BOARD_171_5704_EXTRA_RAM	(5)		/* System 16C */
 
 
 /*************************************
@@ -943,7 +944,7 @@
 	{ 0x35/2, 0x00000, 0x10000, 0xfe0000,      ~0, FUNC_NULL,       "bank11", FUNC(segaic16_tileram_0_w),  NULL,     &segaic16_tileram_0,   "tile RAM" },
 	{ 0x35/2, 0x10000, 0x01000, 0xfef000,      ~0, FUNC_NULL,       "bank12", FUNC(segaic16_textram_0_w),  NULL,     &segaic16_textram_0,   "text RAM" },
 	{ 0x31/2, 0x00000, 0x00800, 0xfff800,      ~0, FUNC_NULL,       "bank13", FUNC_NULL,                   "bank13", &segaic16_spriteram_0, "object RAM" },
-	{ 0x2d/2, 0x00000, 0x04000, 0xffc000,      ~0, FUNC_NULL,       "bank14", FUNC_NULL,                   "bank14", &workram,     "work RAM" },
+	{ 0x2d/2, 0x00000, 0x04000, 0xffc000,      ~0, FUNC_NULL,       "bank14", FUNC_NULL,                   "bank14", &workram,              "work RAM" },
 	{ 0x29/2, 0x00000, 0x20000, 0xfe0000, 0x20000, FUNC_NULL,       "bank15", FUNC_NULL,                   NULL,     NULL,                  "ROM 2" },
 	{ 0x25/2, 0x00000, 0x20000, 0xfe0000, 0x10000, FUNC_NULL,       "bank16", FUNC_NULL,                   NULL,     NULL,                  "ROM 1" },
 	{ 0x21/2, 0x00000, 0x20000, 0xfe0000, 0x00000, FUNC_NULL,       "bank17", FUNC_NULL,                   NULL,     NULL,                  "ROM 0" },
@@ -957,7 +958,7 @@
 	{ 0x35/2, 0x00000, 0x10000, 0xfe0000,      ~0, FUNC_NULL,       "bank11", FUNC(segaic16_tileram_0_w),  NULL,     &segaic16_tileram_0,   "tile RAM" },
 	{ 0x35/2, 0x10000, 0x01000, 0xfef000,      ~0, FUNC_NULL,       "bank12", FUNC(segaic16_textram_0_w),  NULL,     &segaic16_textram_0,   "text RAM" },
 	{ 0x31/2, 0x00000, 0x00800, 0xfff800,      ~0, FUNC_NULL,       "bank13", FUNC_NULL,                   "bank13", &segaic16_spriteram_0, "object RAM" },
-	{ 0x2d/2, 0x00000, 0x04000, 0xffc000,      ~0, FUNC_NULL,       "bank14", FUNC_NULL,                   "bank14", &workram,     "work RAM" },
+	{ 0x2d/2, 0x00000, 0x04000, 0xffc000,      ~0, FUNC_NULL,       "bank14", FUNC_NULL,                   "bank14", &workram,              "work RAM" },
 	{ 0x29/2, 0x00000, 0x20000, 0xfe0000, 0x40000, FUNC_NULL,       "bank15", FUNC_NULL,                   NULL,     NULL,                  "ROM 2" },
 	{ 0x25/2, 0x00000, 0x20000, 0xfe0000, 0x20000, FUNC_NULL,       "bank16", FUNC_NULL,                   NULL,     NULL,                  "ROM 1" },
 	{ 0x21/2, 0x00000, 0x20000, 0xfe0000, 0x00000, FUNC_NULL,       "bank17", FUNC_NULL,                   NULL,     NULL,                  "ROM 0" },
@@ -971,7 +972,21 @@
 	{ 0x35/2, 0x00000, 0x10000, 0xfe0000,      ~0, FUNC_NULL,       "bank11", FUNC(segaic16_tileram_0_w),  NULL,     &segaic16_tileram_0,   "tile RAM" },
 	{ 0x35/2, 0x10000, 0x01000, 0xfef000,      ~0, FUNC_NULL,       "bank12", FUNC(segaic16_textram_0_w),  NULL,     &segaic16_textram_0,   "text RAM" },
 	{ 0x31/2, 0x00000, 0x00800, 0xfff800,      ~0, FUNC_NULL,       "bank13", FUNC_NULL,                   "bank13", &segaic16_spriteram_0, "object RAM" },
-	{ 0x2d/2, 0x00000, 0x04000, 0xffc000,      ~0, FUNC_NULL,       "bank14", FUNC_NULL,                   "bank14", &workram,     "work RAM" },
+	{ 0x2d/2, 0x00000, 0x04000, 0xffc000,      ~0, FUNC_NULL,       "bank14", FUNC_NULL,                   "bank14", &workram,              "work RAM" },
+	{ 0x29/2, 0x00000, 0x10000, 0xff0000,      ~0, FUNC_NULL,       NULL,     FUNC(rom_5704_bank_w),       NULL,     NULL,                  "tile bank" },
+	{ 0x25/2, 0x00000, 0x80000, 0xfc0000, 0x80000, FUNC_NULL,       "bank16", FUNC_NULL,                   NULL,     NULL,                  "ROM 1" },
+	{ 0x21/2, 0x00000, 0x80000, 0xfc0000, 0x00000, FUNC_NULL,       "bank17", FUNC_NULL,                   NULL,     NULL,                  "ROM 0" },
+	{ 0 }
+};
+
+static const segaic16_memory_map_entry rom_171_5704_extra_ram_info[] =
+{
+	{ 0x3d/2, 0x00000, 0x04000, 0xffc000,      ~0, FUNC(misc_io_r), NULL,     FUNC(misc_io_w),             NULL,     NULL,                  "I/O space" },
+	{ 0x39/2, 0x00000, 0x01000, 0xfff000,      ~0, FUNC_NULL,       "bank10", FUNC(segaic16_paletteram_w), NULL,     &segaic16_paletteram,  "color RAM" },
+	{ 0x35/2, 0x00000, 0x10000, 0xfe0000,      ~0, FUNC_NULL,       "bank11", FUNC(segaic16_tileram_0_w),  NULL,     &segaic16_tileram_0,   "tile RAM" },
+	{ 0x35/2, 0x10000, 0x01000, 0xfef000,      ~0, FUNC_NULL,       "bank12", FUNC(segaic16_textram_0_w),  NULL,     &segaic16_textram_0,   "text RAM" },
+	{ 0x31/2, 0x00000, 0x00800, 0xfff800,      ~0, FUNC_NULL,       "bank13", FUNC_NULL,                   "bank13", &segaic16_spriteram_0, "object RAM" },
+	{ 0x2d/2, 0x00000, 0x40000, 0xfc0000,      ~0, FUNC_NULL,       "bank14", FUNC_NULL,                   "bank14", &workram,              "work RAM" },
 	{ 0x29/2, 0x00000, 0x10000, 0xff0000,      ~0, FUNC_NULL,       NULL,     FUNC(rom_5704_bank_w),       NULL,     NULL,                  "tile bank" },
 	{ 0x25/2, 0x00000, 0x80000, 0xfc0000, 0x80000, FUNC_NULL,       "bank16", FUNC_NULL,                   NULL,     NULL,                  "ROM 1" },
 	{ 0x21/2, 0x00000, 0x80000, 0xfc0000, 0x00000, FUNC_NULL,       "bank17", FUNC_NULL,                   NULL,     NULL,                  "ROM 0" },
@@ -985,7 +1000,7 @@
 	{ 0x35/2, 0x00000, 0x10000, 0xfe0000,      ~0, FUNC_NULL,       "bank11", FUNC(segaic16_tileram_0_w),  NULL,     &segaic16_tileram_0,   "tile RAM" },
 	{ 0x35/2, 0x10000, 0x01000, 0xfef000,      ~0, FUNC_NULL,       "bank12", FUNC(segaic16_textram_0_w),  NULL,     &segaic16_textram_0,   "text RAM" },
 	{ 0x31/2, 0x00000, 0x00800, 0xfff800,      ~0, FUNC_NULL,       "bank13", FUNC_NULL,                   "bank13", &segaic16_spriteram_0, "object RAM" },
-	{ 0x2d/2, 0x00000, 0x04000, 0xffc000,      ~0, FUNC_NULL,       "bank14", FUNC_NULL,                   "bank14", &workram,     "work RAM" },
+	{ 0x2d/2, 0x00000, 0x04000, 0xffc000,      ~0, FUNC_NULL,       "bank14", FUNC_NULL,                   "bank14", &workram,              "work RAM" },
 	{ 0x29/2, 0x00000, 0x10000, 0xff0000,      ~0, FUNC_NULL,       NULL,     FUNC(rom_5704_bank_w),       NULL,     NULL,                  "tile bank" },
 	{ 0x25/2, 0x00000, 0x10000, 0xff0000,      ~0, FUNC_NULL,       NULL,     FUNC(atomicp_sound_w),       NULL,     NULL,                  "sound" },
 	{ 0x21/2, 0x00000, 0x80000, 0xfc0000, 0x00000, FUNC_NULL,       "bank17", FUNC_NULL,                   NULL,     NULL,                  "ROM 0" },
@@ -999,7 +1014,7 @@
 	{ 0x35/2, 0x00000, 0x10000, 0xfe0000,      ~0, FUNC_NULL,                  "bank11", FUNC(segaic16_tileram_0_w),  NULL,     &segaic16_tileram_0,   "tile RAM" },
 	{ 0x35/2, 0x10000, 0x01000, 0xfef000,      ~0, FUNC_NULL,                  "bank12", FUNC(segaic16_textram_0_w),  NULL,     &segaic16_textram_0,   "text RAM" },
 	{ 0x31/2, 0x00000, 0x00800, 0xfff800,      ~0, FUNC_NULL,                  "bank13", FUNC_NULL,                   "bank13", &segaic16_spriteram_0, "object RAM" },
-	{ 0x2d/2, 0x00000, 0x04000, 0xffc000,      ~0, FUNC_NULL,                  "bank14", FUNC_NULL,                   "bank14", &workram,     "work RAM" },
+	{ 0x2d/2, 0x00000, 0x04000, 0xffc000,      ~0, FUNC_NULL,                  "bank14", FUNC_NULL,                   "bank14", &workram,              "work RAM" },
 	{ 0x29/2, 0x00000, 0x10000, 0xff0000,      ~0, FUNC(unknown_rgn2_r),       NULL,     FUNC(unknown_rgn2_w),        NULL,     NULL,                  "???" },
 	{ 0x25/2, 0x00000, 0x04000, 0xffc000,      ~0, FUNC(rom_5797_bank_math_r), NULL,     FUNC(rom_5797_bank_math_w),  NULL,     NULL,                  "tile bank/math" },
 	{ 0x21/2, 0x00000, 0x80000, 0xf80000, 0x00000, FUNC_NULL,                  "bank17", FUNC_NULL,                   NULL,     NULL,                  "ROM 0" },
@@ -1012,7 +1027,8 @@
 	&rom_171_5358_info[0],
 	&rom_171_5704_info[0],
 	&rom_atomicp_info[0],
-	&rom_171_5797_info[0]
+	&rom_171_5797_info[0],
+	&rom_171_5704_extra_ram_info[0]
 };
 
 
@@ -1069,15 +1085,22 @@
 static void system16b_generic_init(running_machine &machine, int _rom_board)
 {
 	segas1x_state *state = machine.driver_data<segas1x_state>();
+	int workram_size;
 
 	system16b_common_init(machine, _rom_board);
 
+	/* System 16C board has more workram */
+	if (_rom_board == ROM_BOARD_171_5704_EXTRA_RAM)
+		workram_size = 0x40000;
+	else
+		workram_size = 0x04000;
+
 	/* allocate memory for regions not autmatically assigned */
 	segaic16_spriteram_0 = auto_alloc_array(machine, UINT16, 0x00800 / 2);
 	segaic16_paletteram  = auto_alloc_array(machine, UINT16, 0x01000 / 2);
 	segaic16_tileram_0   = auto_alloc_array(machine, UINT16, 0x10000 / 2);
 	segaic16_textram_0   = auto_alloc_array(machine, UINT16, 0x01000 / 2);
-	workram              = auto_alloc_array(machine, UINT16, 0x04000 / 2);
+	workram              = auto_alloc_array(machine, UINT16, workram_size / 2);
 
 	/* init the memory mapper */
 	segaic16_memory_mapper_init(machine.device("maincpu"), region_info_list[state->m_rom_board], sound_w, NULL);
@@ -1085,13 +1108,13 @@
 	/* init the FD1094 */
 	fd1094_driver_init(machine, "maincpu", segaic16_memory_mapper_set_decrypted);
 
-	machine.device<nvram_device>("nvram")->set_base(workram, 0x4000);
+	machine.device<nvram_device>("nvram")->set_base(workram, workram_size);
 
 	state_save_register_global_pointer(machine, segaic16_spriteram_0, 0x00800/2);
 	state_save_register_global_pointer(machine, segaic16_paletteram,  0x01000/2);
 	state_save_register_global_pointer(machine, segaic16_tileram_0,   0x10000/2);
 	state_save_register_global_pointer(machine, segaic16_textram_0,   0x01000/2);
-	state_save_register_global_pointer(machine, workram,              0x04000/2);
+	state_save_register_global_pointer(machine, workram,              workram_size/2);
 }
 
 
@@ -1320,6 +1343,7 @@
 {
 	segas1x_state *state = device->machine().driver_data<segas1x_state>();
 	int size = state->memregion("soundcpu")->bytes() - 0x10000;
+
 	if (size > 0)
 	{
 		int bankoffs = 0;
@@ -1350,6 +1374,7 @@
 				break;
 
 			case ROM_BOARD_171_5521:
+			case ROM_BOARD_171_5704_EXTRA_RAM:
 				/*
                     D5 : Unused
                     D4 : Unused
@@ -1592,6 +1617,7 @@
 static READ16_HANDLER( aceattac_custom_io_r )
 {
 	segas1x_state *state = space->machine().driver_data<segas1x_state>();
+
 	switch (offset & (0x3000/2))
 	{
 		case 0x1000/2:
@@ -3196,6 +3222,37 @@
 INPUT_PORTS_END
 
 
+static INPUT_PORTS_START( fz2 )
+	PORT_INCLUDE( system16b_generic )
+
+	PORT_MODIFY("DSW2")
+	PORT_DIPUNKNOWN_DIPLOC( 0x01, IP_ACTIVE_LOW, "SW2:1" )
+	PORT_DIPUNKNOWN_DIPLOC( 0x02, IP_ACTIVE_LOW, "SW2:2" )
+	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Lives ) ) PORT_DIPLOCATION("SW2:3,4")
+	PORT_DIPSETTING(    0x08, "2" )
+	PORT_DIPSETTING(    0x0c, "3" )
+	PORT_DIPSETTING(    0x04, "4" )
+	PORT_DIPSETTING(    0x00, "240 (Cheat)")
+	PORT_DIPUNKNOWN_DIPLOC( 0x10, IP_ACTIVE_LOW, "SW2:5" )
+	PORT_DIPUNKNOWN_DIPLOC( 0x20, IP_ACTIVE_LOW, "SW2:6" )
+	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Difficulty ) ) PORT_DIPLOCATION("SW2:7,8")
+	PORT_DIPSETTING(    0x80, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0xc0, DEF_STR( Normal ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Hard ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
+
+	PORT_MODIFY("DSW1")
+	PORT_DIPUNUSED_DIPLOC( 0x01, IP_ACTIVE_LOW, "SW1:1" )
+	PORT_DIPUNUSED_DIPLOC( 0x02, IP_ACTIVE_LOW, "SW1:2" )
+	PORT_DIPUNUSED_DIPLOC( 0x04, IP_ACTIVE_LOW, "SW1:3" )
+	PORT_DIPUNUSED_DIPLOC( 0x08, IP_ACTIVE_LOW, "SW1:4" )
+	PORT_DIPUNUSED_DIPLOC( 0x10, IP_ACTIVE_LOW, "SW1:5" )
+	PORT_DIPUNUSED_DIPLOC( 0x20, IP_ACTIVE_LOW, "SW1:6" )
+	PORT_DIPUNUSED_DIPLOC( 0x40, IP_ACTIVE_LOW, "SW1:7" )
+	PORT_DIPUNUSED_DIPLOC( 0x80, IP_ACTIVE_LOW, "SW1:8" )
+INPUT_PORTS_END
+
+
 /* we use common sys16b tags to simplify port reads */
 static INPUT_PORTS_START( atomicp )
 	PORT_START("SERVICE")	/* P1 */
@@ -6394,6 +6451,52 @@
 	ROM_LOAD( "mpr-12149.a12", 0x30000, 0x20000, CRC(d6617b19) SHA1(aa36d257eaa52c8c871a39aaa2f29c203525dbaf) )
 ROM_END
 
+/**************************************************************************************************************************
+    Fantasy Zone II, Sega System 16C
+    CPU: 68000 (has Sega part number?)
+    ROM Board type: 171-5704 + Extra RAM
+
+    Sega operated this game on actual System 16 PCBs for various events,
+    it was also included in the PS2 Sega Ages collection Vol 33.
+    Various bootlegs were sourced from this version. The dump will have to
+    be verified if the official PCB ever gets into MAME friendly hands.
+
+    There is also a demo version of the game available on the PC, but
+    attempting to use those ROMs on a real PCB / emulator will result
+    in the game failing after a few stages.
+*/
+ROM_START( fantzn2x )
+	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
+	ROM_LOAD16_BYTE( "fz2.a7", 0x00000, 0x20000, CRC(94c05f0b) SHA1(53da68a919776a46ae96dbc094ff941308d13613) )
+	ROM_LOAD16_BYTE( "fz2.a5", 0x00001, 0x20000, CRC(f3526895) SHA1(3197956608138601192f111d3bcc26662a7d6ec1) )
+	/* empty 0x40000 - 0x80000 */
+	ROM_LOAD16_BYTE( "fz2.a8", 0x80000, 0x20000, CRC(b2ebb209) SHA1(bd40c90a372ab92a869bdd28d12cf52b45ecc80e) )
+	ROM_LOAD16_BYTE( "fz2.a6", 0x80001, 0x20000, CRC(6833f546) SHA1(b4503cdb5bdb1322c34b9da3ff4227c740dad707) )
+
+	ROM_REGION( 0x60000, "gfx1", 0 ) /* tiles */
+	ROM_LOAD( "fz2.a14", 0x00000, 0x20000, CRC(1c0a4537) SHA1(3abdf51ea81780309bcfaf12c04efdf7cb15a649) )
+	ROM_LOAD( "fz2.a15", 0x20000, 0x20000, CRC(2b933344) SHA1(5b53ea8d58cc3d157aec6926db048359984e4276) )
+	ROM_LOAD( "fz2.a16", 0x40000, 0x20000, CRC(e63281a1) SHA1(72379c579484c1ef7784a9598d373446ef0a472b) )
+
+	ROM_REGION16_BE( 0x180000, "gfx2", 0 ) /* sprites */
+	ROM_LOAD16_BYTE( "fz2.b1",  0x000001, 0x20000, CRC(46bba615) SHA1(b291df4a83d7155eb7606f86ed733c24362a4db3) )
+	ROM_LOAD16_BYTE( "fz2.b5",  0x000000, 0x20000, CRC(bebeee5d) SHA1(9e57e62c6b9136667aa90d7d423fc33ac6df4352) )
+	ROM_LOAD16_BYTE( "fz2.b2",  0x040001, 0x20000, CRC(6681a7b6) SHA1(228df38601ba3895e9449921a64850941715b421) )
+	ROM_LOAD16_BYTE( "fz2.b6",  0x040000, 0x20000, CRC(42d3241f) SHA1(c3240e3e1d7d398e74e76ba65adca6b06f0f67a9) )
+	ROM_LOAD16_BYTE( "fz2.b3",  0x080001, 0x20000, CRC(5863926f) SHA1(0e591c4b85e5d572b3311bec2c1f6d2484204db6) )
+	ROM_LOAD16_BYTE( "fz2.b7",  0x080000, 0x20000, CRC(cd830510) SHA1(8a32a1aa43f8af5e86f552f05da40b6e4ba12495) )
+	ROM_LOAD16_BYTE( "fz2.b4",  0x0c0001, 0x20000, CRC(b98fa5b6) SHA1(c3f8891f81e80321e2ee5cc1f4d93b1867ed1868) )
+	ROM_LOAD16_BYTE( "fz2.b8",  0x0c0000, 0x20000, CRC(e8248f68) SHA1(7876945d2baf1d7bdb9cc3a23be9f1a1681cede9) )
+	ROM_LOAD16_BYTE( "fz2.a1",  0x100001, 0x20000, CRC(9d2f41f3) SHA1(54f5dc47d854cd26b108695f55263d8b8c29ce0e) )
+	ROM_LOAD16_BYTE( "fz2.b10", 0x100000, 0x20000, CRC(7686ea33) SHA1(812a638f42500b30f80f9a3956c5eb4553cc35d0) )
+	ROM_LOAD16_BYTE( "fz2.a2",  0x140001, 0x20000, CRC(3b4050b7) SHA1(8c7c8051c577a4b2ca54d7e60c100fbd5391551f) )
+	ROM_LOAD16_BYTE( "fz2.b11", 0x140000, 0x20000, CRC(da8a95dc) SHA1(d44e1515008d4ee302f940ce7799fa9a790799e9) )
+
+	ROM_REGION( 0x50000, "soundcpu", 0 ) /* sound CPU */
+	ROM_LOAD( "fz2.a10", 0x00000, 0x08000, CRC(92c92924) SHA1(3c98cea8f42c316405b28ae03469c6876de5e806) )
+	ROM_LOAD( "fz2.a11", 0x10000, 0x20000, CRC(8c641bb9) SHA1(920da63961d2f3457c80d4c5f6d4f405374bb23a) )
+ROM_END
+
 
 
 /*************************************
@@ -6426,6 +6529,12 @@
 }
 
 
+static DRIVER_INIT( generic_5704_extra_ram )
+{
+	system16b_generic_init(machine, ROM_BOARD_171_5704_EXTRA_RAM);
+}
+
+
 static DRIVER_INIT( generic_5797 )
 {
 	system16b_generic_init(machine, ROM_BOARD_171_5797);
@@ -6761,6 +6870,9 @@
 GAME( 1989, wrestwar2,  wrestwar, system16b,           wrestwar, generic_5704,       ROT270, "Sega", "Wrestle War (set 2, World, FD1094 317-0102)", 0 )
 GAME( 1989, wrestwar1,  wrestwar, system16b,           wrestwar, generic_5704,       ROT270, "Sega", "Wrestle War (set 1, Japan, FD1094 317-0090)", 0 )
 
+/* Extra RAM, dubbed by M2 as 'System 16C' */
+GAME( 2008, fantzn2x,   0,        system16b,           fz2,  generic_5704_extra_ram, ROT0,   "Sega / M2", "Fantasy Zone II - The Tears of Opa-Opa (System 16C version)", 0 ) // The 1987 copyright date shown ingame is false
+
 /* Custom Korean Board - these probably belong with the bootlegs... */
 GAME( 1990, atomicp,    0,        atomicp,             atomicp,  atomicp,            ROT0,   "Philko", "Atomic Point (Korea)", 0) // korean clone board..
 GAME( 1990, snapper,    0,        atomicp,             snapper,  snapper,            ROT0,   "Philko", "Snapper (Korea)", 0) // korean clone board..
diff -Nru src-old/mame/drivers/seta.c src/mame/drivers/seta.c
--- src-old/mame/drivers/seta.c	2012-05-25 16:38:46.000000000 +0200
+++ src/mame/drivers/seta.c	2012-06-24 07:58:31.000000000 +0200
@@ -22,50 +22,50 @@
 Ordered by Board        Year + Game                             Licensed To
 -------------------------------------------------------------------------------
 P0-029-A (M6100287A)    88 Thundercade / Twin Formation (1)     Taito
-?        (M6100326A)    88 Twin Eagle                           Taito
-P0-045-A (M6100429A)    89 DownTown                             Taito / RomStar
-?        (M6100430A)    89 U.S. Classic(2)                      Taito / RomStar
-?                       88 Caliber 50                           Taito / RomStar
-?                       89 Arbalester                           Taito / RomStar
+P0-034A  (M6100326A)    88 Twin Eagle                           Taito
+P0-044B                 88 Caliber 50                           Taito / RomStar
+P0-045A  (M6100429A)    89 DownTown                             Taito / RomStar
+P0-045A                 89 Arbalester                           Taito / RomStar
+P0-046A  (M6100430A)    89 U.S. Classic(2)                      Taito / RomStar
 P0-047A                 ?? Seta Roulette                        Seta / Visco
 P1-036-A + P0-045-A +
-P1-049-A                89 Meta Fox                             Taito / RomStar
+P1-049A                 89 Meta Fox                             Taito / RomStar
 P0-053-1                89 Castle of Dragon/Dragon Unit         Taito / RomStar / Athena
-P0-053-A                91 Strike Gunner S.T.G                  Athena / Tecmo
-P0-053-A                92 Quiz Kokology                        Tecmo
-P0-055-B                89 Wit's                                Athena
-P0-055-D                90 Thunder & Lightning                  Romstar / Visco
+P0-053A                 91 Strike Gunner S.T.G                  Athena / Tecmo
+P0-053A                 92 Quiz Kokology                        Tecmo
+P0-055B                 89 Wit's                                Athena
+P0-055D                 90 Thunder & Lightning                  Romstar / Visco
 Promat PCB              94 Wiggie Waggie(5)                     --
 Promat PCB              94 Super Bar(5)                         --
 P0-058-C                98 Internation Toote (6)                Coinmaster
-P0-063-A                91 Rezon                                Allumer
-P0-068-B (M6100723A)    92 Block Carnival                       Visco
+P0-063A                 91 Rezon                                Allumer
+P0-068B  (M6100723A)    92 Block Carnival                       Visco
 P0-072-2 (prototype)    92 Blandia (prototype)                  Allumer
-P0-077-A (BP922)        92 Ultraman Club                        Banpresto
-P0-078-A                92 Blandia (7)                          Allumer
-P0-079-A                92 Zing Zing Zip                        Allumer / Tecmo
-P0-079-A                94 Eight Forces                         Tecmo
-P0-080-A (BP923)        92 SD Gundam Neo Battling (3)           Banpresto
+P0-077A  (BP922)        92 Ultraman Club                        Banpresto
+P0-078A                 92 Blandia (7)                          Allumer
+P0-079A                 92 Zing Zing Zip                        Allumer / Tecmo
+P0-079A                 94 Eight Forces                         Tecmo
+P0-080A  (BP923)        92 SD Gundam Neo Battling (3)           Banpresto
 ?                       93 Athena no Hatena?                    Athena
-?                       93 J.J.Squawkers                        Athena / Able
+?        (93111A)       93 J.J.Squawkers                        Athena / Able
 ?        (93111A)       93 War Of Aero                          Yang Cheng
-P0-081-A (BP933KA)      93 Mobile Suit Gundam                   Banpresto
-P0-083-A (BP931)        93 Ultra Toukon Densetsu                Banpresto / Tsuburaya Prod.
-P0-092-A                93 Daioh                                Athena
-P0-096-A (BP934KA)      93 Kamen Rider                          Banpresto
-P0-097-A                93 Oishii Puzzle ..                     Sunsoft + Atlus
+P0-081A  (BP933KA)      93 Mobile Suit Gundam                   Banpresto
+P0-083A  (BP931)        93 Ultra Toukon Densetsu                Banpresto / Tsuburaya Prod.
+P0-092A                 93 Daioh                                Athena
+P0-096A  (BP934KA)      93 Kamen Rider                          Banpresto
+P0-097A                 93 Oishii Puzzle ..                     Sunsoft + Atlus
 bootleg                 9? Triple Fun (4)                       bootleg (Comad?)
-P0-100-A                93 Quiz Kokology 2                      Tecmo
+P0-100A                 93 Quiz Kokology 2                      Tecmo
 P0-101-1                94 Pro Mahjong Kiwame                   Athena
-P0-102-A                93 Mad Shark                            Allumer
-P0-107-A (prototype?)   94 Orbs (prototype?)                    American Sammy
-P0-107-A                93 Kero Kero Keroppi no Issyoni Asobou  Sammy Industries  [added Chack'n, Hau]
+P0-102A                 93 Mad Shark                            Allumer
+P0-107A  (prototype?)   94 Orbs (prototype?)                    American Sammy
+P0-107A                 93 Kero Kero Keroppi no Issyoni Asobou  Sammy Industries  [added Chack'n, Hau]
 P0-111A                 94 Magical Speed                        Allumer
-P0-114-A (SKB-001)      94 Krazy Bowl                           American Sammy
-P0-117-A (DH-01)        95 Extreme Downhill                     Sammy Japan
-P0-117-A?               95 Sokonuke Taisen Game                 Sammy Industries
-P0-120-A (BP954KA)      95 Gundhara                             Banpresto
-P0-122-A (SZR-001)      95 Zombie Raid                          American Sammy
+P0-114A  (SKB-001)      94 Krazy Bowl                           American Sammy
+P0-117A  (DH-01)        95 Extreme Downhill                     Sammy Japan
+P0-117A?                95 Sokonuke Taisen Game                 Sammy Industries
+P0-120A  (BP954KA)      95 Gundhara                             Banpresto
+P0-122A  (SZR-001)      95 Zombie Raid                          American Sammy
 ?                       96 Crazy Fight                          Subsino
 -------------------------------------------------------------------------------
 (1) YM2203 + YM3812 instead of X1-010
@@ -6030,40 +6030,34 @@
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNKNOWN  )
 
 	PORT_START("DSW") //2 DSWs
-	PORT_DIPNAME( 0x0001, 0x0001, DEF_STR( Flip_Screen ) )
+	PORT_DIPNAME( 0x0001, 0x0001, DEF_STR( Flip_Screen ) )		PORT_DIPLOCATION("SW2:1")
 	PORT_DIPSETTING(      0x0001, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0002, 0x0002, DEF_STR( Demo_Sounds ) )
+	PORT_DIPNAME( 0x0002, 0x0002, DEF_STR( Demo_Sounds ) )		PORT_DIPLOCATION("SW2:2")
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0002, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0004, 0x0004, "Unknown 2-2*" )	//?
+	PORT_DIPNAME( 0x0004, 0x0004, "Unknown DSW2 - 3*" )		PORT_DIPLOCATION("SW2:3")	// tested...Manual states "Unused"
 	PORT_DIPSETTING(      0x0004, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0008, 0x0008, "Stage Select (Cheat)")
+	PORT_DIPNAME( 0x0008, 0x0008, "Stage Select (Cheat)")		PORT_DIPLOCATION("SW2:4")	// Manual states "Unused"
 	PORT_DIPSETTING(      0x0008, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0010, 0x0010, "Unknown 2-4" )
-	PORT_DIPSETTING(      0x0010, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0020, 0x0020, "Unknown 2-5" )
-	PORT_DIPSETTING(      0x0020, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0040, 0x0040, "Unknown 2-6" )
-	PORT_DIPSETTING(      0x0040, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_SERVICE( 0x0080, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED_DIPLOC( 0x0010, IP_ACTIVE_LOW, "SW2:5" ) /* Listed as "Unused" */
+	PORT_DIPUNUSED_DIPLOC( 0x0020, IP_ACTIVE_LOW, "SW2:6" ) /* Listed as "Unused" */
+	PORT_DIPUNUSED_DIPLOC( 0x0040, IP_ACTIVE_LOW, "SW2:7" ) /* Listed as "Unused" */
+	PORT_SERVICE_DIPLOC(   0x0080, IP_ACTIVE_LOW, "SW2:8" )
 
-	PORT_DIPNAME( 0x0300, 0x0300, DEF_STR( Lives ) )
+	PORT_DIPNAME( 0x0300, 0x0300, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW1:1,2")
 	PORT_DIPSETTING(      0x0200, "1" )
 	PORT_DIPSETTING(      0x0300, "2" )
 	PORT_DIPSETTING(      0x0100, "3" )
 	PORT_DIPSETTING(      0x0000, "4" )
-	PORT_DIPNAME( 0x0c00, 0x0c00, DEF_STR( Difficulty ) )
+	PORT_DIPNAME( 0x0c00, 0x0c00, DEF_STR( Difficulty ) )		PORT_DIPLOCATION("SW1:3,4")
 	PORT_DIPSETTING(      0x0800, DEF_STR( Easy )    )
 	PORT_DIPSETTING(      0x0c00, DEF_STR( Normal )  )
 	PORT_DIPSETTING(      0x0400, DEF_STR( Hard )    )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0xf000, 0xf000, DEF_STR( Coinage ) )
+	PORT_DIPNAME( 0xf000, 0xf000, DEF_STR( Coinage ) )		PORT_DIPLOCATION("SW1:5,6,7,8")
 	PORT_DIPSETTING(      0xa000, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(      0xb000, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(      0xc000, DEF_STR( 4C_1C ) )
@@ -9778,30 +9772,30 @@
 
 ROM_START( blandia )
 	ROM_REGION( 0x200000, "maincpu", 0 )		/* 68000 Code */
-	ROM_LOAD16_BYTE( "ux001001.003",  0x000000, 0x040000, CRC(2376a1f3) SHA1(705a3c5cc1137d14ffded6c949bf9aa650133eb7) )
-	ROM_LOAD16_BYTE( "ux001002.004",  0x000001, 0x040000, CRC(b915e172) SHA1(e43e50a664dc1286ece42a5ff8629b2da7fb49b4) )
-	ROM_LOAD16_WORD_SWAP( "ux001003.202",     0x100000, 0x100000, CRC(98052c63) SHA1(b523596de29038b3ec9f1b6e1f7374a6a8709d42) )
+	ROM_LOAD16_BYTE( "ux001001.u3", 0x000000, 0x040000, CRC(2376a1f3) SHA1(705a3c5cc1137d14ffded6c949bf9aa650133eb7) )
+	ROM_LOAD16_BYTE( "ux001002.u4", 0x000001, 0x040000, CRC(b915e172) SHA1(e43e50a664dc1286ece42a5ff8629b2da7fb49b4) )
+	ROM_LOAD16_WORD_SWAP( "ux001003.u202",    0x100000, 0x100000, CRC(98052c63) SHA1(b523596de29038b3ec9f1b6e1f7374a6a8709d42) )
 
 	ROM_REGION( 0x400000, "gfx1", 0 )	/* Sprites */
-	ROM_LOAD( "ux001005.200",  0x300000, 0x100000, CRC(bea0c4a5) SHA1(a690c17fb7cbdab533c1dfad13abbad9359b9631) )
-	ROM_LOAD( "ux001007.201",  0x100000, 0x100000, CRC(4440fdd1) SHA1(7bfee90f81a2c867bd487abcf5905393ad400902) )
-	ROM_LOAD( "ux001006.063",  0x200000, 0x100000, CRC(abc01cf7) SHA1(c3f26e75eeb68073d2825be8df82cc6afcfbfb26) )
-	ROM_LOAD( "ux001008.064",  0x000000, 0x100000, CRC(413647b6) SHA1(594e010ca6f49ec82cc6d44fe23ac3427c4c3dbd) )
+	ROM_LOAD( "ux001005.u200", 0x300000, 0x100000, CRC(bea0c4a5) SHA1(a690c17fb7cbdab533c1dfad13abbad9359b9631) )
+	ROM_LOAD( "ux001007.u201", 0x100000, 0x100000, CRC(4440fdd1) SHA1(7bfee90f81a2c867bd487abcf5905393ad400902) )
+	ROM_LOAD( "ux001006.u63",  0x200000, 0x100000, CRC(abc01cf7) SHA1(c3f26e75eeb68073d2825be8df82cc6afcfbfb26) )
+	ROM_LOAD( "ux001008.u64",  0x000000, 0x100000, CRC(413647b6) SHA1(594e010ca6f49ec82cc6d44fe23ac3427c4c3dbd) )
 
 	ROM_REGION( 0x0c0000, "gfx2", 0 )	/* Layer 1 */
-	ROM_LOAD( "ux001009.065",  0x000000, 0x080000, CRC(bc6f6aea) SHA1(673efa0c70587b5650ccf0a3c4bc316f53d52ba6) )
-	ROM_LOAD( "ux001010.066",  0x040000, 0x080000, CRC(bd7f7614) SHA1(dc865ff0f327f460956915b2018aaac815e8fce5) )
+	ROM_LOAD( "ux001009.u65", 0x000000, 0x080000, CRC(bc6f6aea) SHA1(673efa0c70587b5650ccf0a3c4bc316f53d52ba6) )
+	ROM_LOAD( "ux001010.u66", 0x040000, 0x080000, CRC(bd7f7614) SHA1(dc865ff0f327f460956915b2018aaac815e8fce5) )
 
 	ROM_REGION( 0x0c0000, "gfx3", 0 )	/* Layer 2 */
-	ROM_LOAD( "ux001011.067",  0x000000, 0x080000, CRC(5efe0397) SHA1(a294a2dae9a10e93912543a8614a7f960a011f27) )
-	ROM_LOAD( "ux001012.068",  0x040000, 0x080000, CRC(f29959f6) SHA1(edccea3d0bf972a07edd6339e18792d089033bff) )
+	ROM_LOAD( "ux001011.u67",  0x000000, 0x080000, CRC(5efe0397) SHA1(a294a2dae9a10e93912543a8614a7f960a011f27) )
+	ROM_LOAD( "ux001012.u068", 0x040000, 0x080000, CRC(f29959f6) SHA1(edccea3d0bf972a07edd6339e18792d089033bff) )
 
 	/* The c0000-fffff region is bankswitched */
 	ROM_REGION( 0x240000, "x1snd", 0 )	/* Samples */
-	ROM_LOAD( "ux001013.069",  0x000000, 0x0c0000, CRC(5cd273cd) SHA1(602e1f10454e2b1c941f2e6983872bb9ca77a542) )
+	ROM_LOAD( "ux001013.u69", 0x000000, 0x0c0000, CRC(5cd273cd) SHA1(602e1f10454e2b1c941f2e6983872bb9ca77a542) )
 	// skip c0000-fffff (banked region)
-	ROM_CONTINUE(              0x100000, 0x040000  )
-	ROM_LOAD( "ux001014.070",  0x140000, 0x080000, CRC(86b49b4e) SHA1(045b352950d848907af4c22b817d154b2cfff382) )
+	ROM_CONTINUE(             0x100000, 0x040000  )
+	ROM_LOAD( "ux001014.u70", 0x140000, 0x080000, CRC(86b49b4e) SHA1(045b352950d848907af4c22b817d154b2cfff382) )
 ROM_END
 
 ROM_START( blandiap )
@@ -10111,32 +10105,32 @@
 	ROM_LOAD( "u70.bin",  0x080000, 0x080000, CRC(8d756fdf) SHA1(d66712a6aa19252f2c915ac66fc27df031fa9512) )
 ROM_END
 
-ROM_START( jjsquawk )
+ROM_START( jjsquawk ) /* PCB stickered  J.J. SQUAWKERS 9401- 1022 */
 	ROM_REGION( 0x200000, "maincpu", 0 )		/* 68000 Code */
-	ROM_LOAD16_BYTE( "jj-rom1.040", 0x000000, 0x040000, CRC(7b9af960) SHA1(1718d54b0c12ae148de44f9ccccf90c0182f7b4f) )
-	ROM_CONTINUE   (                0x100000, 0x040000  )
-	ROM_LOAD16_BYTE( "jj-rom2.040", 0x000001, 0x040000, CRC(47dd71a3) SHA1(e219d984a1cac484ce1e570b7849562a88e0903e) )
-	ROM_CONTINUE   (                0x100001, 0x040000  )
+	ROM_LOAD16_BYTE( "fe2002001.u3", 0x000000, 0x040000, CRC(7b9af960) SHA1(1718d54b0c12ae148de44f9ccccf90c0182f7b4f) )
+	ROM_CONTINUE   (                 0x100000, 0x040000  )
+	ROM_LOAD16_BYTE( "fe2002002.u4", 0x000001, 0x040000, CRC(47dd71a3) SHA1(e219d984a1cac484ce1e570b7849562a88e0903e) )
+	ROM_CONTINUE   (                 0x100001, 0x040000  )
 
 	ROM_REGION( 0x200000, "gfx1", 0 )	/* Sprites */
-	ROM_LOAD( "jj-rom9",  0x000000, 0x080000, CRC(27441cd3) SHA1(5867fc30c158e07f2d36ecab97b1d304383e6f35) )
-	ROM_LOAD( "jj-rom10", 0x080000, 0x080000, CRC(ca2b42c4) SHA1(9b99b6618fe44a6c29a255e89dab72a0a56214df) )
-	ROM_LOAD( "jj-rom7",  0x100000, 0x080000, CRC(62c45658) SHA1(82b1ea138e8f4b4ade7e44b31843aa2023c9dd71) )
-	ROM_LOAD( "jj-rom8",  0x180000, 0x080000, CRC(2690c57b) SHA1(b880ded7715dffe12c4fea7ad7cb9c5133b73250) )
+	ROM_LOAD( "fe2001009", 0x000000, 0x080000, CRC(27441cd3) SHA1(5867fc30c158e07f2d36ecab97b1d304383e6f35) ) /* These roms located on a plug-in PCB */
+	ROM_LOAD( "fe2001010", 0x080000, 0x080000, CRC(ca2b42c4) SHA1(9b99b6618fe44a6c29a255e89dab72a0a56214df) )
+	ROM_LOAD( "fe2001007", 0x100000, 0x080000, CRC(62c45658) SHA1(82b1ea138e8f4b4ade7e44b31843aa2023c9dd71) )
+	ROM_LOAD( "fe2001008", 0x180000, 0x080000, CRC(2690c57b) SHA1(b880ded7715dffe12c4fea7ad7cb9c5133b73250) )
 
 	ROM_REGION( 0x200000, "gfx2", 0 )	/* Layer 1 */
-	ROM_LOAD       ( "jj-rom11",    0x000000, 0x080000, CRC(98b9f4b4) SHA1(de96708aebb428ddc413c3649caaec80c0c155bd) )
-	ROM_LOAD       ( "jj-rom12",    0x080000, 0x080000, CRC(d4aa916c) SHA1(d619d20c33f16ab06b529fc1717ad9b703acbabf) )
-	ROM_LOAD16_BYTE( "jj-rom3.040", 0x100000, 0x080000, CRC(a5a35caf) SHA1(da4bdb7f0b319f8ff972a552d0134a73e5ac1b87) )
+	ROM_LOAD       ( "fe2001011", 0x000000, 0x080000, CRC(98b9f4b4) SHA1(de96708aebb428ddc413c3649caaec80c0c155bd) ) /* This rom located on a plug-in PCB */
+	ROM_LOAD       ( "fe2001012", 0x080000, 0x080000, CRC(d4aa916c) SHA1(d619d20c33f16ab06b529fc1717ad9b703acbabf) ) /* This rom located on a plug-in PCB */
+	ROM_LOAD16_BYTE( "fe2001003", 0x100000, 0x080000, CRC(a5a35caf) SHA1(da4bdb7f0b319f8ff972a552d0134a73e5ac1b87) )
 
 	ROM_REGION( 0x200000, "gfx3", 0 )	/* Layer 2 */
-	ROM_LOAD       ( "jj-rom14",    0x000000, 0x080000, CRC(274bbb48) SHA1(b8db632a9bbb7232d0b1debd67b3b453fd4989e6) )
-	ROM_LOAD       ( "jj-rom13",    0x080000, 0x080000, CRC(51e29871) SHA1(9d33283bd9a3f57602a55cfc9fafa49edd0be8c5) )
-	ROM_LOAD16_BYTE( "jj-rom4.040", 0x100000, 0x080000, CRC(a235488e) SHA1(a45d02a4451defbef7fbdab15671955fab8ed76b) )
+	ROM_LOAD       ( "fe2001014", 0x000000, 0x080000, CRC(274bbb48) SHA1(b8db632a9bbb7232d0b1debd67b3b453fd4989e6) ) /* This rom located on a plug-in PCB */
+	ROM_LOAD       ( "fe2001013", 0x080000, 0x080000, CRC(51e29871) SHA1(9d33283bd9a3f57602a55cfc9fafa49edd0be8c5) ) /* This rom located on a plug-in PCB */
+	ROM_LOAD16_BYTE( "fe2001004", 0x100000, 0x080000, CRC(a235488e) SHA1(a45d02a4451defbef7fbdab15671955fab8ed76b) )
 
 	ROM_REGION( 0x100000, "x1snd", 0 )	/* Samples */
-	ROM_LOAD( "jj-rom5.040", 0x000000, 0x080000, CRC(d99f2879) SHA1(66e83a6bc9093d19c72bd8ef1ec0523cfe218250) )
-	ROM_LOAD( "jj-rom6.040", 0x080000, 0x080000, CRC(9df1e478) SHA1(f41b55821187b417ad09e4a1f439c01a107d2674) )
+	ROM_LOAD( "fe2001005.u69", 0x000000, 0x080000, CRC(d99f2879) SHA1(66e83a6bc9093d19c72bd8ef1ec0523cfe218250) )
+	ROM_LOAD( "fe2001006.u70", 0x080000, 0x080000, CRC(9df1e478) SHA1(f41b55821187b417ad09e4a1f439c01a107d2674) )
 ROM_END
 
 ROM_START( jjsquawkb )
@@ -10162,7 +10156,7 @@
 	ROM_COPY( "gfxtemp", 0x300000, 0x100000, 0x100000 )
 
 	ROM_REGION( 0x100000, "x1snd", 0 )	/* Samples */
-	ROM_LOAD( "1", 0x000000, 0x100000, CRC(181a55b8) SHA1(6fa404f85bad93cc15e80feb61d19bed84602b82) ) /* jj-rom5.040 + jj-rom6.040 from jjsquawk */
+	ROM_LOAD( "1", 0x000000, 0x100000, CRC(181a55b8) SHA1(6fa404f85bad93cc15e80feb61d19bed84602b82) ) /* fe2001005.u69 + fe2001006.u70 from jjsquawk */
 ROM_END
 
 ROM_START( jjsquawkb2 ) /* PCB was P0-078A, which was a Blandia board converted to JJ Squawkers. No labels on any of the ROMs */
@@ -10173,19 +10167,19 @@
 	ROM_CONTINUE   (                0x100001, 0x040000  )
 
 	ROM_REGION( 0x200000, "gfx1", 0 )	/* Sprites */
-	ROM_LOAD( "u64.3l",  0x000000, 0x100000, CRC(11d8713a) SHA1(8e3359f605913625191ac0a09222ec465b5fea71) ) /* jj-rom9 + jj-rom10 from jjsquawk */
-	ROM_LOAD( "u63.2l",  0x100000, 0x100000, CRC(7a385ef0) SHA1(d38e2242532074b58707783608a6ddce42c55a77) ) /* jj-rom7 + jj-rom8  from jjsquawk */
+	ROM_LOAD( "u64.3l",  0x000000, 0x100000, CRC(11d8713a) SHA1(8e3359f605913625191ac0a09222ec465b5fea71) ) /* fe2001009 + fe2001010 from jjsquawk */
+	ROM_LOAD( "u63.2l",  0x100000, 0x100000, CRC(7a385ef0) SHA1(d38e2242532074b58707783608a6ddce42c55a77) ) /* fe2001007 + fe2001008 from jjsquawk */
 
 	ROM_REGION( 0x200000, "gfx2", 0 )	/* Layer 1 */
-	ROM_LOAD       ( "u66.5l", 0x000000, 0x100000, CRC(bbaf40c5) SHA1(aecd48176adbe79e76c8febca1d9bb95ff0d6912) ) /* jj-rom11 + jj-rom12 from jjsquawk */
-	ROM_LOAD16_BYTE( "u65.4l", 0x100000, 0x080000, CRC(a5a35caf) SHA1(da4bdb7f0b319f8ff972a552d0134a73e5ac1b87) ) /* jj-rom3.040         from jjsquawk */
+	ROM_LOAD       ( "u66.5l", 0x000000, 0x100000, CRC(bbaf40c5) SHA1(aecd48176adbe79e76c8febca1d9bb95ff0d6912) ) /* fe2001011 + fe2001012 from jjsquawk */
+	ROM_LOAD16_BYTE( "u65.4l", 0x100000, 0x080000, CRC(a5a35caf) SHA1(da4bdb7f0b319f8ff972a552d0134a73e5ac1b87) ) /* fe2001003             from jjsquawk */
 
 	ROM_REGION( 0x200000, "gfx3", 0 )	/* Layer 2 */
-	ROM_LOAD       ( "u68.7l", 0x000000, 0x100000, CRC(ae9ae01f) SHA1(1a828d5b8848c5b5d8e5f279f1fde26b972a6332) ) /* jj-rom14 + jj-rom13 from jjsquawk */
-	ROM_LOAD16_BYTE( "u67.6l", 0x100000, 0x080000, CRC(a235488e) SHA1(a45d02a4451defbef7fbdab15671955fab8ed76b) ) /* jj-rom4.040         from jjsquawk */
+	ROM_LOAD       ( "u68.7l", 0x000000, 0x100000, CRC(ae9ae01f) SHA1(1a828d5b8848c5b5d8e5f279f1fde26b972a6332) ) /* fe2001014 + fe2001013 from jjsquawk */
+	ROM_LOAD16_BYTE( "u67.6l", 0x100000, 0x080000, CRC(a235488e) SHA1(a45d02a4451defbef7fbdab15671955fab8ed76b) ) /* fe2001004             from jjsquawk */
 
 	ROM_REGION( 0x100000, "x1snd", 0 )	/* Samples */
-	ROM_LOAD( "u70.10l", 0x000000, 0x100000, CRC(181a55b8) SHA1(6fa404f85bad93cc15e80feb61d19bed84602b82) ) /* jj-rom5.040 + jj-rom6.040 from jjsquawk */
+	ROM_LOAD( "u70.10l", 0x000000, 0x100000, CRC(181a55b8) SHA1(6fa404f85bad93cc15e80feb61d19bed84602b82) ) /* fe2001005.u69 + fe2001006.u70 from jjsquawk */
 ROM_END
 
 ROM_START( kamenrid )
diff -Nru src-old/mame/drivers/spacefb.c src/mame/drivers/spacefb.c
--- src-old/mame/drivers/spacefb.c	2012-04-30 17:21:04.000000000 +0200
+++ src/mame/drivers/spacefb.c	2012-06-26 00:28:46.000000000 +0200
@@ -288,10 +288,10 @@
 	PORT_DIPSETTING(    0x02, "5" )
 	PORT_DIPSETTING(    0x03, "6" )
 	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW:3,4")
+	PORT_DIPSETTING(    0x08, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_2C ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( 1C_3C ) )
 	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Bonus_Life ) ) PORT_DIPLOCATION("SW:5")
 	PORT_DIPSETTING(    0x00, "5000" )
 	PORT_DIPSETTING(    0x10, "8000" )
@@ -302,29 +302,22 @@
 INPUT_PORTS_END
 
 
-/* same as Space Firebird, except for the difficulty switch */
+/* same as Space Firebird, except for the difficulty switch (replacing 5/6 lives) and 1C_3C (rather than 3C_1C) */
 static INPUT_PORTS_START( spacedem )
 	PORT_INCLUDE( spacefb )
 
 	PORT_MODIFY("DSW")
-	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Lives ) )
+	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Lives ) )  PORT_DIPLOCATION("SW:1")
 	PORT_DIPSETTING(    0x00, "3" )
 	PORT_DIPSETTING(    0x01, "4" )
-	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Difficulty ) )
+	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Difficulty ) )  PORT_DIPLOCATION("SW:2")
 	PORT_DIPSETTING(    0x00, DEF_STR( Easy ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( Hard ) )
-	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Coinage ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Hard ) )
+	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Coinage ) )  PORT_DIPLOCATION("SW:3,4")
 	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_3C ) )
-	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Bonus_Life ) )
-	PORT_DIPSETTING(    0x00, "5000" )
-	PORT_DIPSETTING(    0x10, "8000" )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Cabinet ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( Upright ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Cocktail ) )
-	PORT_BIT( 0xc0, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 INPUT_PORTS_END
 
 
@@ -563,7 +556,7 @@
 	ROM_LOAD( "sdm-c-5n",    0x3800, 0x0800, CRC(7e0e41b0) SHA1(e7dd509ab36e0f9be6350b5fa9de4694224477db) )
 
 	ROM_REGION( 0x1000, "audiocpu", 0 )
-    ROM_LOAD( "sdm-e-20",    0x0000, 0x0400, CRC(55f40a0b) SHA1(8dff27b636f7f1831f71816505e451cf97fc3f98) )
+	ROM_LOAD( "sdm-e-20",    0x0000, 0x0400, CRC(55f40a0b) SHA1(8dff27b636f7f1831f71816505e451cf97fc3f98) )
 
 	ROM_REGION( 0x1000, "gfx1", 0 )  /* sprites */
 	ROM_LOAD( "sdm-v-5k",    0x0000, 0x0800, CRC(55758e4d) SHA1(1338b45f76f5a31a5350c953eac36cc543fbe62e) )
diff -Nru src-old/mame/drivers/taito_h.c src/mame/drivers/taito_h.c
--- src-old/mame/drivers/taito_h.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/drivers/taito_h.c	2012-06-28 05:36:32.000000000 +0200
@@ -5,8 +5,8 @@
 driver by Yochizo
 
 This driver is heavily dependent on the Raine source.
-Very thanks to Richard Bush and the Raine team. Also,
-I have been given a lot of helpful informations by
+Special thanks to Richard Bush and the Raine team. Also,
+I have been given a lot of helpful information by
 Yasuhiro Ogawa. Thank you, Yasu.
 
 
@@ -20,14 +20,14 @@
 System specs :
 ===============
  CPU   : MC68000 (12 MHz) x 1, Z80 (4 MHz?, sound CPU) x 1
- Sound : YM2610, YM3016?
+ Sound : YM2610, YM3016
  OSC   : 20.000 MHz, 8.000 MHz, 24.000 MHz
- Chips : TC0070RGB (Palette?)
+ Chips : TC0070RGB (RGB/Video Mixer)
          TC0220IOC (Input)
          TC0140SYT (Sound communication)
          TC0130LNB (???)
          TC0160ROM (???)
-         TC0080VCO (Video?)
+         TC0080VCO (Tilemap & Motion Object Gen)
 
  name             irq    resolution   tx-layer   tc0220ioc
  --------------------------------------------------------------
@@ -424,7 +424,7 @@
 	PORT_DIPSETTING(    0x01, "Constant" )
 	PORT_DIPSETTING(    0x00, "Based on Inning" )
 	TAITO_DSWA_BITS_1_TO_3_LOC(SW1)
-	TAITO_COINAGE_JAPAN_OLD_LOC(SW1)
+	TAITO_COINAGE_US_LOC(SW1)
 
 	/* 0x200002 -> 0x100527.b ($527,A5) */
 	PORT_START("DSWB")
@@ -464,6 +464,13 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 INPUT_PORTS_END
 
+static INPUT_PORTS_START( dleaguej )
+	PORT_INCLUDE(dleague)
+
+	PORT_MODIFY("DSWA")
+	TAITO_COINAGE_JAPAN_OLD_LOC(SW1)
+INPUT_PORTS_END
+
 
 /***************************************************************************
 
@@ -559,11 +566,11 @@
 static MACHINE_CONFIG_START( syvalion, taitoh_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", M68000,24000000 / 2)		/* 12 MHz */
+	MCFG_CPU_ADD("maincpu", M68000, XTAL_24MHz / 2)		/* 12 MHz */
 	MCFG_CPU_PROGRAM_MAP(syvalion_map)
 	MCFG_CPU_VBLANK_INT("screen", irq2_line_hold)
 
-	MCFG_CPU_ADD("audiocpu", Z80,8000000 / 2)		/* 4 MHz ??? */
+	MCFG_CPU_ADD("audiocpu", Z80, XTAL_8MHz / 2)		/* 4 MHz ??? */
 	MCFG_CPU_PROGRAM_MAP(sound_map)
 
 	MCFG_MACHINE_START(taitoh)
@@ -589,7 +596,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("ymsnd", YM2610, 8000000)
+	MCFG_SOUND_ADD("ymsnd", YM2610, XTAL_8MHz)
 	MCFG_SOUND_CONFIG(ym2610_config)
 	MCFG_SOUND_ROUTE(0, "mono", 0.25)
 	MCFG_SOUND_ROUTE(1, "mono", 1.0)
@@ -602,11 +609,11 @@
 static MACHINE_CONFIG_START( recordbr, taitoh_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", M68000,24000000 / 2)		/* 12 MHz */
+	MCFG_CPU_ADD("maincpu", M68000, XTAL_24MHz / 2)		/* 12 MHz */
 	MCFG_CPU_PROGRAM_MAP(recordbr_map)
 	MCFG_CPU_VBLANK_INT("screen", irq2_line_hold)
 
-	MCFG_CPU_ADD("audiocpu", Z80,8000000 / 2)		/* 4 MHz ??? */
+	MCFG_CPU_ADD("audiocpu", Z80, XTAL_8MHz / 2)		/* 4 MHz ??? */
 	MCFG_CPU_PROGRAM_MAP(sound_map)
 
 	MCFG_MACHINE_START(taitoh)
@@ -632,7 +639,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("ymsnd", YM2610, 8000000)
+	MCFG_SOUND_ADD("ymsnd", YM2610, XTAL_8MHz)
 	MCFG_SOUND_CONFIG(ym2610_config)
 	MCFG_SOUND_ROUTE(0, "mono", 0.25)
 	MCFG_SOUND_ROUTE(1, "mono", 1.0)
@@ -645,11 +652,11 @@
 static MACHINE_CONFIG_START( dleague, taitoh_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", M68000,24000000 / 2)		/* 12 MHz */
+	MCFG_CPU_ADD("maincpu", M68000, XTAL_24MHz / 2)		/* 12 MHz */
 	MCFG_CPU_PROGRAM_MAP(dleague_map)
 	MCFG_CPU_VBLANK_INT("screen", irq1_line_hold)
 
-	MCFG_CPU_ADD("audiocpu", Z80,8000000 / 2)		/* 4 MHz ??? */
+	MCFG_CPU_ADD("audiocpu", Z80, XTAL_8MHz / 2)		/* 4 MHz ??? */
 	MCFG_CPU_PROGRAM_MAP(sound_map)
 
 	MCFG_MACHINE_START(taitoh)
@@ -675,7 +682,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("ymsnd", YM2610, 8000000)
+	MCFG_SOUND_ADD("ymsnd", YM2610, XTAL_8MHz)
 	MCFG_SOUND_CONFIG(ym2610_config)
 	MCFG_SOUND_ROUTE(0, "mono", 0.25)
 	MCFG_SOUND_ROUTE(1, "mono", 1.0)
@@ -791,6 +798,38 @@
 
 ROM_START( dleague )
 	ROM_REGION( 0x60000, "maincpu", 0 )
+	ROM_LOAD16_BYTE( "c02-xx.33", 0x00000, 0x20000, CRC(eda870a7) SHA1(1749a6eb80c137b042d4935fcb9cff1ca50d4397) ) /* Need to verify proper Taito chip number */
+	ROM_LOAD16_BYTE( "c02-xx.36", 0x00001, 0x20000, CRC(f52114af) SHA1(d500933852332a9463a5738cf5890625c9b35d65) ) /* Need to verify proper Taito chip number */
+	ROM_LOAD16_BYTE( "c02-20.34", 0x40000, 0x10000, CRC(cdf593f3) SHA1(6afbd9d8d74e6801dc991eb9fd3205057747b986) )
+	ROM_LOAD16_BYTE( "c02-xx.37", 0x40001, 0x10000, CRC(820a8241) SHA1(a1b75e76f6806d5cbdb97f59d29aa846a6f3bb8b) ) /* Need to verify proper Taito chip number */
+
+	ROM_REGION( 0x1c000, "audiocpu", 0 )
+	ROM_LOAD( "c02-23.40", 0x00000, 0x04000, CRC(5632ee49) SHA1(90dedaf40ab526529cd7d569b78a9d5451ec3e25) )
+	ROM_CONTINUE(          0x10000, 0x0c000 )
+
+	ROM_REGION( 0x400000, "gfx1", 0 )
+	ROM_LOAD       ( "c02-02.15", 0x000000, 0x80000, CRC(b273f854) SHA1(5961b9fe2c49fb05f5bc3e27e05925dbef8577e9) )
+	ROM_LOAD16_BYTE( "c02-06.6",  0x080000, 0x20000, CRC(b8473c7b) SHA1(8fe8d838bdba7aaaf4527ac1c5c16604922bb245) )
+	ROM_LOAD16_BYTE( "c02-10.14", 0x080001, 0x20000, CRC(50c02f0f) SHA1(7d13b798c0a98387719ab738b9178ee6079327b2) )
+	ROM_LOAD       ( "c02-03.17", 0x100000, 0x80000, CRC(c3fd0dcd) SHA1(43f32cefbca203bd0453e1c3d4523f0834900418) )
+	ROM_LOAD16_BYTE( "c02-07.7",  0x180000, 0x20000, CRC(8c1e3296) SHA1(088b028189131186c82c61c38d5a936a0cc9830f) )
+	ROM_LOAD16_BYTE( "c02-11.16", 0x180001, 0x20000, CRC(fbe548b8) SHA1(c2b453fc213c21d118810b8502836e7a2ba5626b) )
+	ROM_LOAD       ( "c02-24.19", 0x200000, 0x80000, CRC(18ef740a) SHA1(27f0445c053e28267e5688627d4f91d158d4fb07) )
+	ROM_LOAD16_BYTE( "c02-08.8",  0x280000, 0x20000, CRC(1a3c2f93) SHA1(0e45f8211dae8e17e67d26173262ca9831ccd283) )
+	ROM_LOAD16_BYTE( "c02-12.18", 0x280001, 0x20000, CRC(b1c151c5) SHA1(3fc3d4270cad52c4a82c217b452e534d24bd8548) )
+	ROM_LOAD       ( "c02-05.21", 0x300000, 0x80000, CRC(fe3a5179) SHA1(34a98969c553ee8c52aeb4fb09670a4ad572446e) )
+	ROM_LOAD16_BYTE( "c02-09.9",  0x380000, 0x20000, CRC(a614d234) SHA1(dc68a6a8cf89ab82edc571853249643aa304d37f) )
+	ROM_LOAD16_BYTE( "c02-13.20", 0x380001, 0x20000, CRC(8eb3194d) SHA1(98290f77a03826cdf7c8238dd35da1f9349d5cf5) )
+
+	ROM_REGION( 0x02000, "user1", 0 ) /* zoom table / mixing? */
+	ROM_LOAD( "c02-18.22", 0x00000, 0x02000, CRC(c88f0bbe) SHA1(18c87c744fbeca35d13033e50f62e5383eb4ec2c) )
+
+	ROM_REGION( 0x80000, "ymsnd", 0 )	/* samples */
+	ROM_LOAD( "c02-01.31", 0x00000, 0x80000, CRC(d5a3d1aa) SHA1(544f807015b5d854a4d8cb73e4dbae4b953fd440) )
+ROM_END
+
+ROM_START( dleaguej )
+	ROM_REGION( 0x60000, "maincpu", 0 )
 	ROM_LOAD16_BYTE( "c02-19a.33", 0x00000, 0x20000, CRC(7e904e45) SHA1(04ac470c973753e71fba3998099a88ab0e6fcbab) )
 	ROM_LOAD16_BYTE( "c02-21a.36", 0x00001, 0x20000, CRC(18c8a32b) SHA1(507cd7a83dcb6eaefa52f2661b9f3a6fabbfbd46) )
 	ROM_LOAD16_BYTE( "c02-20.34",  0x40000, 0x10000, CRC(cdf593f3) SHA1(6afbd9d8d74e6801dc991eb9fd3205057747b986) )
@@ -822,8 +861,9 @@
 ROM_END
 
 
-/*  ( YEAR  NAME      PARENT    MACHINE   INPUT     INIT     MONITOR  COMPANY  FULLNAME */
-GAME( 1988, syvalion, 0,        syvalion, syvalion, 0,       ROT0,    "Taito Corporation",       "Syvalion (Japan)",        GAME_SUPPORTS_SAVE )
-GAME( 1988, recordbr, 0,        recordbr, recordbr, 0,       ROT0,    "Taito Corporation Japan", "Recordbreaker (World)",   GAME_SUPPORTS_SAVE )
-GAME( 1988, gogold,   recordbr, recordbr, gogold,   0,       ROT0,    "Taito Corporation",       "Go For The Gold (Japan)", GAME_SUPPORTS_SAVE )
-GAME( 1990, dleague,  0,        dleague,  dleague,  0,       ROT0,    "Taito Corporation",       "Dynamite League (Japan)", GAME_SUPPORTS_SAVE )
+/*  ( YEAR  NAME      PARENT    MACHINE   INPUT     INIT     MONITOR  COMPANY                      FULLNAME */
+GAME( 1988, syvalion, 0,        syvalion, syvalion, 0,       ROT0,    "Taito Corporation",         "Syvalion (Japan)",        GAME_SUPPORTS_SAVE )
+GAME( 1988, recordbr, 0,        recordbr, recordbr, 0,       ROT0,    "Taito Corporation Japan",   "Recordbreaker (World)",   GAME_SUPPORTS_SAVE )
+GAME( 1988, gogold,   recordbr, recordbr, gogold,   0,       ROT0,    "Taito Corporation",         "Go For The Gold (Japan)", GAME_SUPPORTS_SAVE )
+GAME( 1990, dleague,  0,        dleague,  dleague,  0,       ROT0,    "Taito America Corporation", "Dynamite League (US)", GAME_SUPPORTS_SAVE )
+GAME( 1990, dleaguej, dleague,  dleague,  dleaguej, 0,       ROT0,    "Taito Corporation",         "Dynamite League (Japan)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/taitowlf.c src/mame/drivers/taitowlf.c
--- src-old/mame/drivers/taitowlf.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/taitowlf.c	2012-07-02 08:20:21.000000000 +0200
@@ -479,7 +479,7 @@
 	AM_RANGE(0x0278, 0x027b) AM_WRITE(pnp_config_w)
 	AM_RANGE(0x03f0, 0x03ff) AM_READWRITE(fdc_r, fdc_w)
 	AM_RANGE(0x0a78, 0x0a7b) AM_WRITE(pnp_data_w)
-	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE_LEGACY("pcibus", pci_32le_r,	pci_32le_w)
+	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_bus_legacy_device, read, write)
 ADDRESS_MAP_END
 
 /*****************************************************************************/
@@ -625,9 +625,9 @@
 	MCFG_MACHINE_START(taitowlf)
 	MCFG_MACHINE_RESET(taitowlf)
 
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
-	MCFG_PCI_BUS_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
 
 	MCFG_PIT8254_ADD( "pit8254", taitowlf_pit8254_config )
 	MCFG_I8237_ADD( "dma8237_1", XTAL_14_31818MHz/3, dma8237_1_config )
diff -Nru src-old/mame/drivers/tmaster.c src/mame/drivers/tmaster.c
--- src-old/mame/drivers/tmaster.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/tmaster.c	2012-06-29 23:55:18.000000000 +0200
@@ -1283,6 +1283,23 @@
 	ROM_LOAD( "tm4k_sound.u8", 0x00000, 0x100000, CRC(48c3782b) SHA1(bfe105ddbde8bbbd84665dfdd565d6d41926834a) ) /* Mask rom labeled 5341-15746-07 U8 SOUND IMAGE */
 ROM_END
 
+ROM_START( tm4kca )
+	ROM_REGION( 0x200000, "maincpu", 0 ) // 68000 Code
+	ROM_LOAD16_BYTE( "tm4k_v602ca.u51", 0x000000, 0x100000, CRC(b355e15e) SHA1(e6a6cd74d3439f589ac0a914ec66962ce2885c00) ) /* TOUCHMASTER 4000 U51 CALIFORNIA  6.02 (CA. 4-14-98) */
+	ROM_LOAD16_BYTE( "tm4k_v602ca.u52", 0x000001, 0x100000, CRC(0adbbfc0) SHA1(4660bd95649bfc65d3e52975d168de4963bd27cb) ) /* TOUCHMASTER 4000 U52 CALIFORNIA  6.02 (CA. 4-14-98) */
+
+	ROM_REGION( 0x600000, "blitter", 0 )	// Blitter gfx
+	ROM_LOAD16_BYTE( "tm4k_graphic.u38", 0x000000, 0x100000, CRC(a6683899) SHA1(d05024390917cdb1871d030996da8e1eb6460918) ) /* Mask rom labeled 5341-15746-03 U38 VIDEO IMAGE */
+	ROM_LOAD16_BYTE( "tm4k_graphic.u36", 0x000001, 0x100000, CRC(7bde520d) SHA1(77750b689e2f0d47804042456e54bbd9c28deeac) ) /* Mask rom labeled 5341-15746-01 U36 VIDEO IMAGE */
+	ROM_LOAD16_BYTE( "tm4k_graphic.u39", 0x200000, 0x100000, CRC(bac88cfb) SHA1(26ed169296b890c5f5b50c418c15299355a6592f) ) /* Mask rom labeled 5341-15746-04 U39 VIDEO IMAGE */
+	ROM_LOAD16_BYTE( "tm4k_graphic.u37", 0x200001, 0x100000, CRC(bf49fafa) SHA1(b400667bf654dc9cd01a85c8b99670459400fd60) ) /* Mask rom labeled 5341-15746-02 U37 VIDEO IMAGE */
+	ROM_LOAD16_BYTE( "tm4k_graphic.u41", 0x400000, 0x100000, CRC(e97edb1e) SHA1(75510676cf1692ad03efd4ccd57d25af1cc8ef2a) ) /* Mask rom labeled 5341-15746-06 U41 VIDEO IMAGE */
+	ROM_LOAD16_BYTE( "tm4k_graphic.u40", 0x400001, 0x100000, CRC(f6771a09) SHA1(74f71d5e910006c83a38170f24aa811c38a3e020) ) /* Mask rom labeled 5341-15746-05 U40 VIDEO IMAGE */
+
+	ROM_REGION( 0x100000, "oki", 0 ) // Samples
+	ROM_LOAD( "tm4k_sound.u8", 0x00000, 0x100000, CRC(48c3782b) SHA1(bfe105ddbde8bbbd84665dfdd565d6d41926834a) ) /* Mask rom labeled 5341-15746-07 U8 SOUND IMAGE */
+ROM_END
+
 ROM_START( tm4kb )
 	ROM_REGION( 0x200000, "maincpu", 0 ) // 68000 Code
 	ROM_LOAD16_BYTE( "tm4k_v601.u51", 0x000000, 0x100000, CRC(cdcfd064) SHA1(51f022d25411d119a5f16ff7f09f4bed59b937e1) ) /* TOUCHMASTER 4000 U51 DOMESTIC  6.01 (Standard 3-23-98) */
@@ -1663,6 +1680,28 @@
 }
 
 
+static DRIVER_INIT( tm4kca )
+{
+	UINT16 *ROM = (UINT16 *)machine.root_device().memregion( "maincpu" )->base();
+
+	// protection
+	ROM[0x83470/2] = 0x4e75;
+
+	ROM[0x83426/2] = 0x601a;
+	ROM[0x83466/2] = 0x6002;
+/*
+Protection starts:
+
+ 83416: addi.w  #$384, D0       0640 0384
+ 8341a: move.w  D0, $207a86.l   33C0 0020 7A86
+ 83420: btst    #$7, ($1,A5)    082D 0007 0001
+ 83426: beq     $83448          671A           <-- First patch goes here
+
+*/
+
+}
+
+
 static DRIVER_INIT( tm4kb )
 {
 	UINT16 *ROM = (UINT16 *)machine.root_device().memregion( "maincpu" )->base();
@@ -1897,6 +1936,7 @@
 GAME( 1997, tm3ka,    tm3k,     tm3k,     tmaster,  0,        ROT0, "Midway Games Inc.",                       "Touchmaster 3000 (v5.01 Standard)",      0 )
 GAME( 1998, tm4k,     0,        tm3k,     tmaster,  tm4k,     ROT0, "Midway Games Inc.",                       "Touchmaster 4000 (v6.03 Standard)",      0 )
 GAME( 1998, tm4ka,    tm4k,     tm3k,     tmaster,  tm4ka,    ROT0, "Midway Games Inc.",                       "Touchmaster 4000 (v6.02 Standard)",      0 )
+GAME( 1998, tm4kca,   tm4k,     tm3k,     tmaster,  tm4kca,   ROT0, "Midway Games Inc.",                       "Touchmaster 4000 (v6.02 California)",    0 )
 GAME( 1998, tm4kb,    tm4k,     tm3k,     tmaster,  tm4kb,    ROT0, "Midway Games Inc.",                       "Touchmaster 4000 (v6.01 Standard)",      0 )
 GAME( 1998, tm5k,     0,        tm3k,     tmaster,  tm5k,     ROT0, "Midway Games Inc.",                       "Touchmaster 5000 (v7.10 Standard)",      0 )
 GAME( 1998, tm5kca,   tm5k,     tm3k,     tmaster,  tm5kca,   ROT0, "Midway Games Inc.",                       "Touchmaster 5000 (v7.10 California)",    0 )
diff -Nru src-old/mame/drivers/twinkle.c src/mame/drivers/twinkle.c
--- src-old/mame/drivers/twinkle.c	2012-05-31 21:19:13.000000000 +0200
+++ src/mame/drivers/twinkle.c	2012-06-14 12:30:27.000000000 +0200
@@ -1017,6 +1017,22 @@
 	DISK_IMAGE_READONLY("c44jaa03", 0, SHA1(53e9bd25d1674a04aeec81c0224b4e4e44af802a) )	// was part of a 1st mix machine, but "c44" indicates 8th mix?
 ROM_END
 
+ROM_START( bmiidx2 )
+	TWINKLE_BIOS
+
+	ROM_REGION( 0x100, "security", 0 )
+	ROM_LOAD( "985j.pd",      0x000000, 0x000100, BAD_DUMP CRC(a35143a9) SHA1(1c0feeab60d9dc50dc4b9a2f3dac73ca619e74b0) )
+
+	DISK_REGION( "cdrom0" )
+	DISK_IMAGE_READONLY( "985jaa01", 0, BAD_DUMP SHA1(0b783f11317f64552ebf3323459139529e7f315f) )
+
+	DISK_REGION( "cdrom1" ) // video CD
+	DISK_IMAGE_READONLY( "985jaa02", 0, NO_DUMP )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE_READONLY( "985jaahd", 0, NO_DUMP )
+ROM_END
+
 ROM_START( bmiidx3 )
 	TWINKLE_BIOS
 
@@ -1025,8 +1041,12 @@
 
 	DISK_REGION( "cdrom0" )
 	DISK_IMAGE_READONLY( "992jaa01", 0, BAD_DUMP SHA1(7e5389735dff379bb286ba3744edf59b7dfcc74b) )
-//  DISK_IMAGE_READONLY( "992jaahd", 1, NO_DUMP )
-//  DISK_IMAGE_READONLY( "992jaa02", 2, NO_DUMP )
+
+	DISK_REGION( "cdrom1" ) // video CD
+	DISK_IMAGE_READONLY( "992jaa02", 0, NO_DUMP )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE_READONLY( "992jaahd", 0, NO_DUMP )
 ROM_END
 
 ROM_START( bmiidx4 )
@@ -1037,8 +1057,12 @@
 
 	DISK_REGION( "cdrom0" )
 	DISK_IMAGE_READONLY( "a03jaa01", 0, BAD_DUMP SHA1(2a587b5524bac6f03d26b55247a0acd22aad6c3a) )
-//  DISK_IMAGE_READONLY( "a03jaahd", 1, NO_DUMP )
-//  DISK_IMAGE_READONLY( "a03jaa02", 2, NO_DUMP )
+
+	DISK_REGION( "cdrom1" ) // video CD
+	DISK_IMAGE_READONLY( "a03jaa02", 0, NO_DUMP )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE_READONLY( "a03jaahd", 0, NO_DUMP )
 ROM_END
 
 ROM_START( bmiidx6 )
@@ -1049,8 +1073,12 @@
 
 	DISK_REGION( "cdrom0" )
 	DISK_IMAGE_READONLY( "b4ujaa01", 0, BAD_DUMP SHA1(d8f5d56b8728bea761dc4cdbc04851094d276bd6) )
-//  DISK_IMAGE_READONLY( "b4ujaahd", 1, NO_DUMP )
-//  DISK_IMAGE_READONLY( "b4ujaa02", 2, NO_DUMP )
+
+	DISK_REGION( "cdrom1" ) // DVD
+	DISK_IMAGE_READONLY( "b4ujaa02", 0, NO_DUMP )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE_READONLY( "b4ujaahd", 0, NO_DUMP )
 ROM_END
 
 ROM_START( bmiidx7 )
@@ -1061,8 +1089,12 @@
 
 	DISK_REGION( "cdrom0" )
 	DISK_IMAGE_READONLY( "b44jaa01", 0, BAD_DUMP SHA1(a21610f3dc090e39e125d063442ed877fa056146) )
-//  DISK_IMAGE_READONLY( "b44jaahd", 1, NO_DUMP )
-//  DISK_IMAGE_READONLY( "b44jaa02", 2, NO_DUMP )
+
+	DISK_REGION( "cdrom1" ) // DVD
+	DISK_IMAGE_READONLY( "b44jaa02", 0, NO_DUMP )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE_READONLY( "b44jaahd", 0, NO_DUMP )
 ROM_END
 
 ROM_START( bmiidx8 )
@@ -1073,8 +1105,12 @@
 
 	DISK_REGION( "cdrom0" )
 	DISK_IMAGE_READONLY( "c44jaa01", 0, BAD_DUMP SHA1(8b544c81bc56b19e4aa1649e68824811d6d51ce5) )
-//  DISK_IMAGE_READONLY( "c44jaahd", 1, NO_DUMP )
-//  DISK_IMAGE_READONLY( "c44jaa02", 2, NO_DUMP )
+
+	DISK_REGION( "cdrom1" ) // DVD
+	DISK_IMAGE_READONLY( "c44jaa02", 0, NO_DUMP )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE_READONLY( "c44jaahd", 0, NO_DUMP )
 ROM_END
 
 ROM_START( bmiidxc )
@@ -1085,8 +1121,12 @@
 
 	DISK_REGION( "cdrom0" )
 	DISK_IMAGE_READONLY( "896jaabm", 0, BAD_DUMP SHA1(af008e5bcf18da4e9aea752a712c843e37a74be5) )
-//  DISK_IMAGE_READONLY( "abmjaahd", 1, NO_DUMP )
-//  DISK_IMAGE_READONLY( "abmjaa02", 2, NO_DUMP )
+
+	DISK_REGION( "cdrom1" ) // video CD
+	DISK_IMAGE_READONLY( "abmjaa02", 0, NO_DUMP )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE_READONLY( "abmjaahd", 0, NO_DUMP )
 ROM_END
 
 ROM_START( bmiidxc2 )
@@ -1097,8 +1137,12 @@
 
 	DISK_REGION( "cdrom0" )
 	DISK_IMAGE_READONLY( "984a01bm", 0, BAD_DUMP SHA1(d9b7d74a72a76e4e9cf7725e0fb8dafcc1c87187) )
-//  DISK_IMAGE_READONLY( "abmjaahd", 1, NO_DUMP )
-//  DISK_IMAGE_READONLY( "abmjaa02", 2, NO_DUMP )
+
+	DISK_REGION( "cdrom1" ) // video CD
+	DISK_IMAGE_READONLY( "abmjaa02", 0, NO_DUMP )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE_READONLY( "abmjaahd", 0, NO_DUMP )
 ROM_END
 
 ROM_START( bmiidxca )
@@ -1109,8 +1153,12 @@
 
 	DISK_REGION( "cdrom0" )
 	DISK_IMAGE_READONLY( "896jabbm", 0, BAD_DUMP SHA1(117ae4c876207bbaf9e8fe0fdf5bb161155c1bdb) )
-//  DISK_IMAGE_READONLY( "abmjaahd", 1, NO_DUMP )
-//  DISK_IMAGE_READONLY( "abmjaa02", 2, NO_DUMP )
+
+	DISK_REGION( "cdrom1" ) // video CD
+	DISK_IMAGE_READONLY( "abmjaa02", 0, NO_DUMP )
+
+	DISK_REGION( "drive_0" )
+	DISK_IMAGE_READONLY( "abmjaahd", 0, NO_DUMP )
 ROM_END
 
 GAME( 1999, gq863,    0,       twinkle, twinkle, twinkle, ROT0, "Konami", "Twinkle System", GAME_IS_BIOS_ROOT )
@@ -1123,8 +1171,8 @@
 /* 1999 - beatmania IIDX substream */
 GAME( 1999, bmiidxc2, gq863,   twinkle, twinkle, twinkle, ROT0, "Konami", "beatmania IIDX Substream 2 with DDR 2nd Club Version (984 A01 BM)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_NOT_WORKING  )
 
-/* 1999 - beatmania IIDX 2nd style */
 /* these use i2c for security */
+GAME( 1999, bmiidx2,  gq863,   twinkle, twinkle, twinkle, ROT0, "Konami", "beatmania IIDX 2nd style (GC985 JA)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_NOT_WORKING  )
 GAME( 2000, bmiidx3,  gq863,   twinkle, twinkle, twinkle, ROT0, "Konami", "beatmania IIDX 3rd style (GC992 JA)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_NOT_WORKING  )
 GAME( 2000, bmiidx4,  gq863,   twinkle, twinkle, twinkle, ROT0, "Konami", "beatmania IIDX 4th style (GCA03 JA)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_NOT_WORKING  )
 /* 2001 - beatmania IIDX 5th style */
diff -Nru src-old/mame/drivers/tx1.c src/mame/drivers/tx1.c
--- src-old/mame/drivers/tx1.c	2012-05-25 16:38:46.000000000 +0200
+++ src/mame/drivers/tx1.c	2012-06-23 22:02:16.000000000 +0200
@@ -5,7 +5,7 @@
     driver by Phil Bennett
 
     Games supported:
-        * TX-1 (1983) [2 sets]
+        * TX-1 (1983) [3 sets]
         * Buggy Boy (1985)
         * Buggy Boy Junior (1986)
 
@@ -13,7 +13,7 @@
         * TX-1 V8 (1984)
 
     Notes:
-        * TX-1 tyre screech noises are not implemented yet.
+        * TX-1 tire screech noises are not implemented yet.
 
 ****************************************************************************
 
@@ -107,27 +107,29 @@
 
 static INPUT_PORTS_START( tx1 )
 	PORT_START("DSW")
-	PORT_DIPNAME( 0x001c, 0x0000, DEF_STR( Coin_A ) )
-	PORT_DIPSETTING(      0x0008, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(      0x0004, DEF_STR( 2C_1C ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(      0x001c, DEF_STR( 2C_3C ) )
-	PORT_DIPSETTING(      0x000c, DEF_STR( 1C_2C ) )
-	PORT_DIPSETTING(      0x0010, DEF_STR( 1C_3C ) )
-	PORT_DIPSETTING(      0x0014, DEF_STR( 1C_5C ) )
-	PORT_DIPSETTING(      0x0018, DEF_STR( 1C_6C ) )
+	/* Dipswitch DS.2 is 6 switches but "maps" to switches 2 to 8 (at 6P according to the manual)  */
+	PORT_DIPNAME( 0x000c, 0x0000, "Game Cost" )			PORT_DIPLOCATION("DS.2:1,2")
+	PORT_DIPSETTING(      0x0000, "1 Coin Unit for 1 Credit" )
+	PORT_DIPSETTING(      0x0004, "2 Coin Units for 1 Credit" )
+	PORT_DIPSETTING(      0x0008, "3 Coin Units for 1 Credit" )
+	PORT_DIPSETTING(      0x000c, "4 Coin Units for 1 Credit" )
 
-	PORT_DIPNAME( 0x00e0, 0x0000, DEF_STR( Coin_B ) )
-	PORT_DIPSETTING(      0x0040, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(      0x00e0, DEF_STR( 2C_3C ) )
-	PORT_DIPSETTING(      0x0060, DEF_STR( 1C_2C ) )
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )
-	PORT_DIPSETTING(      0x00a0, DEF_STR( 1C_5C ) )
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_6C ) )
+	PORT_DIPNAME( 0x0010, 0x0000, "Left Coin Mechanism" )		PORT_DIPLOCATION("DS.2:3")
+	PORT_DIPSETTING(      0x0000, "1 Coin for 1 Coin Unit" )
+	PORT_DIPSETTING(      0x0010, "1 Coin for 2 Coin Units" )
 
-	PORT_DIPNAME( 0x0700, 0x0300, DEF_STR( Difficulty ) )
+	PORT_DIPNAME( 0x0060, 0x0000, "Right Coin Mechanism" )		PORT_DIPLOCATION("DS.2:4,5")
+	PORT_DIPSETTING(      0x0000, "1 Coin for 1 Coin Unit" )
+	PORT_DIPSETTING(      0x0020, "1 Coin for 4 Coin Units" )
+	PORT_DIPSETTING(      0x0040, "1 Coin for 5 Coin Units" )
+	PORT_DIPSETTING(      0x0060, "1 Coin for 6 Coin Units" )
+
+	PORT_DIPNAME( 0x0080, 0x0080, DEF_STR( Unknown ) )		PORT_DIPLOCATION("DS.2:6") /* Manual states switches 6 to 8 unused (physically it's only 6 switches) */
+	PORT_DIPSETTING(      0x0080, DEF_STR( Off ) )
+	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
+
+	/* Dipswitch DS.1 is 8 switches (at 8P according to the manual) */
+	PORT_DIPNAME( 0x0700, 0x0300, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("DS.1:1,2,3")
 	PORT_DIPSETTING(      0x0000, "A (Easiest)" )
 	PORT_DIPSETTING(      0x0100, "B" )
 	PORT_DIPSETTING(      0x0200, "C" )
@@ -137,21 +139,21 @@
 	PORT_DIPSETTING(      0x0600, "G" )
 	PORT_DIPSETTING(      0x0700, "H (Hardest)" )
 
-	PORT_DIPNAME( 0x1800, 0x0800, DEF_STR( Game_Time ) )
+	PORT_DIPNAME( 0x1800, 0x1000, DEF_STR( Game_Time ) )	PORT_DIPLOCATION("DS.1:4,5")
 	PORT_DIPSETTING(      0x0000, "A (Longest)" )
 	PORT_DIPSETTING(      0x0800, "B" )
 	PORT_DIPSETTING(      0x1000, "C" )
 	PORT_DIPSETTING(      0x1800, "D (Shortest)" )
 
-	PORT_DIPNAME( 0xe000, 0x0000, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(      0x0000, "0" )
-	PORT_DIPSETTING(      0x2000, "1" )
-	PORT_DIPSETTING(      0x4000, "2" )
-	PORT_DIPSETTING(      0x6000, "3" )
-	PORT_DIPSETTING(      0x8000, "4" )
-	PORT_DIPSETTING(      0xa000, "5" )
-	PORT_DIPSETTING(      0xc000, "6" )
-	PORT_DIPSETTING(      0xe000, "7" )
+	PORT_DIPNAME( 0xe000, 0xe000, "Bonus Adder" )		PORT_DIPLOCATION("DS.1:6,7,8")
+	PORT_DIPSETTING(      0x0000, "No Bonus" )
+	PORT_DIPSETTING(      0x2000, "2 Coin Units for 1 Credit" )
+	PORT_DIPSETTING(      0x4000, "3 Coin Units for 1 Credit" )
+	PORT_DIPSETTING(      0x6000, "4 Coin Units for 1 Credit" )
+	PORT_DIPSETTING(      0x8000, "5 Coin Units for 1 Credit" )
+	PORT_DIPSETTING(      0xa000, "4 Coin Units for 2 Credit" )
+	PORT_DIPSETTING(      0xc000, DEF_STR( Free_Play ) )
+	PORT_DIPSETTING(      0xe000, "No Bonus" )
 
 	PORT_START("AN_STEERING")
 	PORT_BIT( 0x0f, 0x00, IPT_DIAL ) PORT_SENSITIVITY(25) PORT_KEYDELTA(10)
@@ -170,76 +172,82 @@
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_COIN3 )
 
 	PORT_START("PPI_PORTD")
-	/* Wire jumper setting on sound PCB */
-	PORT_DIPNAME( 0xf0, 0x80,  DEF_STR( Unknown ) )
+	/* Wire jumper setting on sound PCB - actually unpopulated 4 switch DS.3 */
+	PORT_DIPNAME( 0xf0, 0x80, "Sound PCB Jumper (DS.3)" )
 	PORT_DIPSETTING(    0x10, "1" )
 	PORT_DIPSETTING(    0x20, "2" )
 	PORT_DIPSETTING(    0x40, "3" )
 	PORT_DIPSETTING(    0x80, "4" )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( tx1a )
+static INPUT_PORTS_START( tx1j )
 	PORT_INCLUDE(tx1)
 
 	PORT_MODIFY("DSW")
-	PORT_DIPNAME( 0x000c, 0x0000, "Game Cost" )
-	PORT_DIPSETTING(      0x0000, "1 Coin Unit for 1 Credit" )
-	PORT_DIPSETTING(      0x0004, "2 Coin Units for 1 Credit" )
-	PORT_DIPSETTING(      0x0008, "3 Coin Units for 1 Credit" )
-	PORT_DIPSETTING(      0x000c, "4 Coin Units for 1 Credit" )
-
-	PORT_DIPNAME( 0x0010, 0x0000, "Left Coin Mechanism" )
-	PORT_DIPSETTING(      0x0000, "1 Coin for 1 Coin Unit" )
-	PORT_DIPSETTING(      0x0010, "1 Coin for 2 Coin Units" )
+	/* Dipswitch DS.2 is 6 switches but "maps" to switches 2 to 8 (at 6P according to the manual)  */
+	PORT_DIPNAME( 0x001c, 0x0000, DEF_STR( Coin_A ) )	PORT_DIPLOCATION("DS.2:1,2,3") /* As silkscreened on the PCB */
+	PORT_DIPSETTING(      0x0008, DEF_STR( 3C_1C ) )
+	PORT_DIPSETTING(      0x0004, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(      0x001c, DEF_STR( 2C_3C ) )
+	PORT_DIPSETTING(      0x000c, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(      0x0010, DEF_STR( 1C_3C ) )
+	PORT_DIPSETTING(      0x0014, DEF_STR( 1C_5C ) )
+	PORT_DIPSETTING(      0x0018, DEF_STR( 1C_6C ) )
 
-	PORT_DIPNAME( 0x0060, 0x0000, "Right Coin Mechanism" )
-	PORT_DIPSETTING(      0x0000, "1 Coin for 1 Coin Unit" )
-	PORT_DIPSETTING(      0x0020, "1 Coin for 4 Coin Units" )
-	PORT_DIPSETTING(      0x0040, "1 Coin for 5 Coin Units" )
-	PORT_DIPSETTING(      0x0060, "1 Coin for 6 Coin Units" )
+	PORT_DIPNAME( 0x00e0, 0x0000, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("DS.2:4,5,6") /* As silkscreened on the PCB */
+	PORT_DIPSETTING(      0x0040, DEF_STR( 3C_1C ) )
+	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(      0x00e0, DEF_STR( 2C_3C ) )
+	PORT_DIPSETTING(      0x0060, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )
+	PORT_DIPSETTING(      0x00a0, DEF_STR( 1C_5C ) )
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_6C ) )
 
-	PORT_DIPNAME( 0xe000, 0xe000, "Bonus Adder" )
-	PORT_DIPSETTING(      0x0000, "No Bonus" )
-	PORT_DIPSETTING(      0x2000, "2 Coin Units for 1 Credit" )
-	PORT_DIPSETTING(      0x4000, "3 Coin Units for 1 Credit" )
-	PORT_DIPSETTING(      0x6000, "4 Coin Units for 1 Credit" )
-	PORT_DIPSETTING(      0x8000, "5 Coin Units for 1 Credit" )
-	PORT_DIPSETTING(      0xa000, "4 Coin Units for 2 Credit" )
-	PORT_DIPSETTING(      0xc000, DEF_STR( Free_Play ) )
-	PORT_DIPSETTING(      0xe000, "No Bonus" )
+	/* Dipswitch DS.1 is 8 switches (at 8P according to the manual) */
+	PORT_DIPNAME( 0xe000, 0x0000, DEF_STR( Unknown ) )	PORT_DIPLOCATION("DS.1:6,7,8")
+	PORT_DIPSETTING(      0x0000, "0" )
+	PORT_DIPSETTING(      0x2000, "1" )
+	PORT_DIPSETTING(      0x4000, "2" )
+	PORT_DIPSETTING(      0x6000, "3" )
+	PORT_DIPSETTING(      0x8000, "4" )
+	PORT_DIPSETTING(      0xa000, "5" )
+	PORT_DIPSETTING(      0xc000, "6" )
+	PORT_DIPSETTING(      0xe000, "7" )
 INPUT_PORTS_END
 
 
 static INPUT_PORTS_START( buggyboy )
 	PORT_START("DSW")
 	/* Dipswitch 0 is unconnected */
-	PORT_DIPNAME( 0x0003, 0x0003, "Do not change 2" )
+	PORT_DIPNAME( 0x0003, 0x0003, "Do not change DSW2 1&2" )	PORT_DIPLOCATION("SW2:1,2") /* Listed in manual as "Do Not Change" */
 	PORT_DIPSETTING(      0x0000, "0" )
 	PORT_DIPSETTING(      0x0001, "1" )
 	PORT_DIPSETTING(      0x0002, "2" )
 	PORT_DIPSETTING(      0x0003, "3" )
 
-	PORT_DIPNAME( 0x0004, 0x0004, "Message" )
+	PORT_DIPNAME( 0x0004, 0x0004, DEF_STR( Language ) )	PORT_DIPLOCATION("SW2:3") /* Language of game instructions */
 	PORT_DIPSETTING(      0x0004, DEF_STR( English ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Japanese ) )
 
-	PORT_DIPNAME( 0x0008, 0x0008, "Do not Change 3" )
+	PORT_DIPNAME( 0x0008, 0x0008, "Do not Change DSW2 4" )	PORT_DIPLOCATION("SW2:4") /* Listed in manual as "Do Not Change" */
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( On ) )
 
-	PORT_DIPNAME( 0x0030, 0x0010, "Time Rank" )
+	PORT_DIPNAME( 0x0030, 0x0010, "Time Rank" )		PORT_DIPLOCATION("SW2:5,6")
 	PORT_DIPSETTING(      0x0000, "A (Longest)" )
 	PORT_DIPSETTING(      0x0010, "B" )
 	PORT_DIPSETTING(      0x0020, "C" )
 	PORT_DIPSETTING(      0x0030, "D (Shortest)" )
 
-	PORT_DIPNAME( 0x00c0, 0x0040, "Game Rank" )
+	PORT_DIPNAME( 0x00c0, 0x0040, "Game Rank" )		PORT_DIPLOCATION("SW2:7,8")
 	PORT_DIPSETTING(      0x0000, "A (Easy)")
 	PORT_DIPSETTING(      0x0040, "B" )
 	PORT_DIPSETTING(      0x0080, "C" )
 	PORT_DIPSETTING(      0x00c0, "D (Difficult)" )
 
-	PORT_DIPNAME( 0xe000, 0x0000, DEF_STR( Coin_A ) )
+	PORT_DIPNAME( 0xe000, 0x0000, DEF_STR( Coin_A ) )	PORT_DIPLOCATION("SW1:8,7,6")
 	PORT_DIPSETTING(      0x4000, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x2000, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_1C ) )
@@ -249,13 +257,13 @@
 	PORT_DIPSETTING(      0xa000, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(      0xe000, "Free-Play" )
 
-	PORT_DIPNAME( 0x1800, 0x0800, DEF_STR( Coin_B ) )
+	PORT_DIPNAME( 0x1800, 0x0800, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SW1:5,4")
 	PORT_DIPSETTING(      0x0800, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(      0x1000, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(      0x1800, DEF_STR( 1C_5C ) )
 
-	PORT_DIPNAME( 0x0700, 0x0700, "Do not change 1" )
+	PORT_DIPNAME( 0x0700, 0x0700, "Do not change DSW1 1-3" )	PORT_DIPLOCATION("SW1:3,2,1") /* Listed in manual as "Do Not Change" */
 	PORT_DIPSETTING(      0x0000, "0" )
 	PORT_DIPSETTING(      0x0100, "1" )
 	PORT_DIPSETTING(      0x0200, "2" )
@@ -297,33 +305,33 @@
 static INPUT_PORTS_START( buggybjr )
 	PORT_START("DSW")
 	/* Dipswitch 0 is unconnected */
-	PORT_DIPNAME( 0x0003, 0x0003, "Do not change 2" )
+	PORT_DIPNAME( 0x0003, 0x0003, "Do not change DSW2 1&2" )	PORT_DIPLOCATION("SW2:1,2") /* Listed in manual as "Do Not Change" */
 	PORT_DIPSETTING(      0x0000, "0" )
 	PORT_DIPSETTING(      0x0001, "1" )
 	PORT_DIPSETTING(      0x0002, "2" )
 	PORT_DIPSETTING(      0x0003, "3" )
 
-	PORT_DIPNAME( 0x0004, 0x0004, "Message" )
+	PORT_DIPNAME( 0x0004, 0x0004, DEF_STR( Language ) )	PORT_DIPLOCATION("SW2:3") /* Language of game instructions */
 	PORT_DIPSETTING(      0x0004, DEF_STR( English ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Japanese ) )
 
-	PORT_DIPNAME( 0x0008, 0x0008, "Do not Change 3" )
+	PORT_DIPNAME( 0x0008, 0x0008, "Do not Change DSW2 4" )	PORT_DIPLOCATION("SW2:4") /* Listed in manual as "Do Not Change" */
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( On ) )
 
-	PORT_DIPNAME( 0x0030, 0x0010, "Time Rank" )
+	PORT_DIPNAME( 0x0030, 0x0010, "Time Rank" )		PORT_DIPLOCATION("SW2:5,6")
 	PORT_DIPSETTING(      0x0000, "A (Longest)" )
 	PORT_DIPSETTING(      0x0010, "B" )
 	PORT_DIPSETTING(      0x0020, "C" )
 	PORT_DIPSETTING(      0x0030, "D (Shortest)" )
 
-	PORT_DIPNAME( 0x00c0, 0x0040, "Game Rank" )
+	PORT_DIPNAME( 0x00c0, 0x0040, "Game Rank" )		PORT_DIPLOCATION("SW2:7,8")
 	PORT_DIPSETTING(      0x0000, "A (Easy)")
 	PORT_DIPSETTING(      0x0040, "B" )
 	PORT_DIPSETTING(      0x0080, "C" )
 	PORT_DIPSETTING(      0x00c0, "D (Difficult)" )
 
-	PORT_DIPNAME( 0xe000, 0x0000, DEF_STR( Coin_A ) )
+	PORT_DIPNAME( 0xe000, 0x0000, DEF_STR( Coin_A ) )	PORT_DIPLOCATION("SW1:8,7,6")
 	PORT_DIPSETTING(      0x4000, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x2000, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_1C ) )
@@ -333,13 +341,13 @@
 	PORT_DIPSETTING(      0xa000, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(      0xe000, "Free-Play" )
 
-	PORT_DIPNAME( 0x1800, 0x0800, DEF_STR( Coin_B ) )
+	PORT_DIPNAME( 0x1800, 0x0800, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SW1:5,4")
 	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x1000, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(      0x0800, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(      0x1800, DEF_STR( 1C_6C ) )
 
-	PORT_DIPNAME( 0x0700, 0x0700, "Do not change 1" )
+	PORT_DIPNAME( 0x0700, 0x0700, "Do not change DSW1 1-3" )	PORT_DIPLOCATION("SW1:3,2,1") /* Listed in manual as "Do Not Change" */
 	PORT_DIPSETTING(      0x0000, "0" )
 	PORT_DIPSETTING(      0x0100, "1" )
 	PORT_DIPSETTING(      0x0200, "2" )
@@ -467,21 +475,21 @@
 /* Buggy Boy uses an 8255 PPI instead of YM2149 ports for inputs! */
 static I8255A_INTERFACE( buggyboy_ppi8255_intf )
 {
-	DEVCB_INPUT_PORT("PPI_PORTA"),		/* Port A read */
-	DEVCB_NULL,							/* Port A write */
-	DEVCB_NULL,							/* Port B read */
+	DEVCB_INPUT_PORT("PPI_PORTA"),						/* Port A read */
+	DEVCB_NULL,											/* Port A write */
+	DEVCB_NULL,											/* Port B read */
 	DEVCB_DRIVER_MEMBER(tx1_state,bb_coin_cnt_w),		/* Port B write */
-	DEVCB_INPUT_PORT("PPI_PORTC"),		/* Port C read */
-	DEVCB_NULL							/* Port C write */
+	DEVCB_INPUT_PORT("PPI_PORTC"),						/* Port C read */
+	DEVCB_NULL											/* Port C write */
 };
 
 static I8255A_INTERFACE( tx1_ppi8255_intf )
 {
 	DEVCB_DRIVER_MEMBER(tx1_state,tx1_ppi_porta_r),		/* Port A read */
-	DEVCB_NULL,							/* Port A write */
+	DEVCB_NULL,											/* Port A write */
 	DEVCB_DRIVER_MEMBER(tx1_state,tx1_ppi_portb_r),		/* Port B read */
-	DEVCB_NULL,							/* Port B write */
-	DEVCB_INPUT_PORT("PPI_PORTC"),		/* Port C read */
+	DEVCB_NULL,											/* Port B write */
+	DEVCB_INPUT_PORT("PPI_PORTC"),						/* Port C read */
 	DEVCB_DRIVER_MEMBER(tx1_state,tx1_coin_cnt_w)		/* Port C write */
 };
 
@@ -505,7 +513,7 @@
 	AM_RANGE(0x0e000, 0x0e001) AM_WRITE(tx1_slock_w)
 	AM_RANGE(0x0f000, 0x0f001) AM_READ(watchdog_reset16_r) AM_WRITE(resume_math_w)
 	AM_RANGE(0x10000, 0x1ffff) AM_READWRITE(z80_shared_r, z80_shared_w)
-	AM_RANGE(0xf0000, 0xfffff) AM_ROM
+	AM_RANGE(0x20000, 0x2ffff) AM_MIRROR(0xd0000) AM_ROM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( tx1_math, AS_PROGRAM, 16, tx1_state )
@@ -518,9 +526,7 @@
 	AM_RANGE(0x02C00, 0x02fff) AM_WRITE(tx1_flgcs_w)
 	AM_RANGE(0x03000, 0x03fff) AM_READWRITE(tx1_math_r, tx1_math_w)
 	AM_RANGE(0x05000, 0x07fff) AM_READ(tx1_spcs_rom_r)
-	AM_RANGE(0x08000, 0x0bfff) AM_ROM
-	AM_RANGE(0x0c000, 0x0ffff) AM_ROM
-	AM_RANGE(0xfc000, 0xfffff) AM_ROM
+	AM_RANGE(0x04000, 0x07fff) AM_MIRROR(0xf8000) AM_ROM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( tx1_sound_prg, AS_PROGRAM, 8, tx1_state )
@@ -582,11 +588,8 @@
 	AM_RANGE(0x02000, 0x022ff) AM_RAM AM_SHARE("objram")
 	AM_RANGE(0x02400, 0x024ff) AM_WRITE(buggyboy_gas_w)
 	AM_RANGE(0x03000, 0x03fff) AM_READWRITE(buggyboy_math_r, buggyboy_math_w)
-	AM_RANGE(0x04000, 0x04fff) AM_ROM
 	AM_RANGE(0x05000, 0x07fff) AM_READ(buggyboy_spcs_rom_r)
-	AM_RANGE(0x08000, 0x0bfff) AM_ROM
-	AM_RANGE(0x0c000, 0x0ffff) AM_ROM
-	AM_RANGE(0xfc000, 0xfffff) AM_ROM
+	AM_RANGE(0x04000, 0x07fff) AM_MIRROR(0xf8000) AM_ROM
 ADDRESS_MAP_END
 
 /* Buggy Boy Sound PCB TC033A */
@@ -726,7 +729,8 @@
 	MCFG_VIDEO_START(tx1)
 
 	MCFG_SPEAKER_STANDARD_STEREO("frontleft", "frontright")
-//  MCFG_SPEAKER_STANDARD_STEREO("rearleft", "rearright")
+//  MCFG_SPEAKER_STANDARD_STEREO("rearleft", "rearright") /* Atari TX-1 TM262 manual shows 4 speakers (TX-1 Audio PCB Assembly A042016-01 A) */
+
 
 	MCFG_SOUND_ADD("aysnd", AY8910, TX1_PIXEL_CLOCK / 8)
 	MCFG_SOUND_CONFIG(tx1_ay8910_interface)
@@ -841,33 +845,121 @@
  *
  *************************************/
 
+/*
+    The TX-1 (Multi License (World)) game is comprised of three boards:
+    - Sound Board (labeled TC013B, top small board, different then the below mentioned TC013A)
+    - CPU Board   (labeled TC011A, middle board, uses 15.000 MHz xtal)
+    - Video Board (labeled TC012A, bottom board, uses 18.000 MHz xtal)
+*/
 ROM_START( tx1 )
 	ROM_REGION( 0x100000, "main_cpu", 0 )
-	ROM_LOAD16_BYTE( "tx1_1c.ic22", 0xf0000, 0x4000, CRC(eedcee83) SHA1(7fa0590b142fb13c6562126a9bdd5a1e032880c7) )
-	ROM_LOAD16_BYTE( "tx1_2c.ic29", 0xf0001, 0x4000, CRC(294bf5bf) SHA1(02b425caba8a187c58211bab27988205eb044558) )
-	ROM_LOAD16_BYTE( "tx1_4c.ic54", 0xf8001, 0x4000, CRC(15bb8ef2) SHA1(83968f010ec555fcd0548a80562fb23a892b5afb) )
-	ROM_LOAD16_BYTE( "tx1_3c.ic45", 0xf8000, 0x4000, CRC(21a8aa55) SHA1(21bc4adefb22a95fcd7a4e305bf0b05e2cb34129) )
+	ROM_LOAD16_BYTE( "8412-136027-244.22", 0x20000, 0x4000, CRC(2e9cefa2) SHA1(4ca04eae446e8df08ab793488a79217ed1a27875) )
+	ROM_LOAD16_BYTE( "8412-136027-245.29", 0x20001, 0x4000, CRC(ade7895c) SHA1(1c33a574cae46fddb4cadb85f5de17f02ae7a596) )
+
+	ROM_LOAD16_BYTE( "8412-136027-249.45", 0x28000, 0x4000, CRC(9bcb82db) SHA1(d1528c9b9c4c2848bdba15e4632927476d544f40) )
+	ROM_LOAD16_BYTE( "8412-136027-250.54", 0x28001, 0x4000, CRC(c8c9368f) SHA1(0972d54d506216eb2b204cf22ccdff9210fb7b10) )
 
 	ROM_REGION( 0x100000, "math_cpu", 0 )
-	ROM_LOAD16_BYTE( "tx1_9c.ic146", 0xfc000, 0x2000, CRC(b65eeea2) SHA1(b5f26e17520c598132b93c5cd7af7ebd03b10012) )
-	ROM_RELOAD(                  0x4000, 0x2000 )
-	ROM_RELOAD(                  0x8000, 0x2000 )
-	ROM_RELOAD(                  0xc000, 0x2000 )
-	ROM_LOAD16_BYTE( "tx1_8c.ic132", 0xfc001, 0x2000, CRC(0d63dadc) SHA1(0954174b25c08967d3efb31f5721fd05502d66dd) )
-	ROM_RELOAD(                  0x4001, 0x2000 )
-	ROM_RELOAD(                  0x8001, 0x2000 )
-	ROM_RELOAD(                  0xc001, 0x2000 )
+	ROM_LOAD16_BYTE( "8411-136027-152.146", 0x04000, 0x2000, CRC(b65eeea2) SHA1(b5f26e17520c598132b93c5cd7af7ebd03b10012) )
+	ROM_LOAD16_BYTE( "8411-136027-151.132", 0x04001, 0x2000, CRC(0d63dadc) SHA1(0954174b25c08967d3efb31f5721fd05502d66dd) )
 
 	ROM_REGION( 0x10000, "audio_cpu", 0 )
 	ROM_LOAD( "8411-136027-157.11", 0x00000, 0x2000, CRC(10ae3075) SHA1(69c5f62f2473aba848383eed3cecf15e273d86ca) )
 
 	ROM_REGION( 0x20000, "char_tiles", 0 )
+	ROM_LOAD( "8411-136027-156.204", 0x0000, 0x4000, CRC(60f3c616) SHA1(59c4361891e4274e27e6279c919e8fd6803af7cf) )
+	ROM_LOAD( "8411-136027-155.174", 0x4000, 0x4000, CRC(e59a6b72) SHA1(c10efa77ab421ac60b97227a8d547f50f8415670) )
+
+	ROM_REGION( 0x40000, "obj_tiles", 0 )
+	ROM_LOAD( "8411-136027-114.203", 0x0000, 0x4000, CRC(fc91328b) SHA1(e57fd2056b65d37cf2e1f0af56616c6555df3006) )
+	ROM_LOAD( "8411-136027-116.258", 0x4000, 0x4000, CRC(5745f671) SHA1(6e471633cd6de9926b3361a84430c088e1f6a097) )
+	ROM_LOAD( "8411-136027-115.173", 0x8000, 0x4000, CRC(720e5873) SHA1(151d9063c35b26f5876cf94bdf0c2665ec701bbd) )
+	ROM_LOAD( "8411-136027-117.232", 0xc000, 0x4000, CRC(3c68d0bc) SHA1(2dbaf2a268b90214fd61c016ac945d4371057826) )
+
+	ROM_REGION( 0x40000, "gfx3", 0 )
+	ROM_LOAD( "8411-136027-146.56", 0x0000, 0x2000, CRC(5635b8c1) SHA1(5cc9437a2ff0843f1917f2451852d4561c240b24) )
+	ROM_LOAD( "8411-136027-147.66", 0x2000, 0x2000, CRC(03d83cf8) SHA1(5c0cfc6bf02ad2b3f37e1ceb493f69eb9829ab1e) )
+	ROM_LOAD( "8411-136027-148.76", 0x4000, 0x2000, CRC(ad56013a) SHA1(ae3a91f58f30daff334754476db33ad1d12569fc) )
+
+	ROM_REGION( 0x10000, "au_data", ROMREGION_LE )
+	ROM_LOAD16_BYTE( "8411-136027-153.184", 0x0000, 0x4000, CRC(acf754e8) SHA1(06779e18636f0799efdaa09396e9ccd59f426257) )
+	ROM_LOAD16_BYTE( "8411-136027-154.185", 0x0001, 0x4000, CRC(f89d3e20) SHA1(4b4cf679b7e3d63cded9989d2b667941f718ff57) )
+	ROM_LOAD16_BYTE( "136027-143.ic223",    0x8000, 0x0200, CRC(22c77af6) SHA1(1be8585b95316b4fc5712cdaef699e676320cd4d) )
+	ROM_LOAD16_BYTE( "136027-142.ic213",    0x8001, 0x0200, CRC(f6b8b70b) SHA1(b79374acf11d71db1e4ad3c494ac5f500a52677b) )
+
+	ROM_REGION( 0x50000, "obj_map", 0 )
+	ROM_LOAD( "8411-136027-119.106", 0x0000, 0x4000, CRC(88eec0fb) SHA1(81d7a69dc1a4b3b81d7f28d97a3f80697cdcc6eb) )
+	ROM_LOAD( "8411-136027-120.73",  0x4000, 0x4000, CRC(407cbe65) SHA1(e1c11b65f3c6abde6d55afeaffdb39cdd6d66377) )
+
+	ROM_REGION( 0x50000, "user3", 0 )
+	ROM_LOAD( "8411-136027-113.48",  0x0000, 0x2000, CRC(4b3d7956) SHA1(fc2432dd69f3be7007d4fd6f7c86c7c19453b1ba) )
+	ROM_LOAD( "8411-136027-118.281", 0x2000, 0x4000, CRC(de418dc7) SHA1(1233e2f7499ec5a73a40ee336d3fe26c06187784) )
+
+	ROM_REGION( 0x10000, "proms", 0 )
+	/* RGB palette (left) */
+	ROM_LOAD( "136027-133.57", 0x0000, 0x100, CRC(3b387d01) SHA1(1229548e3052ad34eeee9598743091d19f6b8f88) )
+	ROM_LOAD( "136027-134.58", 0x0100, 0x100, CRC(f6f4d7d9) SHA1(866024b76b26d6942bd4e1d2494686299414f6be) )
+	ROM_LOAD( "136027-135.59", 0x0200, 0x100, CRC(824e7532) SHA1(917ce74d2bae6af90f2c4e41d12a69f884320915) )
+
+	/* RGB palette (center) */
+	ROM_LOAD( "136027-133.36", 0x0300, 0x100, CRC(3b387d01) SHA1(1229548e3052ad34eeee9598743091d19f6b8f88) )
+	ROM_LOAD( "136027-134.37", 0x0400, 0x100, CRC(f6f4d7d9) SHA1(866024b76b26d6942bd4e1d2494686299414f6be) )
+	ROM_LOAD( "136027-135.38", 0x0500, 0x100, CRC(824e7532) SHA1(917ce74d2bae6af90f2c4e41d12a69f884320915) )
+
+	/* RGB palette (right) */
+	ROM_LOAD( "136027-133.8",  0x0600, 0x100, CRC(3b387d01) SHA1(1229548e3052ad34eeee9598743091d19f6b8f88) )
+	ROM_LOAD( "136027-134.9",  0x0700, 0x100, CRC(f6f4d7d9) SHA1(866024b76b26d6942bd4e1d2494686299414f6be) )
+	ROM_LOAD( "136027-135.10", 0x0800, 0x100, CRC(824e7532) SHA1(917ce74d2bae6af90f2c4e41d12a69f884320915) )
+
+	/* Character colour tables (L, C, R) */
+	ROM_LOAD( "136027-124.85",  0x0900, 0x100, CRC(5aeef5cc) SHA1(e123bf01d556178b0cf9d495bcce445f3f8421cd) )
+	ROM_LOAD( "136027-124.116", 0x0a00, 0x100, CRC(5aeef5cc) SHA1(e123bf01d556178b0cf9d495bcce445f3f8421cd) )
+	ROM_LOAD( "136027-124.148", 0x0b00, 0x100, CRC(5aeef5cc) SHA1(e123bf01d556178b0cf9d495bcce445f3f8421cd) )
+
+	/* Object colour table */
+	ROM_LOAD( "136027-136.276", 0x0c00, 0x200, CRC(7b675b8b) SHA1(3a7617d8ca29aa5d9832e317736598646a466b8b) )
+	ROM_LOAD( "136027-136.277", 0x0e00, 0x200, CRC(7b675b8b) SHA1(3a7617d8ca29aa5d9832e317736598646a466b8b) )
+
+	/* Object tile lookup */
+	ROM_LOAD( "136027-123.25", 0x1000, 0x100, CRC(616a7a85) SHA1(b7c1060ecb128154092441212de64dc304aa3fcd) )
+
+	/* Road graphics */
+	ROM_LOAD( "136027-138.ic33", 0x1100, 0x200, CRC(fafb6917) SHA1(30eb182c7623026dce7dba9e249bc8a9eb7a7f3e) )
+	ROM_LOAD( "136027-139.ic40", 0x1300, 0x200, CRC(93deb894) SHA1(5ae9a21298c836fe649a52f3df2b4067f9012b91) )
+	ROM_LOAD( "136027-140.ic49", 0x1500, 0x200, CRC(aa5ed232) SHA1(f33e7bc2dd33ac6d75fb06b93c4dd58e5d10010d) )
+
+	/* Road stripes */
+	ROM_LOAD( "136027-141.ic50", 0x1700, 0x200, CRC(6b424cea) SHA1(83127326c20116b0a4be1126e163f9c6755e19dc) )
+ROM_END
+
+/*
+    The TX-1 (Japan Rev B) game is comprised of three boards:
+    - Sound Board (labeled TC013A, top small board)
+    - CPU Board   (labeled TC011A, middle board, uses 15.000 MHz xtal)
+    - Video Board (labeled TC012A, bottom board, uses 18.000 MHz xtal)
+*/
+ROM_START( tx1jb )
+	ROM_REGION( 0x100000, "main_cpu", 0 )
+	ROM_LOAD16_BYTE( "tx1_1b.ic22", 0x20000, 0x4000, CRC(3dadb8fb) SHA1(ef99897161d559180abc7f4ce23e8f55fe3bb330) )
+	ROM_LOAD16_BYTE( "tx1_2b.ic29", 0x20001, 0x4000, CRC(6b5a8f23) SHA1(0d82fdcadc29d9a1d7ae9b87dd1f94bd508da4b2) )
+
+	ROM_LOAD16_BYTE( "tx1_3b.ic45", 0x28000, 0x4000, CRC(3a030996) SHA1(7dbbad310380247159c12e5c100ce57193d16e90) )
+	ROM_LOAD16_BYTE( "tx1_4b.ic54", 0x28001, 0x4000, CRC(7aed82ed) SHA1(592d554d02a4b3806154dc008177de83a411ffc6) )
+
+	ROM_REGION( 0x100000, "math_cpu", 0 )
+	ROM_LOAD16_BYTE( "tx1_9b.ic146", 0x04000, 0x2000, CRC(af677ff4) SHA1(3968d7f3811ed7552efe1e1c5c416ec740503ee4) )
+	ROM_LOAD16_BYTE( "tx1_8b.ic132", 0x04001, 0x2000, CRC(dd4356f8) SHA1(b666d2aa93e61f6bcdb8326b8b06635be743b64e) )
+
+	ROM_REGION( 0x10000, "audio_cpu", 0 )
+	ROM_LOAD( "tx1_22h.ic9", 0x00000, 0x2000, CRC(66376232) SHA1(b8a026dae47173e7760eea4f52e67e525ad1b70b) )
+
+	ROM_REGION( 0x20000, "char_tiles", 0 )
 	ROM_LOAD( "tx1_21a.ic204", 0x0000, 0x4000, CRC(cd3441ad) SHA1(8e6597b3177b8aaa34ed3373d85fc4b6231e1333) )
 	ROM_LOAD( "tx1_20a.ic174", 0x4000, 0x4000, CRC(dbe595fc) SHA1(1ed2f775f0a1b46a2ffbc056eb4ef732ed546d3c) )
 
 	ROM_REGION( 0x40000, "obj_tiles", 0 )
 	ROM_LOAD( "tx1_16b.ic203", 0x0000, 0x4000, CRC(1141c965) SHA1(4b90c1428bcbd72d0449c064856a5596269b3fc6) )
-	ROM_LOAD( "tx1_18b.ic258", 0x4000, 0x4000, NO_DUMP )
+	ROM_LOAD( "tx1_18b.ic258", 0x4000, 0x4000, CRC(0ad36d68) SHA1(fd5a65c56557c1bc9c0f3916f15f62500b52bfe0) )
 	ROM_LOAD( "tx1_15b.ic173", 0x8000, 0x4000, CRC(30d1a8d5) SHA1(b4c585b7b8a8920bb3949d643e9e10c17d4009a0) )
 	ROM_LOAD( "tx1_17b.ic232", 0xc000, 0x4000, CRC(364bb354) SHA1(a26581ca1088b979285471e2c6595048df84d75e) )
 
@@ -888,7 +980,7 @@
 
 	ROM_REGION( 0x50000, "user3", 0 )
 	ROM_LOAD( "tx1_12b.ic48",  0x0000, 0x2000, CRC(4b3d7956) SHA1(fc2432dd69f3be7007d4fd6f7c86c7c19453b1ba) )
-	ROM_LOAD( "tx1_19b.ic281", 0x2000, 0x4000, NO_DUMP )
+	ROM_LOAD( "tx1_19b.ic281", 0x2000, 0x4000, CRC(cb250de6) SHA1(4bf3006986fb8cbb3dd4fa988e6471633614e4bb) )
 
 	ROM_REGION( 0x10000, "proms", 0 )
 	/* RGB palette (left) */
@@ -927,83 +1019,77 @@
 	ROM_LOAD( "xb12.ic50",  0x1700, 0x200, CRC(6b424cea) SHA1(83127326c20116b0a4be1126e163f9c6755e19dc) )
 ROM_END
 
-/* Some PROMs haven't been confirmed to be the same as the Tatsumi set (but are very likely identical) */
-ROM_START( tx1a )
+ROM_START( tx1jc )
 	ROM_REGION( 0x100000, "main_cpu", 0 )
-	ROM_LOAD16_BYTE( "8412-136027-244.22", 0xf0000, 0x4000, CRC(2e9cefa2) SHA1(4ca04eae446e8df08ab793488a79217ed1a27875) )
-	ROM_LOAD16_BYTE( "8412-136027-245.29", 0xf0001, 0x4000, CRC(ade7895c) SHA1(1c33a574cae46fddb4cadb85f5de17f02ae7a596) )
-	ROM_LOAD16_BYTE( "8412-136027-250.54", 0xf8001, 0x4000, CRC(c8c9368f) SHA1(0972d54d506216eb2b204cf22ccdff9210fb7b10) )
-	ROM_LOAD16_BYTE( "8412-136027-249.45", 0xf8000, 0x4000, CRC(9bcb82db) SHA1(d1528c9b9c4c2848bdba15e4632927476d544f40))
+	ROM_LOAD16_BYTE( "tx1_1c.ic22", 0x20000, 0x4000, CRC(eedcee83) SHA1(7fa0590b142fb13c6562126a9bdd5a1e032880c7) )
+	ROM_LOAD16_BYTE( "tx1_2c.ic29", 0x20001, 0x4000, CRC(294bf5bf) SHA1(02b425caba8a187c58211bab27988205eb044558) )
+
+	ROM_LOAD16_BYTE( "tx1_3c.ic45", 0x28000, 0x4000, CRC(21a8aa55) SHA1(21bc4adefb22a95fcd7a4e305bf0b05e2cb34129) )
+	ROM_LOAD16_BYTE( "tx1_4c.ic54", 0x28001, 0x4000, CRC(15bb8ef2) SHA1(83968f010ec555fcd0548a80562fb23a892b5afb) )
 
 	ROM_REGION( 0x100000, "math_cpu", 0 )
-	ROM_LOAD16_BYTE( "8411-136027-152.146", 0xfc000, 0x2000, CRC(b65eeea2) SHA1(b5f26e17520c598132b93c5cd7af7ebd03b10012) )
-	ROM_RELOAD(                  0x4000, 0x2000 )
-	ROM_RELOAD(                  0x8000, 0x2000 )
-	ROM_RELOAD(                  0xc000, 0x2000 )
-	ROM_LOAD16_BYTE( "8411-136027-151.132", 0xfc001, 0x2000, CRC(0d63dadc) SHA1(0954174b25c08967d3efb31f5721fd05502d66dd) )
-	ROM_RELOAD(                  0x4001, 0x2000 )
-	ROM_RELOAD(                  0x8001, 0x2000 )
-	ROM_RELOAD(                  0xc001, 0x2000 )
+	ROM_LOAD16_BYTE( "tx1_9c.ic146", 0x04000, 0x2000, CRC(b65eeea2) SHA1(b5f26e17520c598132b93c5cd7af7ebd03b10012) )
+	ROM_LOAD16_BYTE( "tx1_8c.ic132", 0x04001, 0x2000, CRC(0d63dadc) SHA1(0954174b25c08967d3efb31f5721fd05502d66dd) )
 
-	ROM_REGION( 0x10000, "audio_cpu", 0 )
-	ROM_LOAD( "8411-136027-157.11", 0x00000, 0x2000, CRC(10ae3075) SHA1(69c5f62f2473aba848383eed3cecf15e273d86ca) )
+	ROM_REGION( 0x10000, "audio_cpu", 0 ) /* Label was missing */
+	ROM_LOAD( "8411-136027-157.11", 0x00000, 0x2000, CRC(10ae3075) SHA1(69c5f62f2473aba848383eed3cecf15e273d86ca) ) /* Unconfirmed TC013A or the later TC013B */
 
 	ROM_REGION( 0x20000, "char_tiles", 0 )
-	ROM_LOAD( "8411-136027-156.204", 0x0000, 0x4000, CRC(60f3c616) SHA1(59c4361891e4274e27e6279c919e8fd6803af7cf) )
-	ROM_LOAD( "8411-136027-155.174", 0x4000, 0x4000, CRC(e59a6b72) SHA1(c10efa77ab421ac60b97227a8d547f50f8415670) )
+	ROM_LOAD( "tx1_21a.ic204", 0x0000, 0x4000, CRC(cd3441ad) SHA1(8e6597b3177b8aaa34ed3373d85fc4b6231e1333) )
+	ROM_LOAD( "tx1_20a.ic174", 0x4000, 0x4000, CRC(dbe595fc) SHA1(1ed2f775f0a1b46a2ffbc056eb4ef732ed546d3c) )
 
 	ROM_REGION( 0x40000, "obj_tiles", 0 )
-	ROM_LOAD( "8411-136027-114.203", 0x0000, 0x4000, CRC(fc91328b) SHA1(e57fd2056b65d37cf2e1f0af56616c6555df3006) )
-	ROM_LOAD( "8411-136027-116.258", 0x4000, 0x4000, CRC(5745f671) SHA1(6e471633cd6de9926b3361a84430c088e1f6a097) )
-	ROM_LOAD( "8411-136027-115.173", 0x8000, 0x4000, CRC(720e5873) SHA1(151d9063c35b26f5876cf94bdf0c2665ec701bbd) )
-	ROM_LOAD( "8411-136027-117.232", 0xc000, 0x4000, CRC(3c68d0bc) SHA1(2dbaf2a268b90214fd61c016ac945d4371057826) )
+	ROM_LOAD( "tx1_16b.ic203", 0x0000, 0x4000, CRC(1141c965) SHA1(4b90c1428bcbd72d0449c064856a5596269b3fc6) )
+	ROM_LOAD( "tx1_18b.ic258", 0x4000, 0x4000, CRC(0ad36d68) SHA1(fd5a65c56557c1bc9c0f3916f15f62500b52bfe0) )
+	ROM_LOAD( "tx1_15b.ic173", 0x8000, 0x4000, CRC(30d1a8d5) SHA1(b4c585b7b8a8920bb3949d643e9e10c17d4009a0) )
+	ROM_LOAD( "tx1_17b.ic232", 0xc000, 0x4000, CRC(364bb354) SHA1(a26581ca1088b979285471e2c6595048df84d75e) )
 
 	ROM_REGION( 0x40000, "gfx3", 0 )
-	ROM_LOAD( "8411-136027-146.56", 0x0000, 0x2000, CRC(5635b8c1) SHA1(5cc9437a2ff0843f1917f2451852d4561c240b24) )
-	ROM_LOAD( "8411-136027-147.66", 0x2000, 0x2000, CRC(03d83cf8) SHA1(5c0cfc6bf02ad2b3f37e1ceb493f69eb9829ab1e) )
-	ROM_LOAD( "8411-136027-148.76", 0x4000, 0x2000, CRC(ad56013a) SHA1(ae3a91f58f30daff334754476db33ad1d12569fc) )
+	ROM_LOAD( "tx1_5a.ic56", 0x0000, 0x2000, CRC(5635b8c1) SHA1(5cc9437a2ff0843f1917f2451852d4561c240b24) )
+	ROM_LOAD( "tx1_6a.ic66", 0x2000, 0x2000, CRC(03d83cf8) SHA1(5c0cfc6bf02ad2b3f37e1ceb493f69eb9829ab1e) )
+	ROM_LOAD( "tx1_7a.ic76", 0x4000, 0x2000, CRC(ad56013a) SHA1(ae3a91f58f30daff334754476db33ad1d12569fc) )
 
 	ROM_REGION( 0x10000, "au_data", ROMREGION_LE )
-	ROM_LOAD16_BYTE( "8411-136027-153.184", 0x0000, 0x4000, CRC(acf754e8) SHA1(06779e18636f0799efdaa09396e9ccd59f426257) )
-	ROM_LOAD16_BYTE( "8411-136027-154.185", 0x0001, 0x4000, CRC(f89d3e20) SHA1(4b4cf679b7e3d63cded9989d2b667941f718ff57) )
-	ROM_LOAD16_BYTE( "xb02b.ic223",         0x8000, 0x0200, CRC(22c77af6) SHA1(1be8585b95316b4fc5712cdaef699e676320cd4d) )
-	ROM_LOAD16_BYTE( "xb01b.ic213",         0x8001, 0x0200, CRC(f6b8b70b) SHA1(b79374acf11d71db1e4ad3c494ac5f500a52677b) )
+	ROM_LOAD16_BYTE( "tx1_10b.ic184", 0x0000, 0x4000, CRC(acf754e8) SHA1(06779e18636f0799efdaa09396e9ccd59f426257) )
+	ROM_LOAD16_BYTE( "tx1_11b.ic185", 0x0001, 0x4000, CRC(f89d3e20) SHA1(4b4cf679b7e3d63cded9989d2b667941f718ff57) )
+	ROM_LOAD16_BYTE( "xb02b.ic223",   0x8000, 0x0200, CRC(22c77af6) SHA1(1be8585b95316b4fc5712cdaef699e676320cd4d) )
+	ROM_LOAD16_BYTE( "xb01b.ic213",   0x8001, 0x0200, CRC(f6b8b70b) SHA1(b79374acf11d71db1e4ad3c494ac5f500a52677b) )
 
 	ROM_REGION( 0x50000, "obj_map", 0 )
-	ROM_LOAD( "8411-136027-119.106", 0x0000, 0x4000, CRC(88eec0fb) SHA1(81d7a69dc1a4b3b81d7f28d97a3f80697cdcc6eb) )
-	ROM_LOAD( "8411-136027-120.73",  0x4000, 0x4000, CRC(407cbe65) SHA1(e1c11b65f3c6abde6d55afeaffdb39cdd6d66377) )
+	ROM_LOAD( "tx1_14b.ic106", 0x0000, 0x4000, CRC(68c63d6e) SHA1(110e02b99c44d31041be588bd14642e26890ecbd) )
+	ROM_LOAD( "tx1_13b.ic73",  0x4000, 0x4000, CRC(b0c581b2) SHA1(20926bc15e7c97045b219b828acfcdd99b8712a6) )
 
 	ROM_REGION( 0x50000, "user3", 0 )
-	ROM_LOAD( "8411-136027-113.48",  0x0000, 0x2000, CRC(4b3d7956) SHA1(fc2432dd69f3be7007d4fd6f7c86c7c19453b1ba) )
-	ROM_LOAD( "8411-136027-118.281", 0x2000, 0x4000, CRC(de418dc7) SHA1(1233e2f7499ec5a73a40ee336d3fe26c06187784) )
+	ROM_LOAD( "tx1_12b.ic48",  0x0000, 0x2000, CRC(4b3d7956) SHA1(fc2432dd69f3be7007d4fd6f7c86c7c19453b1ba) )
+	ROM_LOAD( "tx1_19b.ic281", 0x2000, 0x4000, CRC(cb250de6) SHA1(4bf3006986fb8cbb3dd4fa988e6471633614e4bb) )
 
 	ROM_REGION( 0x10000, "proms", 0 )
 	/* RGB palette (left) */
-	ROM_LOAD( "136027-133.57", 0x0000, 0x100, CRC(3b387d01) SHA1(1229548e3052ad34eeee9598743091d19f6b8f88) )
-	ROM_LOAD( "136027-134.58", 0x0100, 0x100, CRC(f6f4d7d9) SHA1(866024b76b26d6942bd4e1d2494686299414f6be) )
-	ROM_LOAD( "136027-135.59", 0x0200, 0x100, CRC(824e7532) SHA1(917ce74d2bae6af90f2c4e41d12a69f884320915) )
+	ROM_LOAD( "xb05a.ic57", 0x0000, 0x100, CRC(3b387d01) SHA1(1229548e3052ad34eeee9598743091d19f6b8f88) )
+	ROM_LOAD( "xb06a.ic58", 0x0100, 0x100, CRC(f6f4d7d9) SHA1(866024b76b26d6942bd4e1d2494686299414f6be) )
+	ROM_LOAD( "xb07a.ic59", 0x0200, 0x100, CRC(824e7532) SHA1(917ce74d2bae6af90f2c4e41d12a69f884320915) )
 
 	/* RGB palette (center) */
-	ROM_LOAD( "136027-133.36", 0x0300, 0x100, CRC(3b387d01) SHA1(1229548e3052ad34eeee9598743091d19f6b8f88) )
-	ROM_LOAD( "136027-134.37", 0x0400, 0x100, CRC(f6f4d7d9) SHA1(866024b76b26d6942bd4e1d2494686299414f6be) )
-	ROM_LOAD( "136027-135.38", 0x0500, 0x100, CRC(824e7532) SHA1(917ce74d2bae6af90f2c4e41d12a69f884320915) )
+	ROM_LOAD( "xb05a.ic36", 0x0300, 0x100, CRC(3b387d01) SHA1(1229548e3052ad34eeee9598743091d19f6b8f88) )
+	ROM_LOAD( "xb06a.ic37", 0x0400, 0x100, CRC(f6f4d7d9) SHA1(866024b76b26d6942bd4e1d2494686299414f6be) )
+	ROM_LOAD( "xb07a.ic38", 0x0500, 0x100, CRC(824e7532) SHA1(917ce74d2bae6af90f2c4e41d12a69f884320915) )
 
 	/* RGB palette (right) */
-	ROM_LOAD( "136027-133.8",  0x0600, 0x100, CRC(3b387d01) SHA1(1229548e3052ad34eeee9598743091d19f6b8f88) )
-	ROM_LOAD( "136027-134.9",  0x0700, 0x100, CRC(f6f4d7d9) SHA1(866024b76b26d6942bd4e1d2494686299414f6be) )
-	ROM_LOAD( "136027-135.10", 0x0800, 0x100, CRC(824e7532) SHA1(917ce74d2bae6af90f2c4e41d12a69f884320915) )
+	ROM_LOAD( "xb05a.ic8",  0x0600, 0x100, CRC(3b387d01) SHA1(1229548e3052ad34eeee9598743091d19f6b8f88) )
+	ROM_LOAD( "xb06a.ic9",  0x0700, 0x100, CRC(f6f4d7d9) SHA1(866024b76b26d6942bd4e1d2494686299414f6be) )
+	ROM_LOAD( "xb07a.ic10", 0x0800, 0x100, CRC(824e7532) SHA1(917ce74d2bae6af90f2c4e41d12a69f884320915) )
 
 	/* Character colour tables (L, C, R) */
-	ROM_LOAD( "136027-124.85",  0x0900, 0x100, CRC(5aeef5cc) SHA1(e123bf01d556178b0cf9d495bcce445f3f8421cd) )
-	ROM_LOAD( "136027-124.116", 0x0a00, 0x100, CRC(5aeef5cc) SHA1(e123bf01d556178b0cf9d495bcce445f3f8421cd) )
-	ROM_LOAD( "136027-124.148", 0x0b00, 0x100, CRC(5aeef5cc) SHA1(e123bf01d556178b0cf9d495bcce445f3f8421cd) )
+	ROM_LOAD( "xb08.ic85",  0x0900, 0x100, CRC(5aeef5cc) SHA1(e123bf01d556178b0cf9d495bcce445f3f8421cd) )
+	ROM_LOAD( "xb08.ic116", 0x0a00, 0x100, CRC(5aeef5cc) SHA1(e123bf01d556178b0cf9d495bcce445f3f8421cd) )
+	ROM_LOAD( "xb08.ic148", 0x0b00, 0x100, CRC(5aeef5cc) SHA1(e123bf01d556178b0cf9d495bcce445f3f8421cd) )
 
 	/* Object colour table */
-	ROM_LOAD( "136027-136.276", 0x0c00, 0x200, CRC(7b675b8b) SHA1(3a7617d8ca29aa5d9832e317736598646a466b8b) )
-	ROM_LOAD( "136027-136.277", 0x0e00, 0x200, CRC(7b675b8b) SHA1(3a7617d8ca29aa5d9832e317736598646a466b8b) )
+	ROM_LOAD( "xb04a.ic276",0x0c00, 0x200, CRC(92bf5533) SHA1(4d9127417325af66099234178ab2641d23ee9d22) )
+	ROM_LOAD( "xb04a.ic277",0x0e00, 0x200, CRC(92bf5533) SHA1(4d9127417325af66099234178ab2641d23ee9d22) )
 
 	/* Object tile lookup */
-	ROM_LOAD( "136027-123.25", 0x1000, 0x100, CRC(616a7a85) SHA1(b7c1060ecb128154092441212de64dc304aa3fcd) )
+	ROM_LOAD( "xb03a.ic25", 0x1000, 0x100, CRC(616a7a85) SHA1(b7c1060ecb128154092441212de64dc304aa3fcd) )
 
 	/* Road graphics */
 	ROM_LOAD( "xb09.ic33",  0x1100, 0x200, CRC(fafb6917) SHA1(30eb182c7623026dce7dba9e249bc8a9eb7a7f3e) )
@@ -1014,6 +1100,7 @@
 	ROM_LOAD( "xb12.ic50",  0x1700, 0x200, CRC(6b424cea) SHA1(83127326c20116b0a4be1126e163f9c6755e19dc) )
 ROM_END
 
+
 ROM_START( buggyboy )
 	ROM_REGION( 0x100000, "main_cpu", 0 )
 	ROM_LOAD16_BYTE( "bug1a.230", 0x20000, 0x8000, CRC(92797c25) SHA1(8f7434abbd7f557d3202abb01b1e4899c82c67a5) )
@@ -1026,15 +1113,8 @@
 	ROM_LOAD16_BYTE( "bug6b.175", 0xf8001, 0x4000, CRC(8f000dfa) SHA1(5fd78a03a00f547bbb431839f78a8d10a4ba8e3e) )
 
 	ROM_REGION( 0x100000, "math_cpu", 0 )
-	ROM_LOAD16_BYTE( "bug8a.061", 0x4000, 0x2000, CRC(512291cd) SHA1(60f87133c86b88b982ba4680f96d0ac55970cb8d) )
-	ROM_RELOAD(                  0x8000,  0x2000 )
-	ROM_RELOAD(                  0xc000,  0x2000 )
-	ROM_RELOAD(                  0xfc000, 0x2000 )
-
-	ROM_LOAD16_BYTE( "bug7a.060", 0x4001, 0x2000, CRC(d24dfdef) SHA1(37d05a8bf9567380523df01265afb9780e39ea2a) )
-	ROM_RELOAD(                  0x8001,  0x2000 )
-	ROM_RELOAD(                  0xc001,  0x2000 )
-	ROM_RELOAD(                  0xfc001, 0x2000 )
+	ROM_LOAD16_BYTE( "bug8a.061", 0x04000, 0x2000, CRC(512291cd) SHA1(60f87133c86b88b982ba4680f96d0ac55970cb8d) )
+	ROM_LOAD16_BYTE( "bug7a.060", 0x04001, 0x2000, CRC(d24dfdef) SHA1(37d05a8bf9567380523df01265afb9780e39ea2a) )
 
 	ROM_REGION( 0x10000, "audio_cpu", 0 )
 	ROM_LOAD( "bug35.11", 0x00000, 0x4000,  CRC(7aa16e9e) SHA1(ea54e56270f70351a62a78fa32027bb41ef9861e) )
@@ -1134,15 +1214,8 @@
 	ROM_LOAD16_BYTE( "bug5s.174", 0xf0001, 0x8000, CRC(5e352d8d) SHA1(350c206b5241d5628e673ce1108f728c8c4f980c) )
 
 	ROM_REGION( 0x100000, "math_cpu", 0 )
-	ROM_LOAD16_BYTE( "bug8s.26", 0x4000,  0x2000, CRC(efd66282) SHA1(8355422c0732c92951659930eb399129fe8d6230) )
-	ROM_RELOAD(                  0x8000,  0x2000 )
-	ROM_RELOAD(                  0xc000,  0x2000 )
-	ROM_RELOAD(                  0xfc000, 0x2000 )
-
-	ROM_LOAD16_BYTE( "bug7s.25", 0x4001,  0x2000, CRC(bd75b5eb) SHA1(f2b55f84f4c968df177a56103924ac64705285cd) )
-	ROM_RELOAD(                  0x8001,  0x2000 )
-	ROM_RELOAD(                  0xc001,  0x2000 )
-	ROM_RELOAD(                  0xfc001, 0x2000 )
+	ROM_LOAD16_BYTE( "bug8s.26", 0x04000, 0x2000, CRC(efd66282) SHA1(8355422c0732c92951659930eb399129fe8d6230) )
+	ROM_LOAD16_BYTE( "bug7s.25", 0x04001, 0x2000, CRC(bd75b5eb) SHA1(f2b55f84f4c968df177a56103924ac64705285cd) )
 
 	ROM_REGION( 0x10000, "audio_cpu", 0 )
 	ROM_LOAD( "bug35s.21", 0x00000, 0x4000, CRC(65d9af57) SHA1(17b09404942d17e7254550c43b56ae96a8c55680) )
@@ -1229,7 +1302,8 @@
  *
  *************************************/
 
-GAMEL( 1983, tx1,        0,        tx1,      tx1,      0, ROT0, "Tatsumi", "TX-1",                                   GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND, layout_tx1 )
-GAMEL( 1983, tx1a,       tx1,      tx1,      tx1a,     0, ROT0, "Tatsumi (Atari/Namco/Taito license)", "TX-1 (Atari/Namco/Taito license)", GAME_IMPERFECT_SOUND, layout_tx1 )
-GAMEL( 1985, buggyboy,   0,        buggyboy, buggyboy, 0, ROT0, "Tatsumi", "Buggy Boy/Speed Buggy (cockpit)",        0, layout_buggyboy )
-GAMEL( 1986, buggyboyjr, buggyboy, buggybjr, buggybjr, 0, ROT0, "Tatsumi", "Buggy Boy Junior/Speed Buggy (upright)", 0, layout_buggybjr )
+GAMEL( 1983, tx1,        0,        tx1,      tx1,      0,     ROT0, "Tatsumi (Atari/Namco/Taito license)", "TX-1 (World)", GAME_IMPERFECT_SOUND, layout_tx1 )
+GAMEL( 1983, tx1jb,      tx1,      tx1,      tx1j,     0,     ROT0, "Tatsumi", "TX-1 (Japan rev. B)",                      GAME_IMPERFECT_SOUND, layout_tx1 )
+GAMEL( 1983, tx1jc,      tx1,      tx1,      tx1j,     0,     ROT0, "Tatsumi", "TX-1 (Japan rev. C)",                      GAME_IMPERFECT_SOUND, layout_tx1 )
+GAMEL( 1985, buggyboy,   0,        buggyboy, buggyboy, 0,     ROT0, "Tatsumi", "Buggy Boy/Speed Buggy (cockpit)",          0, layout_buggyboy )
+GAMEL( 1986, buggyboyjr, buggyboy, buggybjr, buggybjr, 0,     ROT0, "Tatsumi", "Buggy Boy Junior/Speed Buggy (upright)",   0, layout_buggybjr )
diff -Nru src-old/mame/drivers/vamphalf.c src/mame/drivers/vamphalf.c
--- src-old/mame/drivers/vamphalf.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/vamphalf.c	2012-07-02 09:06:11.000000000 +0200
@@ -39,6 +39,12 @@
 
  Boong-Ga Boong-Ga: the test mode is usable with a standard input configuration like the "common" one
 
+ The Semicom boards (at least) have a strange visible area, with the display output cutting off 4 lines
+ before you'd expect.  It has been confirmed on real hardware that these lines are simply never output,
+ no amount of stretching the screen renders them as visible.  The games are also programmed around this
+ assumption in many places, with visible sprite clipping issues at screen edges otherwise.  This does
+ result in some graphics also being cut off slightly, but that is correct.
+
  Undumped Semicom games on similar hardware:
    Wivern Wings - Semicom's orginal release with alt spelling of title
    Red Wyvern - A semi-sequel or update?
@@ -57,6 +63,7 @@
 #include "cpu/e132xs/e132xs.h"
 #include "machine/eeprom.h"
 #include "machine/nvram.h"
+#include "sound/qs1000.h"
 #include "sound/2151intf.h"
 #include "sound/okim6295.h"
 
@@ -87,6 +94,8 @@
 	UINT16 m_finalgdr_backupram_bank;
 	UINT8 *m_finalgdr_backupram;
 	int m_has_extra_gfx;
+	UINT8 m_qs1000_data;
+
 	DECLARE_WRITE16_MEMBER(flipscreen_w);
 	DECLARE_WRITE32_MEMBER(flipscreen32_w);
 	DECLARE_WRITE16_MEMBER(jmpbreak_flipscreen_w);
@@ -95,12 +104,11 @@
 	DECLARE_WRITE32_MEMBER(wyvernwg_prot_w);
 	DECLARE_READ32_MEMBER(finalgdr_prot_r);
 	DECLARE_WRITE32_MEMBER(finalgdr_prot_w);
-	DECLARE_WRITE32_MEMBER(finalgdr_backupram_bank_w);
-	DECLARE_READ32_MEMBER(finalgdr_backupram_r);
-	DECLARE_WRITE32_MEMBER(finalgdr_backupram_w);
 	DECLARE_WRITE32_MEMBER(finalgdr_prize_w);
 	DECLARE_WRITE16_MEMBER(boonggab_prize_w);
 	DECLARE_WRITE16_MEMBER(boonggab_lamps_w);
+	DECLARE_CUSTOM_INPUT_MEMBER(boonggab_photo_sensors_r);
+
 	DECLARE_READ16_MEMBER(vamphalf_speedup_r);
 	DECLARE_READ16_MEMBER(vamphafk_speedup_r);
 	DECLARE_READ16_MEMBER(misncrft_speedup_r);
@@ -120,15 +128,24 @@
 	DECLARE_READ16_MEMBER(dtfamily_speedup_r);
 	DECLARE_READ16_MEMBER(toyland_speedup_r);
 	DECLARE_READ16_MEMBER(boonggab_speedup_r);
-	DECLARE_CUSTOM_INPUT_MEMBER(boonggab_photo_sensors_r);
+
 	DECLARE_READ16_MEMBER(eeprom_r);
 	DECLARE_READ32_MEMBER(eeprom32_r);
 	DECLARE_WRITE16_MEMBER(eeprom_w);
 	DECLARE_WRITE32_MEMBER(eeprom32_w);
 	DECLARE_WRITE32_MEMBER(finalgdr_eeprom_w);
+	DECLARE_WRITE32_MEMBER(finalgdr_backupram_bank_w);
+	DECLARE_READ32_MEMBER(finalgdr_backupram_r);
+	DECLARE_WRITE32_MEMBER(finalgdr_backupram_w);
+
 	DECLARE_WRITE32_MEMBER(finalgdr_oki_bank_w);
 	DECLARE_WRITE32_MEMBER(aoh_oki_bank_w);
 	DECLARE_WRITE16_MEMBER(boonggab_oki_bank_w);
+	DECLARE_WRITE32_MEMBER(wyvernwg_snd_w);
+	DECLARE_WRITE16_MEMBER(misncrft_snd_w);
+
+	DECLARE_READ8_MEMBER(qs1000_p1_r);
+	DECLARE_WRITE8_MEMBER(qs1000_p3_w);
 };
 
 READ16_MEMBER(vamphalf_state::eeprom_r)
@@ -338,6 +355,42 @@
 	}
 }
 
+
+
+WRITE32_MEMBER( vamphalf_state::wyvernwg_snd_w )
+{
+	qs1000_device *qs1000 = machine().device<qs1000_device>("qs1000");
+
+	m_qs1000_data = data & 0xff;
+	qs1000->set_irq(ASSERT_LINE);
+	machine().scheduler().boost_interleave(attotime::zero, attotime::from_usec(100));
+}
+
+WRITE16_MEMBER( vamphalf_state::misncrft_snd_w )
+{
+	qs1000_device *qs1000 = machine().device<qs1000_device>("qs1000");
+
+	m_qs1000_data = data & 0xff;
+	qs1000->set_irq(ASSERT_LINE);
+	machine().scheduler().boost_interleave(attotime::zero, attotime::from_usec(100));
+}
+
+READ8_MEMBER( vamphalf_state::qs1000_p1_r )
+{
+	return m_qs1000_data;
+}
+
+WRITE8_MEMBER( vamphalf_state::qs1000_p3_w )
+{
+	qs1000_device *qs1000 = machine().device<qs1000_device>("qs1000");
+
+	if (!BIT(data, 5))
+		qs1000->set_irq(CLEAR_LINE);
+
+	membank("qs1000:data")->set_entry(data & 7);
+}
+
+
 static ADDRESS_MAP_START( common_map, AS_PROGRAM, 16, vamphalf_state )
 	AM_RANGE(0x00000000, 0x001fffff) AM_RAM AM_SHARE("wram")
 	AM_RANGE(0x40000000, 0x4003ffff) AM_RAM AM_SHARE("tiles")
@@ -369,6 +422,7 @@
 	AM_RANGE(0x200, 0x203) AM_READ_PORT("P1_P2")
 	AM_RANGE(0x240, 0x243) AM_READ_PORT("SYSTEM")
 	AM_RANGE(0x3c0, 0x3c3) AM_WRITE(eeprom_w)
+	AM_RANGE(0x400, 0x403) AM_WRITE(misncrft_snd_w)
 	AM_RANGE(0x580, 0x583) AM_READ(eeprom_r)
 ADDRESS_MAP_END
 
@@ -400,7 +454,7 @@
 	AM_RANGE(0x2000, 0x2003) AM_WRITE(flipscreen32_w)
 	AM_RANGE(0x2800, 0x2803) AM_READ_PORT("P1_P2")
 	AM_RANGE(0x3000, 0x3003) AM_READ_PORT("SYSTEM")
-	AM_RANGE(0x5400, 0x5403) AM_WRITENOP // soundlatch
+	AM_RANGE(0x5400, 0x5403) AM_WRITE(wyvernwg_snd_w)
 	AM_RANGE(0x7000, 0x7003) AM_WRITE(eeprom32_w)
 	AM_RANGE(0x7c00, 0x7c03) AM_READ(eeprom32_r)
 ADDRESS_MAP_END
@@ -648,8 +702,28 @@
 }
 
 
+void vamphalf_handle_flipped_visible_area( screen_device &screen )
+{
+	vamphalf_state *state = screen.machine().driver_data<vamphalf_state>();
+	// are there actually registers to handle this?
+	if(!state->m_flipscreen)
+	{
+		rectangle visarea;
+		visarea.set(31, 350, 16, 251);
+		screen.machine().primary_screen->configure(512, 256, visarea, HZ_TO_ATTOSECONDS(60));
+	}
+	else
+	{
+		rectangle visarea;
+		visarea.set(31, 350, 20, 255);
+		screen.machine().primary_screen->configure(512, 256, visarea, HZ_TO_ATTOSECONDS(60));
+	}
+}
+
+
 static SCREEN_UPDATE_IND16( common )
 {
+	vamphalf_handle_flipped_visible_area(screen);
 	bitmap.fill(0, cliprect);
 	draw_sprites(screen, bitmap);
 	return 0;
@@ -657,6 +731,7 @@
 
 static SCREEN_UPDATE_IND16( aoh )
 {
+//  vamphalf_handle_flipped_visible_area(screen); // not on this?
 	bitmap.fill(0, cliprect);
 	draw_sprites_aoh(screen, bitmap);
 	return 0;
@@ -852,13 +927,27 @@
 GFXDECODE_END
 
 
-static ADDRESS_MAP_START( qs1000_prg_map, AS_PROGRAM, 8, vamphalf_state )
-	AM_RANGE( 0x0000, 0xffff) AM_ROM
-ADDRESS_MAP_END
 
-static ADDRESS_MAP_START( qs1000_io_map, AS_IO, 8, vamphalf_state )
-	AM_RANGE( 0x0000, 0x007f) AM_RAM	// RAM?  wavetable registers?  not sure.
-ADDRESS_MAP_END
+
+static QS1000_INTERFACE( qs1000_intf )
+{
+	/* External ROM */
+	true,
+
+	/* P1-P3 read handlers */
+	DEVCB_DRIVER_MEMBER(vamphalf_state, qs1000_p1_r),
+	DEVCB_NULL,
+	DEVCB_NULL,
+
+	/* P1-P3 write handlers */
+	DEVCB_NULL,
+	DEVCB_NULL,
+	DEVCB_DRIVER_MEMBER(vamphalf_state, qs1000_p3_w),
+};
+
+
+
+
 
 static MACHINE_CONFIG_START( common, vamphalf_state )
 	MCFG_CPU_ADD("maincpu", E116T, 50000000)	/* 50 MHz */
@@ -871,8 +960,8 @@
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
-	MCFG_SCREEN_SIZE(512, 512)
-	MCFG_SCREEN_VISIBLE_AREA(31, 350, 16, 255)
+	MCFG_SCREEN_SIZE(512, 256)
+	MCFG_SCREEN_VISIBLE_AREA(31, 350, 16, 251)
 	MCFG_SCREEN_UPDATE_STATIC(common)
 
 	MCFG_PALETTE_LENGTH(0x8000)
@@ -904,10 +993,12 @@
 MACHINE_CONFIG_END
 
 static MACHINE_CONFIG_FRAGMENT( sound_qs1000 )
-	MCFG_CPU_ADD("audiocpu", I8052, 24000000/4)	/* 6 MHz? */
-	MCFG_CPU_PROGRAM_MAP(qs1000_prg_map)
-	MCFG_CPU_IO_MAP( qs1000_io_map)
+	/* sound hardware */
+	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
+	MCFG_QS1000_ADD("qs1000", XTAL_24MHz, qs1000_intf)
+	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
+	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
 
 static MACHINE_CONFIG_DERIVED( vamphalf, common )
@@ -1628,11 +1719,11 @@
 F-E1-32-010-D
 +------------------------------------------------------------------+
 |    VOL    +-------+  +---------+                                 |
-+-+         | QPSD  |  |  U15A   |      +---------+   +---------+  |
++-+         | QDSP  |  |  U15A   |      +---------+   +---------+  |
   |         |QS1001A|  |         |      | ROMH00  |   | ROML00  |  |
 +-+         +-------+  +---------+      |         |   |         |  |
 |           +-------+                   +---------+   +---------+  |
-|           |QPSD   |   +----------+    +---------+   +---------+  |
+|           |QDSP   |   +----------+    +---------+   +---------+  |
 |           |QS1000 |   |    U7    |    | ROMH01  |   | ROML01  |  |
 |J   24MHz  +-------+   +----------+    |         |   |         |  |
 |A                                      +---------+   +---------+  |
@@ -1676,8 +1767,11 @@
 	ROM_LOAD( "rom1.bin", 0x000000, 0x080000, CRC(66bf3a5c) SHA1(037d5e7a6ef6f5b4ac08a9c811498c668a9d2522) )
 	ROM_LOAD( "rom2.bin", 0x080000, 0x080000, CRC(fd9b5911) SHA1(a01e8c6e5a9009024af385268ba3ba90e1ebec50) )
 
-	ROM_REGION( 0x020000, "audiocpu", 0 ) /* QDSP ('51) Code */
-	ROM_LOAD( "u7", 0x0000, 0x20000, CRC(00a3f705) SHA1(f0a6bafd16bea53d4c05c8cc108983cbd41e5757) )
+	ROM_REGION( 0x080000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
+	ROM_LOAD( "u7",  0x00000, 0x20000, CRC(00a3f705) SHA1(f0a6bafd16bea53d4c05c8cc108983cbd41e5757) )
+	ROM_RELOAD(      0x20000, 0x20000 )
+	ROM_RELOAD(      0x40000, 0x20000 )
+	ROM_RELOAD(      0x60000, 0x20000 )
 
 	ROM_REGION( 0x1000000, "gfx1", 0 )  /* gfx data */
 	ROM_LOAD32_WORD( "roml00", 0x000000, 0x200000, CRC(fb3541b6) SHA1(4f569ac7bde92c5febf005ab73f76552421ec223) )
@@ -1689,11 +1783,9 @@
 	ROM_LOAD32_WORD( "roml03", 0xc00000, 0x200000, CRC(b10bf37c) SHA1(6af835b1e2573f0bb2c17057e016a7aecc8fcde8) )
 	ROM_LOAD32_WORD( "romh03", 0xc00002, 0x200000, CRC(e01c2a92) SHA1(f53c2db92d62f595d473b1835c46d426f0dbe6b3) )
 
-	ROM_REGION( 0x200000, "sfx", 0 ) /* Music data / QDSP samples (SFX) */
-	ROM_LOAD( "romsnd.u15a",  0x000000, 0x200000, CRC(fc89eedc) SHA1(2ce28bdb773cfa5b5660e4c0a9ef454cb658f2da) )
-
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* Music data / QDSP samples (SFX) */
+	ROM_LOAD( "romsnd.u15a", 0x000000, 0x200000, CRC(fc89eedc) SHA1(2ce28bdb773cfa5b5660e4c0a9ef454cb658f2da) )
+	ROM_LOAD( "qs1001a",     0x200000, 0x080000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 ROM_START( wyvernwga )
@@ -1701,7 +1793,7 @@
 	ROM_LOAD( "rom1(__alt).rom", 0x000000, 0x080000, CRC(586881fd) SHA1(d335bbd91def8fa4935eb2375c9b00471a1f40eb) )
 	ROM_LOAD( "rom2(__alt).rom", 0x080000, 0x080000, CRC(938049ec) SHA1(cc10944c99ceb388dd4aafc93377c40540861d14) )
 
-	ROM_REGION( 0x020000, "audiocpu", 0 ) /* QDSP ('51) Code */
+	ROM_REGION( 0x020000, "qs1000:cpu", 0 ) /* QDSP (8052) Code */
 	ROM_LOAD( "u7", 0x0000, 0x20000, CRC(00a3f705) SHA1(f0a6bafd16bea53d4c05c8cc108983cbd41e5757) )
 
 	ROM_REGION( 0x1000000, "gfx1", 0 )  /* gfx data */
@@ -1714,11 +1806,9 @@
 	ROM_LOAD32_WORD( "roml03", 0xc00000, 0x200000, CRC(b10bf37c) SHA1(6af835b1e2573f0bb2c17057e016a7aecc8fcde8) )
 	ROM_LOAD32_WORD( "romh03", 0xc00002, 0x200000, CRC(e01c2a92) SHA1(f53c2db92d62f595d473b1835c46d426f0dbe6b3) )
 
-	ROM_REGION( 0x200000, "sfx", 0 ) /* Music data / QDSP samples (SFX) */
-	ROM_LOAD( "romsnd.u15a",  0x000000, 0x200000, CRC(fc89eedc) SHA1(2ce28bdb773cfa5b5660e4c0a9ef454cb658f2da) )
-
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 ) /* Music data / QDSP samples (SFX) */
+	ROM_LOAD( "romsnd.u15a", 0x000000, 0x200000, CRC(fc89eedc) SHA1(2ce28bdb773cfa5b5660e4c0a9ef454cb658f2da) )
+	ROM_LOAD( "qs1001a",     0x200000, 0x080000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 /*
@@ -1774,8 +1864,11 @@
 	/* 0 - 0x80000 empty */
 	ROM_LOAD( "prg-rom2.bin", 0x80000, 0x80000, CRC(059ae8c1) SHA1(2c72fcf560166cb17cd8ad665beae302832d551c) ) /* Version 2.4 */
 
-	ROM_REGION( 0x400000, "audiocpu", 0 )	/* i8052 code */
+	ROM_REGION( 0x080000, "qs1000:cpu", 0 )	/* QDSP (8052) Code */
 	ROM_LOAD( "snd-rom2.us1", 0x00000, 0x20000, CRC(8821e5b9) SHA1(4b8df97bc61b48aa16ed411614fcd7ed939cac33) )
+	ROM_RELOAD(      0x20000, 0x20000 )
+	ROM_RELOAD(      0x40000, 0x20000 )
+	ROM_RELOAD(      0x60000, 0x20000 )
 
 	ROM_REGION( 0x800000, "gfx1", 0 )
 	ROM_LOAD32_WORD( "roml00", 0x000000, 0x200000, CRC(748c5ae5) SHA1(28005f655920e18c82eccf05c0c449dac16ee36e) )
@@ -1783,11 +1876,9 @@
 	ROM_LOAD32_WORD( "roml01", 0x400000, 0x200000, CRC(e37ece7b) SHA1(744361bb73905bc0184e6938be640d3eda4b758d) )
 	ROM_LOAD32_WORD( "romh01", 0x400002, 0x200000, CRC(71fe4bc3) SHA1(08110b02707e835bf428d343d5112b153441e255) )
 
-	ROM_REGION( 0x80000, "sfx", 0 )
-	ROM_LOAD( "snd-rom1.u15", 0x00000, 0x80000, CRC(fb381da9) SHA1(2b1a5447ed856ab92e44d000f27a04d981e3ac52) )
-
-	ROM_REGION( 0x80000, "wavetable", 0 )
-	ROM_LOAD( "qs1001a.u17", 0x00000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_REGION( 0x1000000, "qs1000", 0 )
+	ROM_LOAD( "snd-rom1.u15", 0x000000, 0x80000, CRC(fb381da9) SHA1(2b1a5447ed856ab92e44d000f27a04d981e3ac52) )
+	ROM_LOAD( "qs1001a.u17",  0x200000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 
 	ROM_REGION16_BE( 0x80, "eeprom", 0 )
 	ROM_LOAD( "eeprom-misncrft.bin", 0x0000, 0x0080, CRC(9ad27077) SHA1(7f0e98eff9cf6e1b60c19fc1016b888e50b087e0) )
@@ -2370,6 +2461,10 @@
 
 	state->m_palshift = 0;
 	state->m_flip_bit = 1;
+
+	// Configure the QS1000 ROM banking. Care must be taken not to overlap the 256b internal RAM
+	machine.device("qs1000:cpu")->memory().space(AS_IO)->install_read_bank(0x0100, 0xffff, "data");
+	state->membank("qs1000:data")->configure_entries(0, 16, state->memregion("qs1000:cpu")->base()+0x100, 0x8000-0x100);
 }
 
 static DRIVER_INIT( coolmini )
@@ -2429,6 +2524,10 @@
 	state->m_semicom_prot_idx = 8;
 	state->m_semicom_prot_data[0] = 2;
 	state->m_semicom_prot_data[1] = 1;
+
+	// Configure the QS1000 ROM banking. Care must be taken not to overlap the 256b internal RAM
+	machine.device("qs1000:cpu")->memory().space(AS_IO)->install_read_bank(0x0100, 0xffff, "data");
+	state->membank("qs1000:data")->configure_entries(0, 16, state->memregion("qs1000:cpu")->base()+0x100, 0x8000-0x100);
 }
 
 static DRIVER_INIT( finalgdr )
@@ -2539,13 +2638,13 @@
 GAME( 1999, vamphalf, 0,        vamphalf, common,   vamphalf, ROT0,   "Danbi / F2 System", "Vamf x1/2 (Europe)", 0 )
 GAME( 1999, vamphalfk,vamphalf, vamphalf, common,   vamphafk, ROT0,   "Danbi / F2 System", "Vamp x1/2 (Korea)", 0 )
 GAME( 2000, dquizgo2, 0,        coolmini, common,   dquizgo2, ROT0,   "SemiCom",           "Date Quiz Go Go Episode 2" , 0)
-GAME( 2000, misncrft, 0,        misncrft, common,   misncrft, ROT90,  "Sun",               "Mission Craft (version 2.4)", GAME_NO_SOUND )
+GAME( 2000, misncrft, 0,        misncrft, common,   misncrft, ROT90,  "Sun",               "Mission Craft (version 2.4)", GAME_IMPERFECT_SOUND )
 GAME( 2000, mrdig,    0,        mrdig,    common,   mrdig,    ROT0,   "Sun",               "Mr. Dig", 0 )
 GAME( 2001, dtfamily, 0,        coolmini, common,   dtfamily, ROT0,   "SemiCom",           "Diet Family", 0 )
 GAME( 2001, finalgdr, 0,        finalgdr, finalgdr, finalgdr, ROT0,   "SemiCom",           "Final Godori (Korea, version 2.20.5915)", 0 )
 GAME( 2001, mrkicker, 0,        mrkicker, finalgdr, mrkicker, ROT0,   "SemiCom",           "Mr. Kicker", GAME_NOT_WORKING ) // game stops booting / working properly after you get a high score, or if you don't have a default eeprom with 'valid data.  It's never worked properly, CPU core issue?
 GAME( 2001, toyland,  0,        coolmini, common,   toyland,  ROT0,   "SemiCom",           "Toy Land Adventure", 0 )
-GAME( 2001, wyvernwg, 0,        wyvernwg, common,   wyvernwg, ROT270, "SemiCom (Game Vision license)", "Wyvern Wings (set 1)", GAME_NO_SOUND )
-GAME( 2001, wyvernwga,wyvernwg, wyvernwg, common,   wyvernwg, ROT270, "SemiCom (Game Vision license)", "Wyvern Wings (set 2)", GAME_NO_SOUND )
+GAME( 2001, wyvernwg, 0,        wyvernwg, common,   wyvernwg, ROT270, "SemiCom (Game Vision license)", "Wyvern Wings (set 1)", GAME_IMPERFECT_SOUND )
+GAME( 2001, wyvernwga,wyvernwg, wyvernwg, common,   wyvernwg, ROT270, "SemiCom (Game Vision license)", "Wyvern Wings (set 2)", GAME_IMPERFECT_SOUND )
 GAME( 2001, aoh,      0,        aoh,      aoh,      aoh,      ROT0,   "Unico",             "Age Of Heroes - Silkroad 2 (v0.63 - 2001/02/07)", 0 )
 GAME( 2001, boonggab, 0,        boonggab, boonggab, boonggab, ROT270, "Taff System",	   "Boong-Ga Boong-Ga (Spank'em!)", 0 )
diff -Nru src-old/mame/drivers/vball.c src/mame/drivers/vball.c
--- src-old/mame/drivers/vball.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/drivers/vball.c	2012-06-28 05:23:50.000000000 +0200
@@ -508,24 +508,59 @@
 	ROM_REGION( 0x10000, "audiocpu", 0 ) /* region#2: music CPU, 64kb */
 	ROM_LOAD( "25j1-0.47",    0x00000, 0x8000,  CRC(10ca79ad) SHA1(aad4a09d6745ca0b5665cb00ff7a4e08ea434068) )
 
-	/* These are from the bootleg; the original has the image data stored in a special dip rom */
+	/* The bootlegs used standard roms on a daughter card that plugs into the socket for the TOSHIBA TRJ-101 dip rom */
 	ROM_REGION(0x80000, "gfx1", 0 )	 /* fg tiles */
-	ROM_LOAD( "vball13.bin",  0x00000, 0x10000, CRC(f26df8e1) SHA1(72186c1430d07c7fd9211245b539f05a0660bebe) ) /* 0,1,2,3 */
-	ROM_LOAD( "vball14.bin",  0x10000, 0x10000, CRC(c9798d0e) SHA1(ec156f6c7ecccaa216ce8076f75ad7627ee90945) ) /* 0,1,2,3 */
-	ROM_LOAD( "vball15.bin",  0x20000, 0x10000, CRC(68e69c4b) SHA1(9870674c91cab7215ad8ed40eb82facdee478fde) ) /* 0,1,2,3 */
-	ROM_LOAD( "vball16.bin",  0x30000, 0x10000, CRC(936457ba) SHA1(1662bbd777fcd33a298d192a3f06681809b9d049) ) /* 0,1,2,3 */
-	ROM_LOAD( "vball09.bin",  0x40000, 0x10000, CRC(42874924) SHA1(a75eed7934e089f035000b7f35f6ba8dd96f1e98) ) /* 0,1,2,3 */
-	ROM_LOAD( "vball10.bin",  0x50000, 0x10000, CRC(6cc676ee) SHA1(6e8c590946211baa9266b19b871f252829057696) ) /* 0,1,2,3 */
-	ROM_LOAD( "vball11.bin",  0x60000, 0x10000, CRC(4754b303) SHA1(8630f077b542590ef1340a2f0a6b94086ff91c40) ) /* 0,1,2,3 */
-	ROM_LOAD( "vball12.bin",  0x70000, 0x10000, CRC(21294a84) SHA1(b36ea9ddf6879443d3104241997fa0f916856528) ) /* 0,1,2,3 */
+	ROM_LOAD( "13", 0x00000, 0x10000, CRC(f26df8e1) SHA1(72186c1430d07c7fd9211245b539f05a0660bebe) ) /* 0,1,2,3 */
+	ROM_LOAD( "14", 0x10000, 0x10000, CRC(c9798d0e) SHA1(ec156f6c7ecccaa216ce8076f75ad7627ee90945) ) /* 0,1,2,3 */
+	ROM_LOAD( "15", 0x20000, 0x10000, CRC(68e69c4b) SHA1(9870674c91cab7215ad8ed40eb82facdee478fde) ) /* 0,1,2,3 */
+	ROM_LOAD( "16", 0x30000, 0x10000, CRC(936457ba) SHA1(1662bbd777fcd33a298d192a3f06681809b9d049) ) /* 0,1,2,3 */
+	ROM_LOAD( "9",  0x40000, 0x10000, CRC(42874924) SHA1(a75eed7934e089f035000b7f35f6ba8dd96f1e98) ) /* 0,1,2,3 */
+	ROM_LOAD( "10", 0x50000, 0x10000, CRC(6cc676ee) SHA1(6e8c590946211baa9266b19b871f252829057696) ) /* 0,1,2,3 */
+	ROM_LOAD( "11", 0x60000, 0x10000, CRC(4754b303) SHA1(8630f077b542590ef1340a2f0a6b94086ff91c40) ) /* 0,1,2,3 */
+	ROM_LOAD( "12", 0x70000, 0x10000, CRC(21294a84) SHA1(b36ea9ddf6879443d3104241997fa0f916856528) ) /* 0,1,2,3 */
 
 	ROM_REGION(0x40000, "gfx2", 0 ) /* sprites */
-	ROM_LOAD( "vball.35",     0x00000, 0x20000, CRC(877826d8) SHA1(fd77298f9343051f66259dad9127f40afb95f385) ) /* 0,1,2,3 */
-	ROM_LOAD( "vball.5",      0x20000, 0x20000, CRC(c6afb4fa) SHA1(6d7c966300ce5fb2094476b393434486965d62b4) ) /* 0,1,2,3 */
+	ROM_LOAD( "vball.35",     0x00000, 0x20000, CRC(877826d8) SHA1(fd77298f9343051f66259dad9127f40afb95f385) ) /* 0,1,2,3 == 25j4-0.35 */
+	ROM_LOAD( "vball.5",      0x20000, 0x20000, CRC(c6afb4fa) SHA1(6d7c966300ce5fb2094476b393434486965d62b4) ) /* 0,1,2,3 == 25j3-0.5  */
 
 	ROM_REGION(0x40000, "oki", 0 ) /* Sound region#1: adpcm */
-	ROM_LOAD( "vball.78a",    0x00000, 0x10000, CRC(f3e63b76) SHA1(da54d1d7d7d55b73e49991e4363bc6f46e0f70eb) )
-	ROM_LOAD( "vball.78b",    0x10000, 0x10000, CRC(7ad9d338) SHA1(3e3c270fa69bda93b03f07a54145eb5e211ec8ba) )
+	ROM_LOAD( "vball.78a",    0x00000, 0x10000, CRC(f3e63b76) SHA1(da54d1d7d7d55b73e49991e4363bc6f46e0f70eb) ) /* == 1st half of 25j0-0.78 */
+	ROM_LOAD( "vball.78b",    0x10000, 0x10000, CRC(7ad9d338) SHA1(3e3c270fa69bda93b03f07a54145eb5e211ec8ba) ) /* == 2nd half of 25j0-0.78 */
+
+	ROM_REGION(0x1000, "proms", 0 )	/* color PROMs */
+	ROM_LOAD_NIB_LOW ( "25j5-0.144",   0x0000,  0x00800, CRC(a317240f) SHA1(bd57ad516f7a8ff774276fd26b02dd34659d41ad) )
+	ROM_LOAD_NIB_HIGH( "25j6-0.143",   0x0000,  0x00800, CRC(1ff70b4f) SHA1(a469baa0dda844ba307c09ddefb23f239cfe7b5f) )
+	ROM_LOAD(          "25j7-0.160",   0x0800,  0x00800, CRC(2ffb68b3) SHA1(d560fdcd5e5c79d37e5b5bde22fbaf662fe89252) )
+ROM_END
+
+ROM_START( vball2pjb ) /* bootleg of the Japan set with unmoddified program rom */
+	ROM_REGION( 0x18000, "maincpu", 0 ) /* Main CPU: 64k for code */
+	ROM_LOAD( "1.124", 0x10000, 0x08000, CRC(432509c4) SHA1(6de50e21d279f4ac9674bc91990ba9535e80908c) )/* Bankswitched, == 25j2-2-5.124 from vball2pj */
+	ROM_CONTINUE(      0x08000, 0x08000 ) /* Static code  */
+
+	ROM_REGION( 0x10000, "audiocpu", 0 ) /* Sound CPU, 64kb */
+	ROM_LOAD( "4.ic47", 0x00000, 0x8000,  CRC(534dfbd9) SHA1(d0cb37caf94fa85da4ebdfe15e7a78109084bf91) )
+
+	/* The bootlegs used standard roms on a daughter card that plugs into the socket for the TOSHIBA TRJ-101 dip rom */
+	ROM_REGION(0x80000, "gfx1", 0 )	 /* fg tiles */
+	ROM_LOAD( "13", 0x00000, 0x10000, CRC(f26df8e1) SHA1(72186c1430d07c7fd9211245b539f05a0660bebe) ) /* 0,1,2,3 */
+	ROM_LOAD( "14", 0x10000, 0x10000, CRC(c9798d0e) SHA1(ec156f6c7ecccaa216ce8076f75ad7627ee90945) ) /* 0,1,2,3 */
+	ROM_LOAD( "15", 0x20000, 0x10000, CRC(68e69c4b) SHA1(9870674c91cab7215ad8ed40eb82facdee478fde) ) /* 0,1,2,3 */
+	ROM_LOAD( "16", 0x30000, 0x10000, CRC(936457ba) SHA1(1662bbd777fcd33a298d192a3f06681809b9d049) ) /* 0,1,2,3 */
+	ROM_LOAD( "9",  0x40000, 0x10000, CRC(42874924) SHA1(a75eed7934e089f035000b7f35f6ba8dd96f1e98) ) /* 0,1,2,3 */
+	ROM_LOAD( "10", 0x50000, 0x10000, CRC(6cc676ee) SHA1(6e8c590946211baa9266b19b871f252829057696) ) /* 0,1,2,3 */
+	ROM_LOAD( "11", 0x60000, 0x10000, CRC(4754b303) SHA1(8630f077b542590ef1340a2f0a6b94086ff91c40) ) /* 0,1,2,3 */
+	ROM_LOAD( "12", 0x70000, 0x10000, CRC(21294a84) SHA1(b36ea9ddf6879443d3104241997fa0f916856528) ) /* 0,1,2,3 */
+
+	ROM_REGION(0x40000, "gfx2", 0 ) /* sprites */
+	ROM_LOAD( "8", 0x00000, 0x10000, CRC(b18d083c) SHA1(8c7a39b8a9c79a13682a4f283470801c3cbb748c) ) /* == 1st half of 25j4-0.35 */
+	ROM_LOAD( "7", 0x10000, 0x10000, CRC(79a35321) SHA1(0953730b1baa9bda4b2eb703258476423e5448f5) ) /* == 2nd half of 25j4-0.35 */
+	ROM_LOAD( "6", 0x20000, 0x10000, CRC(49c6aad7) SHA1(6c026ddd97a5dfd138fb65781504f192c11ee6aa) ) /* == 1st half of 25j3-0.5  */
+	ROM_LOAD( "5", 0x30000, 0x10000, CRC(9bb95651) SHA1(ec8a481cc7f0d6e469489db7c51103446910ae80) ) /* == 2nd half of 25j3-0.5  */
+
+	ROM_REGION(0x40000, "oki", 0 ) /* Sound region#1: adpcm */
+	ROM_LOAD( "vball.78a", 0x00000, 0x10000, CRC(f3e63b76) SHA1(da54d1d7d7d55b73e49991e4363bc6f46e0f70eb) ) /* == 1st half of 25j0-0.78    (ROM type 27512) */
+	ROM_LOAD( "3.ic79",    0x10000, 0x08000, CRC(d77349ba) SHA1(5ef25636056607fae7a5463957487b53da0dd310) ) /* == 3rd quarter of 25j0-0.78 (ROM type 27256) */
 
 	ROM_REGION(0x1000, "proms", 0 )	/* color PROMs */
 	ROM_LOAD_NIB_LOW ( "25j5-0.144",   0x0000,  0x00800, CRC(a317240f) SHA1(bd57ad516f7a8ff774276fd26b02dd34659d41ad) )
@@ -536,4 +571,5 @@
 
 GAME( 1988, vball,    0,     vball,    vball,    0, ROT0, "Technos Japan", "U.S. Championship V'ball (US)", 0 )
 GAME( 1988, vball2pj, vball, vball,    vball2pj, 0, ROT0, "Technos Japan", "U.S. Championship V'ball (Japan)", 0 )
-GAME( 1988, vballb,   vball, vball,    vball,    0, ROT0, "bootleg", "U.S. Championship V'ball (bootleg)", 0 )
+GAME( 1988, vballb,   vball, vball,    vball,    0, ROT0, "bootleg", "U.S. Championship V'ball (bootleg of US set)", 0 )
+GAME( 1988, vball2pjb,vball, vball,    vball,    0, ROT0, "bootleg", "U.S. Championship V'ball (bootleg of Japan set)", 0 )
diff -Nru src-old/mame/drivers/vegaeo.c src/mame/drivers/vegaeo.c
--- src-old/mame/drivers/vegaeo.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/drivers/vegaeo.c	2012-07-02 09:06:11.000000000 +0200
@@ -8,13 +8,13 @@
 
  TODO:
  - where are mapped the unused dip switches?
- - sound & sound cpu
 
  *********************************************************************/
 
 #include "emu.h"
 #include "cpu/e132xs/e132xs.h"
 #include "machine/at28c16.h"
+#include "sound/qs1000.h"
 #include "includes/eolith.h"
 #include "includes/eolithsp.h"
 
@@ -32,10 +32,43 @@
 	DECLARE_WRITE32_MEMBER(vega_palette_w);
 	DECLARE_WRITE32_MEMBER(vega_misc_w);
 	DECLARE_READ32_MEMBER(vegaeo_custom_read);
+	DECLARE_WRITE32_MEMBER(soundlatch_w);
+
+	DECLARE_READ8_MEMBER(qs1000_p1_r);
+
+	DECLARE_WRITE8_MEMBER(qs1000_p1_w);
+	DECLARE_WRITE8_MEMBER(qs1000_p2_w);
+	DECLARE_WRITE8_MEMBER(qs1000_p3_w);
 };
 
+READ8_MEMBER( vegaeo_state::qs1000_p1_r )
+{
+	return soundlatch_byte_r(space, 0);
+}
+
+WRITE8_MEMBER( vegaeo_state::qs1000_p1_w )
+{
+
+}
+
+WRITE8_MEMBER( vegaeo_state::qs1000_p2_w )
+{
+
+}
+
+WRITE8_MEMBER( vegaeo_state::qs1000_p3_w )
+{
+	// .... .xxx - Data ROM bank (64kB)
+	// ...x .... - ?
+	// ..x. .... - /IRQ clear
 
+	qs1000_device *qs1000 = machine().device<qs1000_device>("qs1000");
 
+	membank("qs1000:bank")->set_entry(data & 0x07);
+
+	if (!BIT(data, 5))
+		qs1000->set_irq(CLEAR_LINE);
+}
 
 WRITE32_MEMBER(vegaeo_state::vega_vram_w)
 {
@@ -96,13 +129,24 @@
 	return ioport("SYSTEM")->read();
 }
 
+WRITE32_MEMBER(vegaeo_state::soundlatch_w)
+{
+	qs1000_device *qs1000 = space.machine().device<qs1000_device>("qs1000");
+
+	soundlatch_byte_w(space, 0, data);
+	qs1000->set_irq(ASSERT_LINE);
+
+	machine().scheduler().boost_interleave(attotime::zero, attotime::from_usec(100));
+}
+
+
 static ADDRESS_MAP_START( vega_map, AS_PROGRAM, 32, vegaeo_state )
 	AM_RANGE(0x00000000, 0x001fffff) AM_RAM
 	AM_RANGE(0x80000000, 0x80013fff) AM_READWRITE(vega_vram_r, vega_vram_w)
 	AM_RANGE(0xfc000000, 0xfc0000ff) AM_DEVREADWRITE8_LEGACY("at28c16", at28c16_r, at28c16_w, 0x000000ff)
 	AM_RANGE(0xfc200000, 0xfc2003ff) AM_RAM_WRITE(vega_palette_w) AM_SHARE("paletteram")
 	AM_RANGE(0xfc400000, 0xfc40005b) AM_WRITENOP // crt registers ?
-	AM_RANGE(0xfc600000, 0xfc600003) AM_WRITENOP // soundlatch
+	AM_RANGE(0xfc600000, 0xfc600003) AM_WRITE(soundlatch_w)
 	AM_RANGE(0xfca00000, 0xfca00003) AM_WRITE(vega_misc_w)
 	AM_RANGE(0xfcc00000, 0xfcc00003) AM_READ(vegaeo_custom_read)
 	AM_RANGE(0xfce00000, 0xfce00003) AM_READ_PORT("P1_P2")
@@ -179,12 +223,36 @@
 }
 
 
+
+/*************************************
+ *
+ *  QS1000 interface
+ *
+ *************************************/
+
+static QS1000_INTERFACE( qs1000_intf )
+{
+	/* External ROM */
+	true,
+
+	/* P1-P3 read handlers */
+	DEVCB_DRIVER_MEMBER(vegaeo_state, qs1000_p1_r),
+	DEVCB_NULL,
+	DEVCB_NULL,
+
+	/* P1-P3 write handlers */
+	DEVCB_DRIVER_MEMBER(vegaeo_state, qs1000_p1_w),
+	DEVCB_DRIVER_MEMBER(vegaeo_state, qs1000_p2_w),
+	DEVCB_DRIVER_MEMBER(vegaeo_state, qs1000_p3_w)
+};
+
+
 static MACHINE_CONFIG_START( vega, vegaeo_state )
-	MCFG_CPU_ADD("maincpu", GMS30C2132, 55000000)	/* 55 MHz */
+	MCFG_CPU_ADD("maincpu", GMS30C2132, XTAL_55MHz)
 	MCFG_CPU_PROGRAM_MAP(vega_map)
 	MCFG_TIMER_ADD_SCANLINE("scantimer", eolith_speedup, "screen", 0, 1)
 
-	/* sound cpu */
+	MCFG_AT28C16_ADD("at28c16", NULL)
 
 	/* video hardware */
 	MCFG_SCREEN_ADD("screen", RASTER)
@@ -199,7 +267,12 @@
 	MCFG_VIDEO_START(vega)
 
 	/* sound hardware */
-	MCFG_AT28C16_ADD( "at28c16", NULL )
+	/* sound hardware */
+	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
+
+	MCFG_QS1000_ADD("qs1000", XTAL_24MHz, qs1000_intf)
+	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
+	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
 
 /*
@@ -270,19 +343,23 @@
 	ROM_LOAD32_WORD_SWAP( "14", 0x1c00000, 0x200000, CRC(38ede322) SHA1(9496685a1280885a61a568047c4a8c2cd70d1b83) )
 	ROM_LOAD32_WORD_SWAP( "15", 0x1c00002, 0x200000, CRC(d35e630a) SHA1(8c220f1baddd39cc978e3e5a874cc58e78b74c62) )
 
-	ROM_REGION( 0x080000, "cpu1", 0 )  /* QDSP ('51) Code ? */
+	ROM_REGION( 0x080000, "qs1000:cpu", 0 )  /* QDSP (8052) Code */
 	ROM_LOAD( "bgm.u84",      0x000000, 0x080000, CRC(13aa7778) SHA1(131f74e1b73dd7a7038864593dc7ca24af0ffc30) )
 
-	ROM_REGION( 0x100000, "music", 0 )
+	ROM_REGION( 0x1000000, "qs1000", 0 )
 	ROM_LOAD( "effect.u85",   0x000000, 0x100000, CRC(9159fcc6) SHA1(2be9a197a51303a0da9484dced12a3f6d3b0d867) )
-
-	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
-	ROM_LOAD( "qs1001a.u86",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+	ROM_LOAD( "qs1001a.u86",  0x200000, 0x080000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
 static DRIVER_INIT( vegaeo )
 {
+	vegaeo_state *state = machine.driver_data<vegaeo_state>();
+
+	// Set up the QS1000 program ROM banking, taking care not to overlap the internal RAM
+	machine.device("qs1000:cpu")->memory().space(AS_IO)->install_read_bank(0x0100, 0xffff, "bank");
+	state->membank("qs1000:bank")->configure_entries(0, 8, state->memregion("qs1000:cpu")->base()+0x100, 0x10000);
+
 	init_eolith_speedup(machine);
 }
 
-GAME( 2002, crazywar, 0, vega, crazywar, vegaeo, ROT0, "Eolith", "Crazy War",  GAME_NO_SOUND )
+GAME( 2002, crazywar, 0, vega, crazywar, vegaeo, ROT0, "Eolith", "Crazy War", GAME_IMPERFECT_SOUND )
diff -Nru src-old/mame/drivers/viper.c src/mame/drivers/viper.c
--- src-old/mame/drivers/viper.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/viper.c	2012-07-02 08:20:21.000000000 +0200
@@ -384,26 +384,26 @@
 
 READ64_MEMBER(viper_state::pci_config_addr_r)
 {
-	device_t *device = machine().device("pcibus");
-	return pci_64be_r(device, 0, U64(0xffffffff00000000));
+	pci_bus_legacy_device *device = machine().device<pci_bus_legacy_device>("pcibus");
+	return device->read_64be(space, 0, U64(0xffffffff00000000));
 }
 
 WRITE64_MEMBER(viper_state::pci_config_addr_w)
 {
-	device_t *device = machine().device("pcibus");
-	pci_64be_w(device, 0, data, U64(0xffffffff00000000));
+	pci_bus_legacy_device *device = machine().device<pci_bus_legacy_device>("pcibus");
+	device->write_64be(space, 0, data, U64(0xffffffff00000000));
 }
 
 READ64_MEMBER(viper_state::pci_config_data_r)
 {
-	device_t *device = machine().device("pcibus");
-	return pci_64be_r(device, 1, U64(0x00000000ffffffff)) << 32;
+	pci_bus_legacy_device *device = machine().device<pci_bus_legacy_device>("pcibus");
+	return device->read_64be(space, 1, U64(0x00000000ffffffff)) << 32;
 }
 
 WRITE64_MEMBER(viper_state::pci_config_data_w)
 {
-	device_t *device = machine().device("pcibus");
-	pci_64be_w(device, 1, data >> 32, U64(0x00000000ffffffff));
+	pci_bus_legacy_device *device = machine().device<pci_bus_legacy_device>("pcibus");
+	device->write_64be(space, 1, data >> 32, U64(0x00000000ffffffff));
 }
 
 
@@ -1976,9 +1976,9 @@
 	MCFG_MACHINE_START(viper)
 	MCFG_MACHINE_RESET(viper)
 
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(0, "mpc8240", mpc8240_pci_r, mpc8240_pci_w)
-	MCFG_PCI_BUS_DEVICE(12, "voodoo", voodoo3_pci_r, voodoo3_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(0, "mpc8240", mpc8240_pci_r, mpc8240_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(12, "voodoo", voodoo3_pci_r, voodoo3_pci_w)
 
 	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL, true)
 	MCFG_3DFX_VOODOO_3_ADD("voodoo", STD_VOODOO_3_CLOCK, 8, "screen")
diff -Nru src-old/mame/drivers/voyager.c src/mame/drivers/voyager.c
--- src-old/mame/drivers/voyager.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/voyager.c	2012-07-02 08:20:21.000000000 +0200
@@ -449,7 +449,7 @@
 	AM_RANGE(0x03f0, 0x03f7) AM_READWRITE(fdc_r, fdc_w)
 	AM_RANGE(0x03f8, 0x03ff) AM_NOP // To debug Serial Port COM1:
 	AM_RANGE(0x0a78, 0x0a7b) AM_WRITENOP//AM_WRITE_LEGACY(pnp_data_w)
-	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE_LEGACY("pcibus", pci_32le_r,	pci_32le_w)
+	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_bus_legacy_device, read, write)
 	AM_RANGE(0x42e8, 0x43ef) AM_NOP //To debug
 	AM_RANGE(0x43c0, 0x43cf) AM_RAM AM_SHARE("share1")
 	AM_RANGE(0x46e8, 0x46ef) AM_NOP //To debug
@@ -778,9 +778,9 @@
 	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL, true)
 
 	MCFG_MC146818_ADD( "rtc", MC146818_STANDARD )
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
-	MCFG_PCI_BUS_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
 
 	/* video hardware */
 	MCFG_FRAGMENT_ADD( pcvideo_vga )
diff -Nru src-old/mame/drivers/wildpkr.c src/mame/drivers/wildpkr.c
--- src-old/mame/drivers/wildpkr.c	1970-01-01 01:00:00.000000000 +0100
+++ src/mame/drivers/wildpkr.c	2012-07-02 09:06:11.000000000 +0200
@@ -0,0 +1,309 @@
+/******************************************************************************
+
+  Wild Poker
+  TAB Austria.
+
+  Preliminary driver by Roberto Fresca.
+
+
+  Games running in this hardware:
+
+  * Wild Poker (ver. D 1.01),         199?, TAB Austria.
+
+
+  The HD63484 ACRTC support is incomplete,
+  due to the preliminary emulation state.
+
+*******************************************************************************
+
+  Hardware Notes:
+  ---------------
+
+  CPU:
+  - 1x MC68000P12        ; 68000 CPU @ 12 MHz, from Motorola.
+  - 1x D8751H            ; 8751 MCU (3.6864 MHz?)
+
+  Sound device:
+  - 1x AY8930            ; Sound IC, from Yamaha.
+
+  Video:
+  - 1x HD63484CP8 @ 8MHz ; Advanced CRT Controller (ACRTC), from Hitachi Semiconductor.
+  - 1x HD63485CP64       ; Hitachi - Graphic Memory Interface Controller (GMIC).
+  - 2x HD63486CP32       ; Hitachi - Graphic Video Attribute Controller (GVAC).
+
+  Other:
+  - 1x MC68681           ; Motorola - Dual Asynchronous Receiver/Transmitter.
+  - 4x XTALs....         ; 3.6864 / 12.000 / 26.000 / 24.000 MHz.
+
+                                                                                          .--------.
+  PCB Layout:                                                                           --+--------+--
+  .---------------------------------------------------------------------------------------+        +-----------------------------------------------------.
+  |                                                                                       |  DB9   |                                                     |
+  |                        .--------.                    .--------.                       |        |                             .--------.              |
+  |                        |::::::::|                    |::::::::|                       '--------'                             |74HCT32P|              |
+  |                        '--------'                    '--------'                                                              '--------'              |
+  |                        .--------.                    .---------. .----------.         .--------. .----------.  .----------.  .--------.              |
+  |                        |LT1084CN|                    |SN75116N | | MM57410N |         |74HCT14P| |74HCT245P |  |74HCT245P |  |74HCT86P| .-------.    |
+  |                        '--------'                    '---------' '----------'         '--------' '----------'  '----------'  '--------' |XTAL 3 |    |
+  |                                                                                                                  .--------.   .-------. |       |    |
+  |                                         .--------.    .---------.        .-..-.                                  |        |   |DM74S04| '-------'    |
+  |                                         |  PC617 |    |74HCT14P |        | || |               .----------------. '--------'   '-------'              |
+  |                                         '--------'    '---------'        '-''-'               |  inmos 8941-C  |                                     |
+  |.--. .---------.  .---------.    .-----------. .--------.     .---------------.                |  IMS G176P-50  |           .----------. .----------. |
+  ||..| |ULN2803A |  |74HCT533P|    |PC74HC245P | |74HCT125|     |    HYUNDAI    |                |                |           |HY53C464LS| |HY53C464LS| |
+  ||..| '---------'  '---------'    '-----------' '--------'     |  HY6264LP-10  |                '----------------'           '----------' '----------' |
+  ||..|                           .------------------------.     |  9040D KOREA  |  .-------------.        .-------------.     .----------. .----------. |
+  ||..| .---------.  .---------.  |        AY8930 /P       |     '---------------'  |             |        |             |     |HY53C464LS| |HY53C464LS| |
+  ||..| |ULN2803A |  |74HCT533P|  |        9019CCA         |                        |             |        |             |     '----------' '----------' |
+  ||..| '---------'  '---------'  |        TAIWAN          |     .---------------.  |    IE1 U    |        |    9117     |     .----------. .----------. |
+  ||..|                           '------------------------'     |    HYUNDAI    |  | HD63484CP8  |        | HD63486CP32 |     |HY53C464LS| |HY53C464LS| |
+  ||..| .---------.  .---------.                                 |  HY6264LP-10  |  |             |        |             |     '----------' '----------' |
+  ||..| |ULN2803A |  |74HCT533P|       .--------. .--------.     |  9040D KOREA  |  |        Japan|        |        Japan|     .----------. .----------. |
+  ||..| '---------'  '---------'  .---.|8      1| |8      1|     '---------------'  |             |        |             |     |HY53C464LS| |HY53C464LS| |
+  |'--'                           |   ||  DSW1  | |  DSW2  |                        |             |        |             |     '----------' '----------' |
+  |     .---------.  .---------.  '---''--------' '--------'                        '-------------'        '-------------'                               |
+  |.--. |ULN2803A |  |74HCT533P|                                                                                                                         |
+  ||..| '---------'  '---------'  .------------------------.                                                                   .----------. .----------. |
+  ||..|                           |D8751H                  |                                                                   |HY53C464LS| |HY53C464LS| |
+  ||..|                           |L0381103                |                        .-------------.        .-------------.     '----------' '----------' |
+  ||..|  .--------.  .---------.  |          VD1.00        |  .------------------.  |             |        |             |     .----------. .----------. |
+  ||..|  |MDP1603 |  |74HCT245P|  '------------------------'  |D27C020           |  |             |        |             |     |HY53C464LS| |HY53C464LS| |
+  |'--'  '--------'  '---------'  .-------.     .-------.     |                  |  |     9109    |        |    9117     |     '----------' '----------' |
+  |                               |XTAL 1 |     |XTAL 2 |     |   VD / 1.01 / 3  |  | HD63485CP64 |        | HD63486CP32 |     .----------. .----------. |
+  |.--.  .--------.  .---------.  |       |     |       |     '------------------'  |             |        |             |     |HY53C464LS| |HY53C464LS| |
+  ||..|  |MDP1603 |  |74HCT245P|  '-------'     '-------'                           |        Japan|        |        Japan|     '----------' '----------' |
+  ||..|  '--------'  '---------'  .------------------------.                        |             |        |             |     .----------. .----------. |
+  ||..|                           |        MC68681P        |                        |             |        |             |     |HY53C464LS| |HY53C464LS| |
+  ||..|  .--------.  .---------.  |         2C98R          |                        '-------------'        '-------------'     '----------' '----------' |
+  ||..|  |MDP1603 |  |74HCT245P|  |        QQPQ9051        |                                                                                             |
+  ||..|  '--------'  '---------'  '------------------------'  .------------------.                                             .--------.   .--------.   |
+  ||..|                             .--------.    .--------.  |D27C020           |                                             |        |   |        |   |
+  ||..|  .--------.  .---------.    |8      1|    |74HCT147|  |                  |                                             '--------'   '--------'   |
+  ||..|  |MDP1603 |  |74HCT245P|    |  DSW3  |    '--------'  |   VD / 1.01 / 1  |                 .--------.  .--------.                                |
+  ||..|  '--------'  '---------'    '--------'                '------------------'                 |74HCT138|  |74HCT74P|                                |
+  |'--'                                                                     .----------. .-------. '--------'  '--------'                           .------.
+  |                             .---------------------------------------.   | GAL16V8S | |74HCT74|                                                  |      |
+  |      .-------.              |                                       |   '----------' '-------' .--------.  .--------.                           |      |
+  |      |       |              |             MC68000P12                |  .--------.   .------.   |74HCT138|  |74HCT21P|                           |      |
+  |      |Battery|              |               2C91E                   |  |74HCT04P|   |XTAL 4|   '--------'  '--------'                           |      |
+  |      |       |              |              QZUZ9102                 |  '--------'   |      |   .--------.  .--------.                           |      |
+  |      |       |              |                                       |  .--------.   '------'   |74HCT138|  |74HCT161|                           |      |
+  |      '-------'              '---------------------------------------'  |74HCT14P|              '--------'  '--------'                           |      |
+  |                                                                        '--------'  .-------.   .--------.  .--------.                           |      |
+  |               .--.  .--.                                                           |74HCT08|   |74HCT21 |  |1      8|                           |      |
+  |               |TL|  |TL|                                                           '-------'   '--------'  |  DSW4  |                           |      |
+  |               '--'  '--'    ========================================                                       '--------'                           '------'
+  |                            | |::::::::::::::::::::::::::::::::::::| |                                                                                |
+  |                            | |::::::::::::::::::::::::::::::::::::| |                                                                                |
+  |                             ========================================                                                                                 |
+  '------------------------------------------------------------------------------------------------------------------------------------------------------'
+
+  XTAL 1: 3.6864 MHz.
+  XTAL 2: 12.000 MHz.
+  XTAL 3: 26.000 MHz.
+  XTAL 4: 24.000 MHz.
+
+  TL: TL7705ACP
+
+
+      DSW1:          DSW2:          DSW3:          DSW4:
+   .--------.     .--------.     .--------.     .--------.
+  1| oo oooo|8   1|oooooooo|8   1|oooooooo|8   1|  o     |8    ON
+   |--------|     |--------|     |--------|     |--------|
+   |o  o    |     |        |     |        |     |oo ooooo|     OFF
+   '--------'     '--------'     '--------'     '--------'
+
+
+*******************************************************************************
+
+  *** Game Notes ***
+
+  Nothing yet...
+
+
+*******************************************************************************
+
+  ---------------------------------
+  ***  Memory Map (preliminary) ***
+  ---------------------------------
+
+  00000 - 7FFFF  ; ROM space.
+
+
+*******************************************************************************
+
+  DRIVER UPDATES:
+
+  [2012-06-11]
+
+  - Initial release.
+  - Pre-defined Xtals.
+  - Added ASCII PCB layout.
+  - Started a preliminary memory map.
+  - Added technical notes.
+
+
+  TODO:
+
+  - Improve memory map.
+  - ACRTC support.
+  - GFX decode.
+  - Sound support.
+  - A lot!.
+
+
+*******************************************************************************/
+
+
+#define MAIN_CLOCK	XTAL_12MHz
+#define SEC_CLOCK	XTAL_3.6864MHz
+#define AUX1_CLOCK	XTAL_26MHz
+#define AUX2_CLOCK	XTAL_24MHz
+
+#include "emu.h"
+#include "cpu/m68000/m68000.h"
+#include "video/hd63484.h"
+
+
+class wildpkr_state : public driver_device
+{
+public:
+	wildpkr_state(const machine_config &mconfig, device_type type, const char *tag)
+		: driver_device(mconfig, type, tag) { }
+
+};
+
+
+/*************************
+*     Video Hardware     *
+*************************/
+
+static VIDEO_START( wildpkr )
+{
+}
+
+static SCREEN_UPDATE_IND16( wildpkr )
+{
+//  wildpkr_state *state = screen.machine().driver_data<wildpkr_state>();
+	return 0;
+}
+
+static PALETTE_INIT( wildpkr )
+{
+}
+
+
+/*************************
+*      ACRTC Access      *
+*************************/
+
+
+/*************************
+*      Misc Handlers     *
+*************************/
+
+
+/*************************
+*      Memory Map        *
+*************************/
+
+static ADDRESS_MAP_START( wildpkr_map, AS_PROGRAM, 16, wildpkr_state )
+	AM_RANGE(0x00000, 0x3ffff) AM_ROM
+
+ADDRESS_MAP_END
+
+/* Unknown R/W:
+
+
+*/
+
+
+/*************************
+*      Input Ports       *
+*************************/
+
+static INPUT_PORTS_START( wildpkr )
+INPUT_PORTS_END
+
+
+/*************************
+*     Machine Start      *
+*************************/
+
+static MACHINE_START(wildpkr)
+{
+/*
+  ACRTC memory:
+
+  00000-3ffff = RAM
+  40000-7ffff = ROM
+  80000-bffff = unused
+  c0000-fffff = unused
+*/
+
+}
+
+// static const hd63484_interface wildpkr_hd63484_intf = { 1 };
+
+
+/*************************
+*    Machine Drivers     *
+*************************/
+
+static MACHINE_CONFIG_START( wildpkr, wildpkr_state )
+
+	/* basic machine hardware */
+	MCFG_CPU_ADD("maincpu", M68000, MAIN_CLOCK)
+	MCFG_CPU_PROGRAM_MAP(wildpkr_map)
+	MCFG_CPU_VBLANK_INT("screen", irq1_line_hold)	//guess
+
+	MCFG_MACHINE_START(wildpkr)
+
+	MCFG_SCREEN_ADD("screen", RASTER)
+	MCFG_SCREEN_REFRESH_RATE(60)
+	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
+	MCFG_SCREEN_SIZE(512, 512)
+	MCFG_SCREEN_VISIBLE_AREA(0, 512-1, 0, 512-1)
+	MCFG_SCREEN_UPDATE_STATIC(wildpkr)
+
+//  MCFG_HD63484_ADD("hd63484", wildpkr_hd63484_intf)
+
+	MCFG_PALETTE_INIT(wildpkr)
+	MCFG_PALETTE_LENGTH(256)
+
+	MCFG_VIDEO_START(wildpkr)
+
+MACHINE_CONFIG_END
+
+
+/*************************
+*        Rom Load        *
+*************************/
+
+ROM_START( wildpkr )
+	ROM_REGION( 0x80000, "maincpu", 0 )
+	ROM_LOAD16_BYTE( "vd_1.01_3.bin", 0x000000, 0x40000, CRC(d19d5609) SHA1(87eedb7daaa8ac33c0a73e4e849b9a0f76152261) )
+	ROM_LOAD16_BYTE( "vd_1.01_1.bin", 0x000001, 0x40000, CRC(f10644ab) SHA1(5872fe41b8c7fec5e83011abdf82a85f064b734f) )
+
+	ROM_REGION( 0x0200, "plds", 0 )
+	ROM_LOAD( "gal6v8s.bin",  0x0000, 0x0117, CRC(389c63a7) SHA1(4ebb26a001ed14a9e96dd268ed1c7f298f0c086b) )
+ROM_END
+
+
+/*************************
+*      Driver Init       *
+*************************/
+
+static DRIVER_INIT(wildpkr)
+{
+	//HD63484_start(machine);
+}
+
+
+/*************************
+*      Game Drivers      *
+*************************/
+
+/*    YEAR  NAME       PARENT    MACHINE   INPUT     INIT      ROT    COMPANY        FULLNAME                   FLAGS */
+GAME( 199?, wildpkr,   0,        wildpkr,  wildpkr,  wildpkr,  ROT0, "TAB Austria", "Wild Poker (ver. D 1.01)", GAME_NO_SOUND | GAME_NOT_WORKING )
+
diff -Nru src-old/mame/drivers/xtom3d.c src/mame/drivers/xtom3d.c
--- src-old/mame/drivers/xtom3d.c	2012-05-25 11:27:45.000000000 +0200
+++ src/mame/drivers/xtom3d.c	2012-07-02 08:20:21.000000000 +0200
@@ -549,7 +549,7 @@
 	AM_RANGE(0x01f0, 0x01f7) AM_READWRITE(ide_r, ide_w)
 	AM_RANGE(0x03f0, 0x03f7) AM_READWRITE(fdc_r, fdc_w)
 
-	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE_LEGACY("pcibus", pci_32le_r,	pci_32le_w)
+	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_bus_legacy_device, read, write)
 ADDRESS_MAP_END
 
 
@@ -694,9 +694,9 @@
 
 	MCFG_MC146818_ADD( "rtc", MC146818_STANDARD )
 
-	MCFG_PCI_BUS_ADD("pcibus", 0)
-	MCFG_PCI_BUS_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
-	MCFG_PCI_BUS_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
+	MCFG_PCI_BUS_LEGACY_ADD("pcibus", 0)
+	MCFG_PCI_BUS_LEGACY_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
+	MCFG_PCI_BUS_LEGACY_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
 
 	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL, true)
 
diff -Nru src-old/mame/includes/8080bw.h src/mame/includes/8080bw.h
--- src-old/mame/includes/8080bw.h	2012-04-11 09:56:42.000000000 +0200
+++ src/mame/includes/8080bw.h	2012-06-18 00:19:06.000000000 +0200
@@ -32,6 +32,7 @@
 	UINT8       m_screen_red;
 
 	device_t *m_speaker;
+
 	DECLARE_CUSTOM_INPUT_MEMBER(sflush_80_r);
 	DECLARE_READ8_MEMBER(indianbt_r);
 	DECLARE_WRITE8_MEMBER(steelwkr_sh_port_3_w);
@@ -57,6 +58,9 @@
 	DECLARE_WRITE8_MEMBER(yosakdon_sh_port_2_w);
 	DECLARE_WRITE8_MEMBER(shuttlei_sh_port_1_w);
 	DECLARE_WRITE8_MEMBER(shuttlei_sh_port_2_w);
+	DECLARE_READ8_MEMBER(invmulti_eeprom_r);
+	DECLARE_WRITE8_MEMBER(invmulti_eeprom_w);
+	DECLARE_WRITE8_MEMBER(invmulti_bank_w);
 };
 
 
@@ -64,12 +68,8 @@
 
 MACHINE_START( extra_8080bw_sh );
 
-
-
 extern const samples_interface lrescue_samples_interface;
 
-
-
 WRITE8_DEVICE_HANDLER( indianbt_sh_port_3_w );
 DISCRETE_SOUND_EXTERN( indianbt );
 
@@ -84,12 +84,6 @@
 DISCRETE_SOUND_EXTERN( schaser );
 
 
-
-
-
-
-
-
 /*----------- defined in video/8080bw.c -----------*/
 
 MACHINE_START( extra_8080bw_vh );
diff -Nru src-old/mame/includes/centiped.h src/mame/includes/centiped.h
--- src-old/mame/includes/centiped.h	2012-05-25 16:38:46.000000000 +0200
+++ src/mame/includes/centiped.h	2012-06-24 01:16:00.000000000 +0200
@@ -8,24 +8,30 @@
 {
 public:
 	centiped_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) ,
+		: driver_device(mconfig, type, tag),
 		m_rambase(*this, "rambase"),
 		m_videoram(*this, "videoram"),
 		m_spriteram(*this, "spriteram"),
-		m_bullsdrt_tiles_bankram(*this, "bullsdrt_bank"){ }
+		m_bullsdrt_tiles_bankram(*this, "bullsdrt_bank")
+	{ }
 
 	optional_shared_ptr<UINT8> m_rambase;
 	required_shared_ptr<UINT8> m_videoram;
 	required_shared_ptr<UINT8> m_spriteram;
 	optional_shared_ptr<UINT8> m_bullsdrt_tiles_bankram;
+
 	UINT8 m_oldpos[4];
 	UINT8 m_sign[4];
 	UINT8 m_dsw_select;
 	UINT8 m_control_select;
 	UINT8 m_flipscreen;
-	tilemap_t *m_bg_tilemap;
+	UINT8 m_prg_bank;
+	UINT8 m_gfx_bank;
 	UINT8 m_bullsdrt_sprites_bank;
 	UINT8 m_penmask[64];
+	tilemap_t *m_bg_tilemap;
+
+	// drivers/centiped.c
 	DECLARE_WRITE8_MEMBER(irq_ack_w);
 	DECLARE_READ8_MEMBER(centiped_IN0_r);
 	DECLARE_READ8_MEMBER(centiped_IN2_r);
@@ -39,16 +45,22 @@
 	DECLARE_WRITE8_MEMBER(led_w);
 	DECLARE_WRITE8_MEMBER(coin_count_w);
 	DECLARE_WRITE8_MEMBER(bullsdrt_coin_count_w);
+	DECLARE_READ8_MEMBER(caterplr_rand_r);
+	DECLARE_WRITE8_MEMBER(caterplr_AY8910_w);
+	DECLARE_READ8_MEMBER(caterplr_AY8910_r);
+	DECLARE_READ8_MEMBER(multiped_eeprom_r);
+	DECLARE_WRITE8_MEMBER(multiped_eeprom_w);
+	DECLARE_WRITE8_MEMBER(multiped_prgbank_w);
+
+	// video/centiped.c
 	DECLARE_WRITE8_MEMBER(centiped_videoram_w);
 	DECLARE_WRITE8_MEMBER(centiped_flip_screen_w);
+	DECLARE_WRITE8_MEMBER(multiped_gfxbank_w);
 	DECLARE_WRITE8_MEMBER(bullsdrt_tilesbank_w);
 	DECLARE_WRITE8_MEMBER(bullsdrt_sprites_bank_w);
 	DECLARE_WRITE8_MEMBER(centiped_paletteram_w);
 	DECLARE_WRITE8_MEMBER(milliped_paletteram_w);
 	DECLARE_WRITE8_MEMBER(mazeinv_paletteram_w);
-	DECLARE_READ8_MEMBER(caterplr_rand_r);
-	DECLARE_WRITE8_MEMBER(caterplr_AY8910_w);
-	DECLARE_READ8_MEMBER(caterplr_AY8910_r);
 };
 
 
@@ -66,5 +78,3 @@
 SCREEN_UPDATE_IND16( warlords );
 SCREEN_UPDATE_IND16( bullsdrt );
 
-
-
diff -Nru src-old/mame/includes/dec0.h src/mame/includes/dec0.h
--- src-old/mame/includes/dec0.h	2012-06-07 18:04:30.000000000 +0200
+++ src/mame/includes/dec0.h	2012-06-12 14:24:58.000000000 +0200
@@ -99,11 +99,13 @@
 SCREEN_UPDATE_IND16( baddudes );
 SCREEN_UPDATE_IND16( birdtry );
 SCREEN_UPDATE_IND16( robocop );
-SCREEN_UPDATE_IND16( automat );
 SCREEN_UPDATE_IND16( hippodrm );
 SCREEN_UPDATE_IND16( slyspy );
 SCREEN_UPDATE_IND16( midres );
 
+// bootlegs
+SCREEN_UPDATE_IND16( automat );
+SCREEN_UPDATE_IND16( secretab );
 
 /*----------- defined in machine/dec0.c -----------*/
 
diff -Nru src-old/mame/includes/dynax.h src/mame/includes/dynax.h
--- src-old/mame/includes/dynax.h	2012-05-25 16:38:46.000000000 +0200
+++ src/mame/includes/dynax.h	2012-06-11 21:54:22.000000000 +0200
@@ -415,6 +415,11 @@
 	DECLARE_WRITE8_MEMBER(tenkai_dswsel_w);
 	DECLARE_READ8_MEMBER(tenkai_dsw_r);
 	DECLARE_WRITE_LINE_MEMBER(tenkai_rtc_irq);
+	DECLARE_WRITE8_MEMBER(janshinp_coincounter_w);
+	DECLARE_READ8_MEMBER(seljan2_busy_r);
+	DECLARE_WRITE8_MEMBER(seljan2_rombank_w);
+	DECLARE_WRITE8_MEMBER(seljan2_palette_enab_w);
+	DECLARE_WRITE8_MEMBER(seljan2_palette_w);
 };
 
 //----------- defined in drivers/dynax.c -----------
diff -Nru src-old/mame/includes/eolith.h src/mame/includes/eolith.h
--- src-old/mame/includes/eolith.h	2012-04-09 15:23:05.000000000 +0200
+++ src/mame/includes/eolith.h	2012-07-02 09:06:11.000000000 +0200
@@ -3,22 +3,35 @@
 public:
 	eolith_state(const machine_config &mconfig, device_type type, const char *tag)
 		:	driver_device(mconfig, type, tag),
-			m_maincpu(*this,"maincpu")
+			m_maincpu(*this, "maincpu"),
+			m_soundcpu(*this, "soundcpu")
 			{ }
 
 	int m_coin_counter_bit;
 	int m_buffer;
 	UINT32 *m_vram;
 
+	UINT8 m_sound_data;
+	UINT8 m_data_to_qs1000;
+
 	required_device<cpu_device> m_maincpu;
+	optional_device<cpu_device> m_soundcpu;
+
 	DECLARE_READ32_MEMBER(eolith_custom_r);
 	DECLARE_WRITE32_MEMBER(systemcontrol_w);
+	DECLARE_WRITE32_MEMBER(sound_w);
 	DECLARE_READ32_MEMBER(hidctch3_pen1_r);
 	DECLARE_READ32_MEMBER(hidctch3_pen2_r);
 	DECLARE_WRITE32_MEMBER(eolith_vram_w);
 	DECLARE_READ32_MEMBER(eolith_vram_r);
 	DECLARE_CUSTOM_INPUT_MEMBER(eolith_speedup_getvblank);
 	DECLARE_CUSTOM_INPUT_MEMBER(stealsee_speedup_getvblank);
+
+	DECLARE_READ8_MEMBER(sound_cmd_r);
+	DECLARE_WRITE8_MEMBER(sound_p1_w);
+
+	DECLARE_READ8_MEMBER(qs1000_p1_r);
+	DECLARE_WRITE8_MEMBER(qs1000_p1_w);
 };
 
 
diff -Nru src-old/mame/includes/mw8080bw.h src/mame/includes/mw8080bw.h
--- src-old/mame/includes/mw8080bw.h	2012-04-16 00:00:24.000000000 +0200
+++ src/mame/includes/mw8080bw.h	2012-06-18 00:19:06.000000000 +0200
@@ -35,11 +35,14 @@
 {
 public:
 	mw8080bw_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) ,
+		: driver_device(mconfig, type, tag),
+		m_maincpu(*this,"maincpu"),
 		m_main_ram(*this, "main_ram"),
-		m_colorram(*this, "colorram"){ }
+		m_colorram(*this, "colorram")
+	{ }
 
-	/* memory pointers */
+	/* device/memory pointers */
+	required_device<cpu_device> m_maincpu;
 	required_shared_ptr<UINT8> m_main_ram;
 	optional_shared_ptr<UINT8> m_colorram;
 
@@ -66,8 +69,7 @@
 	/* timer */
 	emu_timer   *m_interrupt_timer;
 
-	/* devices */
-	device_t *m_maincpu;
+	/* other devices */
 	device_t *m_mb14241;
 	samples_device *m_samples;
 	samples_device *m_samples1;
@@ -76,6 +78,7 @@
 	device_t *m_sn2;
 	device_t *m_sn;
 	device_t *m_discrete;
+
 	DECLARE_READ8_MEMBER(mw8080bw_shift_result_rev_r);
 	DECLARE_READ8_MEMBER(mw8080bw_reversable_shift_result_r);
 	DECLARE_WRITE8_MEMBER(mw8080bw_reversable_shift_count_w);
@@ -140,7 +143,9 @@
 #define INVADERS_CAB_TYPE_PORT_TAG		("CAB")
 #define INVADERS_P1_CONTROL_PORT_TAG	("CONTP1")
 #define INVADERS_P2_CONTROL_PORT_TAG	("CONTP2")
-
+#define INVADERS_COIN_INPUT_PORT_TAG	("COIN")
+#define INVADERS_SW6_SW7_PORT_TAG		("SW6SW7")
+#define INVADERS_SW5_PORT_TAG			("SW5")
 
 #define BLUESHRK_SPEAR_PORT_TAG			("IN0")
 
diff -Nru src-old/mame/includes/pacman.h src/mame/includes/pacman.h
--- src-old/mame/includes/pacman.h	2012-05-12 17:12:33.000000000 +0200
+++ src/mame/includes/pacman.h	2012-06-19 18:12:49.000000000 +0200
@@ -9,14 +9,17 @@
 public:
 	pacman_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		  m_spriteram(*this, "spriteram"),
-		  m_spriteram2(*this, "spriteram2"),
-		  m_s2650_spriteram(*this, "s2650_spriteram") ,
+		m_maincpu(*this, "maincpu"),
+		m_spriteram(*this, "spriteram"),
+		m_spriteram2(*this, "spriteram2"),
+		m_s2650_spriteram(*this, "s2650_spriteram"),
 		m_videoram(*this, "videoram"),
 		m_colorram(*this, "colorram"),
 		m_s2650games_tileram(*this, "s2650_tileram"),
-		m_rocktrv2_prot_data(*this, "rocktrv2_prot"){ }
+		m_rocktrv2_prot_data(*this, "rocktrv2_prot")
+	{ }
 
+	required_device<cpu_device> m_maincpu;
 	optional_shared_ptr<UINT8> m_spriteram;
 	optional_shared_ptr<UINT8> m_spriteram2;
 	optional_shared_ptr<UINT8> m_s2650_spriteram;
@@ -97,6 +100,7 @@
 	DECLARE_WRITE8_MEMBER(jrpacman_spritebank_w);
 	DECLARE_WRITE8_MEMBER(jrpacman_scroll_w);
 	DECLARE_WRITE8_MEMBER(jrpacman_bgpriority_w);
+	DECLARE_WRITE8_MEMBER(superabc_bank_w);
 };
 
 
@@ -106,21 +110,13 @@
 VIDEO_START( pacman );
 SCREEN_UPDATE_IND16( pacman );
 
-
-
 VIDEO_START( pengo );
 
-
-
 VIDEO_START( s2650games );
 SCREEN_UPDATE_IND16( s2650games );
 
-
-
-
 VIDEO_START( jrpacman );
 
-
 VIDEO_START( birdiy );
 
 
diff -Nru src-old/mame/machine/cd32.c src/mame/machine/cd32.c
--- src-old/mame/machine/cd32.c	2011-07-21 15:19:08.000000000 +0200
+++ src/mame/machine/cd32.c	2012-06-21 04:35:51.000000000 +0200
@@ -112,7 +112,7 @@
 	else
 	{
 		// MAME case
-		state->m_cdrom = cdrom_open(get_disk_handle(machine, "cdrom"));
+		state->m_cdrom = cdrom_open(get_disk_handle(machine, ":cdrom"));
 		state->m_cdrom_is_device = 0;
 	}
 
diff -Nru src-old/mame/machine/decocass.c src/mame/machine/decocass.c
--- src-old/mame/machine/decocass.c	2012-05-20 04:28:25.000000000 +0200
+++ src/mame/machine/decocass.c	2012-06-22 05:32:50.000000000 +0200
@@ -1563,6 +1563,17 @@
 	state->m_dongle_w = decocass_type2_w;
 }
 
+MACHINE_RESET( cfishing )
+{
+	decocass_state *state = machine.driver_data<decocass_state>();
+	decocass_reset_common(machine);
+	LOG(0,("dongle type #3 (PAL)\n"));
+	state->m_dongle_r = decocass_type3_r;
+	state->m_dongle_w = decocass_type3_w;
+	state->m_type3_swap = TYPE3_SWAP_01;
+
+}
+
 MACHINE_RESET( cbtime )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
@@ -1571,6 +1582,7 @@
 	state->m_dongle_r = decocass_type3_r;
 	state->m_dongle_w = decocass_type3_w;
 	state->m_type3_swap = TYPE3_SWAP_12;
+
 }
 
 MACHINE_RESET( cburnrub )
diff -Nru src-old/mame/machine/decocass.h src/mame/machine/decocass.h
--- src-old/mame/machine/decocass.h	2012-05-22 18:40:44.000000000 +0200
+++ src/mame/machine/decocass.h	2012-06-22 05:32:50.000000000 +0200
@@ -148,6 +148,7 @@
 MACHINE_RESET( ctsttape );
 MACHINE_RESET( chwy );
 MACHINE_RESET( cdsteljn );
+MACHINE_RESET( cfishing );
 MACHINE_RESET( cterrani );
 MACHINE_RESET( castfant );
 MACHINE_RESET( csuperas );
diff -Nru src-old/mame/machine/mw8080bw.c src/mame/machine/mw8080bw.c
--- src-old/mame/machine/mw8080bw.c	2012-02-19 03:53:16.000000000 +0100
+++ src/mame/machine/mw8080bw.c	2012-06-18 00:19:06.000000000 +0200
@@ -100,7 +100,6 @@
 
 	mw8080bw_create_interrupt_timer(machine);
 
-	state->m_maincpu = machine.device("maincpu");
 	state->m_samples = machine.device<samples_device>("samples");
 	state->m_samples1 = machine.device<samples_device>("samples1");
 	state->m_samples2 = machine.device<samples_device>("samples2");
diff -Nru src-old/mame/machine/tx1.c src/mame/machine/tx1.c
--- src-old/mame/machine/tx1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/tx1.c	2012-06-23 21:11:14.000000000 +0200
@@ -804,7 +804,7 @@
 READ16_MEMBER(tx1_state::tx1_spcs_rom_r)
 {
 	math_t &math = m_math;
-	math.cpulatch = *(UINT16*)((UINT8*)machine().root_device().memregion("math_cpu")->base() + 0xfc000 + 0x1000 + offset*2);
+	math.cpulatch = *(UINT16*)((UINT8*)machine().root_device().memregion("math_cpu")->base() + 0x04000 + 0x1000 + offset*2);
 
 	if (math.mux == TX1_SEL_ILDEN)
 	{
@@ -1266,7 +1266,7 @@
 READ16_MEMBER(tx1_state::buggyboy_spcs_rom_r)
 {
 	math_t &math = m_math;
-	math.cpulatch = *(UINT16*)((UINT8*)machine().root_device().memregion("math_cpu")->base() + 0xfc000 + 0x1000 + offset*2);
+	math.cpulatch = *(UINT16*)((UINT8*)machine().root_device().memregion("math_cpu")->base() + 0x04000 + 0x1000 + offset*2);
 
 	if (math.mux == BB_MUX_ILDEN)
 	{
diff -Nru src-old/mame/mame.lst src/mame/mame.lst
--- src-old/mame/mame.lst	2012-06-11 01:55:51.000000000 +0200
+++ src/mame/mame.lst	2012-06-29 23:55:18.000000000 +0200
@@ -122,12 +122,13 @@
 mschamp			// hack by RAYGLO MFG "Zola-Puc" (c) 1992/1993
 mschamps		// hack (hack of the Rayglo hack?)
 cannonbp		// hack
+superabc		// hack
+superabco		// hack
 
 // S2650 Pacman Kits
 drivfrcp		// (c) 1984 Shinkai Inc. (Magic Eletronics Inc. license)
 8bpm			// (c) 1985 Seatongrove Ltd (Magic Eletronics USA license)
 porky			// (c) 1985 Shinkai Inc. (Magic Eletronics Inc. license)
-
 pengo			// 834-0386 (c) 1982 Sega
 pengo2			// 834-0386 (c) 1982 Sega
 pengo2u			// 834-0386 (c) 1982 Sega
@@ -136,7 +137,6 @@
 pengob			// bootleg
 penta			// bootleg
 jrpacmbl		// bootleg on Pengo HW
-
 jrpacman		// (c) 1983 Midway
 
 // Epos games
@@ -183,6 +183,7 @@
 skyraidr		// bootleg
 batman2			// bootleg
 warofbug		// (c) 1981 Armenia
+warofbugu		// (c) 1981 Armenia
 warofbugg		// German Version
 redufo			// (c) Artic
 redufob			// bootleg
@@ -382,19 +383,16 @@
 cclimberj		// (c) 1980 Nichibutsu
 ccboot			// bootleg
 ccboot2			// bootleg
-
 ckong			// (c) 1981 (Kyoei)
 ckongo			// bootleg (Orca)
 ckongalc		// bootleg (Alca)
 bigkong			// bootleg
 monkeyd			// bootleg
-
 ckongpt2		// (c) 1981 Falcon
 ckongpt2a		// (c) 1981 Falcon
 ckongpt2j		// (c) 1981 Falcon
 ckongpt2jeu		// bootleg (Jeutel)
 ckongpt2b		// bootleg
-
 rpatrol			// Orca, from a suspicious set
 rpatrolb		// bootleg
 silvland		// Falcon
@@ -472,7 +470,6 @@
 // Nichibutsu Mahjong games
 hyhoo			// (c) 1987
 hyhoo2			// (c) 1987
-
 jangou			// (c) 1983
 macha			// (c) 1983 Logitec
 // Jangou Night // (c) 1983
@@ -489,11 +486,9 @@
 sexygal			// (c) 1985
 sweetgal		// (c) 1985
 ngalsumr		// (c) 1985
-
 pastelg			// (c) 1985
-3ds				// (c) 1985
+3ds			// (c) 1985
 galds			// (c) 1985
-
 crystalg		// (c) 1986
 crystal2		// (c) 1986
 nightlov		// (c) 1986
@@ -533,7 +528,6 @@
 mmsikaku		// (c) 1988
 mjcamera		// (c) 1988 MIKI SYOUJI
 mmcamera		// (c) 1988 MIKI SYOUJI
-
 msjiken			// (c) 1988
 hanamomo		// (c) 1988
 hanamomb		// (c) 1988
@@ -567,7 +561,6 @@
 club90sa		// (c) 1990
 lovehous		// (c) 1990
 hanaoji			// (c) 1991
-
 pstadium		// (c) 1990
 triplew1		// (c) 1989
 triplew2		// (c) 1990
@@ -586,10 +579,8 @@
 uchuuai			// (c) 1989
 av2mj1bb		// (c) 1991 MIKI SYOUJI/AV JAPAN
 av2mj2rg		// (c) 1991 MIKI SYOUJI/AV JAPAN
-
 ohpaipee		// (c) 1990 Nichibutsu
 togenkyo		// (c) 1990 Nichibutsu
-
 mjuraden		// (c) 1992 Nichibutsu/Yubis
 koinomp			// (c) 1992
 patimono		// (c) 1992
@@ -621,15 +612,12 @@
 imekura			// (c) 1994 SPHINX/AV JAPAN
 mscoutm			// (c) 1994 SPHINX/AV JAPAN
 mjegolf			// (c) 1994 FUJIC/AV JAPAN
-
 mhhonban		// (c) 199?
 zokumahj		// (c) 199?
 4psimasy		// (c) 1994
 musobana		// (c) 1995
 niyanpai		// (c) 1996
-
 csplayh1		// (c) 1995
-
 junai			// (c) 1998
 csplayh5		// (c) 1998
 junai2			// (c) 1998
@@ -675,8 +663,6 @@
 trvmstrc		// (c) 1985 Enerdyne Technologies Inc.
 trvgns			// bootleg
 
-
-
 // Namco games (plus some intruders on similar hardware)
 geebee			// [1978] Namco
 geebeeb			// [1978] Namco (F.lli Bertolino license)
@@ -686,7 +672,7 @@
 navarone		// (c) 1980 Namco
 kaitein			// [1980] Namco
 kaitei			// [1980] K.K. Tokki
-sos				// [1980] Namco
+sos			// [1980] Namco
 tankbatt		// (c) 1980 Namco
 warpwarp		// (c) 1981 Namco
 warpwarpr		// (c) 1981 [Namco] (Rock-ola license)
@@ -816,7 +802,7 @@
 pacmaniaj		// (c) 1987 (Japan)
 galaga88		// (c) 1987
 galaga88j		// (c) 1987 (Japan)
-ws				// (c) 1988 (Japan)
+ws			// (c) 1988 (Japan)
 berabohm		// (c) 1988 (Japan)
 berabohmo		// (c) 1988 (Japan)
 				// 1988 Alice in Wonderland (English version of Marchen maze)
@@ -888,7 +874,7 @@
 luckywldj		// (c) 1992
 suzuka8h		// (c) 1992 (World)
 suzuka8hj		// (c) 1992 (Japan)
-sws				// (c) 1992 (Japan)
+sws			// (c) 1992 (Japan)
 sws92			// (c) 1992 (Japan)
 sws92g			// (c) 1992 (Japan)
 suzuk8h2		// (c) 1993 (World)
@@ -907,7 +893,7 @@
 exvania			// (c) 1992 (World)
 exvaniaj		// (c) 1992 (Japan)
 fghtatck		// (c) 1992 (US)
-fa				// (c) 1992 (Japan)
+fa			// (c) 1992 (Japan)
 knckhead		// (c) 1992 (World)
 knckheadj		// (c) 1992 (Japan)
 swcourt			// (c) 1992 (Japan)
@@ -1317,8 +1303,6 @@
 pss63			// 199? Nintendo / BPS
 pss64			// 199? Nintendo / Hudson Soft
 
-
-
 // SNES-based hacks
 kinstb			// bootleg
 ffight2b		// bootleg
@@ -1327,7 +1311,6 @@
 endless			// bootleg
 denseib			// bootleg
 
-
 // Midway 8080 b/w games
 seawolf			// 596 [1976]
 seawolfo		// 596 [1976]
@@ -1436,7 +1419,16 @@
 astropal		// (c) 19?? Sidam
 cosmo			// TDS & Mints
 darthvdr		// bootleg
-
+invmulti		// hack
+invmultim3a		// hack
+invmultim2c		// hack
+invmultim2a		// hack
+invmultim1a		// hack
+invmultit3d		// hack
+invmultis3a		// hack
+invmultis2a		// hack
+invmultis1a		// hack
+invmultip		// hack
 18w				// 653 (c) 1979 Midway
 18w2			// 653 (c) 1979 Midway
 sspeedr			// 1979 Midway
@@ -1597,13 +1589,11 @@
 skychut			// Irem [1980]
 spacbeam		// M15 no copyright notice
 greenber		// Irem
-headoni			// Irem no copyright notice (1979 - Arcade TV Game List - P.98, Left, 7 from top
-
+headoni			// Irem no copyright notice (1979 - Arcade TV Game List - P.98, Left, 7 from top)
 panther			// M27 no copyright notice
 redalert		// M27 (c) 1981 + "GDI presents"
 demoneye		// M27 (c) 1981
-ww3				// M27 (c) 1981
-
+ww3			// M27 (c) 1981
 olibochu		// M47 (c) 1981 + "GDI presents"
 mpatrol			// M52 (c) 1982
 mpatrolw		// M52 (c) 1982 + Williams license
@@ -1862,7 +1852,7 @@
 fightrol		// (c) 1983 Taito
 rollace			// (c) 1983 Williams
 rollace2		// (c) 1983 Williams
-lgp				// (c) 1983 Taito
+lgp			// (c) 1983 Taito
 vsgongf			// (c) 1984 Kaneko
 ringfgt			// (c) 1984 Taito
 ringfgt2		// (c) 1984 Taito
@@ -1961,6 +1951,7 @@
 arkanoidj		// A75 (c) 1986 Taito Corporation (Japan)
 arkanoidjo		// A75 (c) 1986 Taito Corporation (Japan)
 arkanoidjb		// bootleg
+arkanoidjb2		// bootleg (Beta)
 ark1ball		// bootleg
 arkangc			// bootleg
 arkangc2		// bootleg
@@ -2111,7 +2102,8 @@
 syvalion		// B51 (c) 1988 Taito Corporation (Japan)
 recordbr		// B56 (c) 1988 Taito Corporation Japan (World)
 gogold			// B56 (c) 1988 Taito Corporation (Japan)
-dleague			// C02 (c) 1990 Taito Corporation (Japan)
+dleague			// C02 (c) 1990 Taito America Corporation (US)
+dleaguej		// C02 (c) 1990 Taito Corporation (Japan)
 
 // Taito B-System games
 masterw			// B72 (c) 1989 Taito Corporation Japan (World)
@@ -2136,7 +2128,7 @@
 ashurau			// C43 (c) 1990 Taito America Corporation (US)
 hitice			// C59 (c) 1990 Williams (US)
 hiticej			// C59 (c) 1990 Midway/Taito Corporation (Japan)
-sbm				// C69 (c) 1990 Taito Corporation (Japan)
+sbm			// C69 (c) 1990 Taito Corporation (Japan)
 selfeena		// ??? (c) 1991 East Technology
 silentd			// ??? (c) 1992 Taito Corporation Japan (World)
 silentdu		// ??? (c) 1992 Taito Corporation Japan (World)
@@ -2160,7 +2152,7 @@
 nightstr		// B91 (c) 1989 Taito Corporation Japan (World)
 nightstrj		// B91 (c) 1989 Taito Corporation (Japan)
 nightstru		// B91 (c) 1989 Taito America Corporation (US)
-sci				// C09 (c) 1989 Taito Corporation Japan (World)
+sci			// C09 (c) 1989 Taito Corporation Japan (World)
 scia			// C09 (c) 1989 Taito Corporation Japan (World)
 scij			// C09 (c) 1989 Taito Corporation Japan (World)
 sciu			// C09 (c) 1989 Taito America Corporation (US)
@@ -2182,7 +2174,6 @@
 // Taito Air System games
 topland			// B62 (c) 1988 Taito Coporation Japan (World)
 ainferno		// C45 (c) 1990 Taito America Corporation (US)
-
 mlanding		// ??? (c) 1990 Taito America Corporation (US)
 
 // enhanced Z-System hardware games
@@ -2219,7 +2210,7 @@
 liquidku		// 1990.?? C49 (c) 1990 Taito America Corporation (US)
 mizubaku		// 1990.08 C49 (c) 1990 Taito Corporation (Japan)
 quizhq			// 1990.07 C53 (c) 1990 Taito Corporation (Japan)
-ssi				// 1990.?? C64 (c) 1990 Taito Corporation Japan (World)
+ssi			// 1990.?? C64 (c) 1990 Taito Corporation Japan (World)
 ssia			// 1990.?? C64 (c) 1990 Taito Corporation Japan (World)
 majest12		// 1990.11 C64 (c) 1990 Taito Corporation (Japan)
 				// 1990.12 C64 (US)
@@ -2394,7 +2385,6 @@
 gtstarb1		// GX-006 bootleg but (c) 1986 Taito Corporation
 gtstarb2		// GX-006 bootleg but (c) 1986 Taito Corporation
 mjsister		// (c) 1986 Toaplan
-
 fshark			// B02 / TP-007 (c) 1987 Taito Corporation (World)
 skyshark		// B02 / TP-007 (c) 1987 Taito America Corporation + Romstar license (US)
 hishouza		// B02 / TP-007 (c) 1987 Taito Corporation (Japan)
@@ -2407,7 +2397,6 @@
 twincobru		// B30 / TP-011 (c) 1987 Taito America Corporation + Romstar license (US)
 ktiger			// B30 / TP-011 (c) 1987 Taito Corporation (Japan)
 gulfwar2		// (c) 1991 Comad
-
 rallybik		// B45 / TP-O12 (c) 1988 Taito
 truxton			// B65 / TP-O13B (c) 1988 Taito
 hellfire		// B90 / TP-??? (c) 1989 Toaplan + Taito license
@@ -2459,7 +2448,6 @@
 moremorp		// (c) 1999 SemiCom + Exit
 4in1boot		// (c) 2002 KISoft (includes hacks of Semicom games + Snowbros)
 
-
 // More Toaplan Games
 tekipaki		// TP-020 (c) 1991 Toaplan
 ghox			// TP-021 (c) 1991 Toaplan
@@ -2475,19 +2463,19 @@
 whoopee			// TP-025
 pipibibsbl		// (c) 1991 Ryouta Kikaku (bootleg)
 fixeight		// TP-026 (c) 1992 + Taito license
-fixeightt
-fixeightkt
-fixeightk
-fixeightht
-fixeighth
-fixeighttwt
-fixeighttw
-fixeightat
-fixeighta
-fixeightu
-fixeightut
-fixeightj
-fixeightjt
+fixeightt		// TP-026 (c) 1992 + Taito license
+fixeightkt		// TP-026 (c) 1992 + Taito license
+fixeightk		// TP-026 (c) 1992 + Taito license
+fixeightht		// TP-026 (c) 1992 + Taito license
+fixeighth		// TP-026 (c) 1992 + Taito license
+fixeighttwt		// TP-026 (c) 1992 + Taito license
+fixeighttw		// TP-026 (c) 1992 + Taito license
+fixeightat		// TP-026 (c) 1992 + Taito license
+fixeighta		// TP-026 (c) 1992 + Taito license
+fixeightu		// TP-026 (c) 1992 + Taito license
+fixeightut		// TP-026 (c) 1992 + Taito license
+fixeightj		// TP-026 (c) 1992 + Taito license
+fixeightjt		// TP-026 (c) 1992 + Taito license
 fixeightbl		// bootleg
 grindstm		// TP-027 (c) 1993 Toaplan + Unite Trading license (Korea)
 grindstma		// TP-027 (c) 1993 Toaplan + Unite Trading license (Korea)
@@ -2628,7 +2616,7 @@
 flashgal		// (c) 1985 Sega
 flashgala		// (c) 1985 Sega
 srdmissn		// (c) 1986 Taito Corporation
-fx				// bootleg
+fx			// bootleg
 legend			// no copyright notice [1986 Sega/Coreland] (Arcade TV Game List - P.104, Left, 14 from top)
 legendb			// no copyright notice [1986 Sega/Coreland] (Arcade TV Game List - P.104, Left, 14 from top)
 airwolf			// (c) 1987 Kyugo
@@ -2706,7 +2694,7 @@
 commandob		// bootleg
 sinvasn			// Europe original?
 sinvasnb		// bootleg
-gng				//  9/1985 (c) 1985
+gng			//  9/1985 (c) 1985
 gnga			//  9/1985 (c) 1985
 gngbl			// bootleg
 gngblita		// bootleg
@@ -2760,13 +2748,13 @@
 blktigerb2		// bootleg
 blkdrgon		//  8/1987 (c) 1987 (Japan)
 blkdrgonb		// bootleg, hacked to say Black Tiger
-sf				//  8/1987 (c) 1987 (World)
-sfu				//  8/1987 (c) 1987 (US)
+sf			//  8/1987 (c) 1987 (World)
+sfu			//  8/1987 (c) 1987 (US)
 sfua			//  8/1987 (c) 1987 (US)
-sfj				//  8/1987 (c) 1987 (Japan)
-sfp				//  8/1987 (c) 1987
+sfj			//  8/1987 (c) 1987 (Japan)
+sfp			//  8/1987 (c) 1987
 tigeroad		// 11/1987 (c) 1987 + Romstar (US)
-toramich		// 11/1987 (c) 1987 (Japan)
+toramich		// 11/1987 (c) 1987 (Japan
 tigeroadb		// bootleg
 f1dream			//  4/1988 (c) 1988 + Romstar
 f1dreamb		// bootleg
@@ -2791,7 +2779,6 @@
 // 10/1991 Block Block - see below among "Mitchell" games
 //  6/1995 Street Fighter - the Movie - see below among "Incredible Technologies" games
 
-
 // Capcom CPS1 games
 forgottn		//  7/1988 (c) 1988 (World)
 forgottnu		//  7/1988 (c) 1988 (USA)
@@ -2845,7 +2832,7 @@
 cawingr1		// 09/10/1990 (c) 1990 (World)
 cawingu			// 12/10/1990 (c) 1990 (USA)
 cawingj			// 12/10/1990 (c) 1990 (Japan)
-cawingbl
+cawingbl		// bootleg
 nemo			// 30/11/1990 (c) 1990 (World)
 nemoj			// 20/11/1990 (c) 1990 (Japan)
 sf2			// 22/05/1991 (c) 1991 (World)
@@ -2958,7 +2945,6 @@
 megaman			// 06/10/1995 (c) 1995 (USA)
 megamana		// 06/10/1995 (c) 1995 (Asia)
 rockmanj		// 22/09/1995 (c) 1995 (Japan)
-
 fcrash			// bootleg of Final Fight
 
 // Capcom CPS2 games
@@ -3046,7 +3032,7 @@
 cybots			// 24/04/1995 (c) 1995 (Euro)
 cybotsu			// 24/04/1995 (c) 1995 (USA)
 cybotsj			// 20/04/1995 (c) 1995 (Japan)
-sfa				// 27/07/1995 (c) 1995 (Euro)
+sfa			// 27/07/1995 (c) 1995 (Euro)
 sfar1			// 18/07/1995 (c) 1995 (Euro)
 sfar2			// 27/06/1995 (c) 1995 (Euro)
 sfar3			// 05/06/1995 (c) 1995 (Euro)
@@ -3061,7 +3047,7 @@
 sfzbr1			// 27/07/1995 (c) 1995 (Brazil)
 mmancp2u		// 06/10/1995 (c) 1995 (Japan)
 rmancp2j		// 22/09/1995 (c) 1995 (Japan)
-msh				// 24/10/1995 (c) 1995 (Euro)
+msh			// 24/10/1995 (c) 1995 (Euro)
 mshu			// 24/10/1995 (c) 1995 (USA)
 mshj			// 17/11/1995 (c) 1995 (Japan)
 mshjr1			// 24/10/1995 (c) 1995 (Japan)
@@ -3266,7 +3252,6 @@
 sfiii3ur1		// 12/05/1999 (c) 1999 (USA)
 jojoba			// 27/09/1999 (c) 1999 (Japan)
 jojobar1		// 13/09/1999 (c) 1999 (Japan)
-
 sfiiin			// 04/02/1997 (c) 1997 (Asia)
 sfiii2n			// 30/09/1997 (c) 1997 (Asia)
 jojon			// 28/01/1999 (c) 1998 (Asia)
@@ -3611,7 +3596,7 @@
 drmn2m			// 1999 - DrumMania 2nd Mix (GE912 VER. JAB)
 drmn2mpu		// 1999 - DrumMania 2nd Mix Session Power Up Kit (GE912 VER. JAB)
 dncfrks			// 2000 - Dance Freaks (G*874 VER. KAA)
-dmx				// 2000 - Dance Maniax (G*874 VER. JAA)
+dmx			// 2000 - Dance Maniax (G*874 VER. JAA)
 gunmania		// 2000 - GunMania (GL906 VER. JAA)
 fghtmn			// 2000 - Fighting Mania (QG918 VER. EAA)
 fghtmna			// 2000 - Fighting Mania (QG918 VER. AAA)
@@ -3671,6 +3656,7 @@
 bmiidxc
 bmiidxca
 bmiidxc2
+bmiidx2
 bmiidx3
 bmiidx4
 bmiidx6
@@ -3756,7 +3742,7 @@
 stratab			// (c) 1990 Strata/Incredible Technologies
 stratab1		// (c) 1990 Strata/Incredible Technologies
 sstrike			// (c) 1990 Strata/Incredible Technologies
-gtg				// (c) 1990 Strata/Incredible Technologies
+gtg			// (c) 1990 Strata/Incredible Technologies
 gtgt			// (c) 1990 Strata/Incredible Technologies
 gtgt1			// (c) 1990 Strata/Incredible Technologies
 hstennis		// (c) 1990 Strata/Incredible Technologies
@@ -3810,7 +3796,6 @@
 shufshot139		// (c) Strata/Incredible Technologies
 shufshot137		// (c) Strata/Incredible Technologies
 wcbowldx		// (c) 1999 Incredible Technologies
-
 gt3d			// (c) 1995 Incredible Technologies
 gt3dl192		// (c) 1995 Incredible Technologies
 gt3dl191		// (c) 1995 Incredible Technologies
@@ -3876,7 +3861,7 @@
 ataxxa			// (c) 1990 Leland
 ataxxe			// (c) 1990 Leland
 ataxxj			// (c) 1990 Leland
-wsf				// (c) 1990 Leland
+wsf			// (c) 1990 Leland
 indyheat		// (c) 1991 Leland
 brutforc		// (c) 1991 Leland
 asylum			// (c) 1991 Leland
@@ -3957,7 +3942,7 @@
 astrob2a		// (c) 1981
 astrob1			// (c) 1981
 astrobg			// (c) 1981
-005				// (c) 1981
+005			// (c) 1981
 monsterb		// (c) 1982
 monsterb2		// (c) 1982
 spaceod			// (c) 1981
@@ -4054,7 +4039,7 @@
 wboysys2		// 834-5984  (c) 1986 + Escape license (S1)
 gardia			// 834-6119 (S2?)
 gardiab			// bootleg
-nob				// (c) Data East
+nob			// (c) Data East
 nobb			// bootleg
 blockgal		// 834-6303 (S1)
 blockgalb		// bootleg
@@ -4145,13 +4130,13 @@
 // System 16A
 aceattaca		// (c) 1988 (FD1094, decrypted)
 afighter		// (c) 1986 (FD1089A, decrypted)
-alexkidd		// (c) 1986 (FD1089A, decrypted)
-alexkidd1		// (c) 1986
+alexkidd		// (c) 1986 (Unprotected)
+alexkidd1		// (c) 1986 (FD1089A, decrypted)
 fantzone		// (c) 1986 (Unprotected Rev A)
 fantzone1		// (c) 1986 (Unprotected)
 fantzonep		// (c) 1986 (NEC 0317-5000, encrypted)
 sdi				// (c) 1987 (FD1089B, decrypted)
-shinobi			// (c) 1987
+shinobi			// (c) 1987 (Unprotected)
 shinobi1		// (c) 1987 (FD1094, decrypted)
 shinobls		// (c) 1987 (Star bootleg)
 sjryuko1		// (c) 1988 White Board (FD1089B, decrypted)
@@ -4161,11 +4146,11 @@
 wb31			// (c) 1988 Sega / Westone (FD1094, decrypted)
 wb35			// (c) 1988 Sega / Westone (FD1089A, decrypted)
 wb35a			// (c) 1988 Sega / Westone (FD1089A, decrypted)
-passsht16a		// (c) 1988
+passsht16a		// (c) 1988 (FD1094, decrypted)
 
 // System 16B
 aceattac		// (c) 1988 (protected)
-aliensyn		// (c) 1987
+aliensyn		// (c) 1987 (Unprotected)
 aliensyn3		// (c) 1987 (FD1089A, decrypted)
 aliensynj		// (c) 1987 (FD1089A, decrypted)
 altbeast		// (c) 1988 (8751)
@@ -4182,7 +4167,7 @@
 bayroute		// (c) 1989 Sunsoft / Sega (FD1094, decrypted)
 bayroutej		// (c) 1989 Sunsoft / Sega (FD1094, decrypted)
 bayroute1		// (c) 1989 Sunsoft / Sega
-bullet			// (c) 1987 (protected)
+bullet			// (c) 1987 (FD1094, decrypted)
 cotton			// (c) 1990 (FD1094, decrypted)
 cottonu			// (c) 1990 (FD1094, decrypted)
 cottonj			// (c) 1990 (FD1094, decrypted)
@@ -4192,38 +4177,38 @@
 eswat			// (c) 1989 (FD1094, decrypted)
 eswatu			// (c) 1989 (FD1094, decrypted)
 eswatj			// (c) 1989 (FD1094, decrypted)
-exctleag		// (protected)
+exctleag		// (c) 1988 (FD1094, decrypted)
 fpoint			// (c) 1989 (Japan, FD1094, decrypted)
 fpoint1			// (c) 1989 (Japan, FD1094, decrypted)
 goldnaxe		// (c) 1989 (8751)
-goldnaxeu		// (c) 1989 (protected)
+goldnaxeu		// (c) 1989 (FD1094, decrypted)
 goldnaxej		// (c) 1989 (FD1094, decrypted)
 goldnaxe3		// (c) 1989 (FD1094, decrypted)
 goldnaxe2		// (c) 1989 (8751)
 goldnaxe1		// (c) 1989 (FD1094, decrypted)
-hwchamp			// (c) 1987
+hwchamp			// (c) 1987 (Unprotected)
 hwchampj		// (c) 1987 (FD1094, decrypted)
 mvp				// (c) 1989 (FD1094, decrypted)
 mvpj			// (c) 1989 (FD1094, decrypted)
 passsht			// (c) 1988 (FD1094, decrypted)
 passshta		// (c) 1988 (FD1094, decrypted)
 passshtj		// (c) 1988 (FD1094, decrypted)
-riotcity		// (c) 1991 Sega / Westone
+riotcity		// (c) 1991 Sega / Westone (Unprotected)
 ryukyu			// (c) 1990 (FD1094, decrypted)
 sdib			// (c) 1987 (FD1089A, decrypted)
 sdibl			// (c) 1987 bootleg
 defense			// (c) 1987 (FD1094, decrypted)
-shinobi5		// (c) 1987
+shinobi5		// (c) 1987 (Unprotected)
 shinobi4		// (c) 1987 (MC-8123B)
 shinobi3		// (c) 1987 (MC-8123B)
 shinobi2		// (c) 1987 (FD1094, decrypted)
 sonicbom		// (c) 1987 (FD1094, decrypted)
 sjryuko			// (c) 1988 White Board (FD1094, decrypted)
-suprleag		// (c) 1987 (protected)
+suprleag		// (c) 1987 (FD1094, decrypted)
 tetris2			// (c) 1988 (FD1094, decrypted) S16B
 tetris1			// (c) 1988 (FD1094, decrypted) S16B
-timescan		// (c) 1987
-toryumon		// (c) 1995
+timescan		// (c) 1987 (Unprotected)
+toryumon		// (c) 1995 (Unprotected)
 tturf			// (c) 1989 Sega / Sunsoft (8751)
 tturfu			// (c) 1989 Sega / Sunsoft (8751)
 wb3				// (c) 1988 Sega / Westone (8751)
@@ -4234,6 +4219,9 @@
 wrestwar2		// (c) 1989 (FD1094, decrypted)
 wrestwar1		// (c) 1989 (FD1094, decrypted)
 
+// System 16C
+fantzn2x		// (c) 2008 Sega / M2
+
 // Philko Boards
 atomicp			// (c) 1990 Philko - korean clone board
 snapper			// (c) 1990 Philko - korean clone board
@@ -4310,11 +4298,11 @@
 				// 1987.04 Super Hang-On (Japan)
 				// 1987.06 Super Hang-On (US)
 				// 1987.?? Super Hang-On (World)
-shangon			// 1987 (protected)
+shangon			// 1987 (unprotected)
 shangon3		// 1987 (FD1089B, decrypted)
 shangon2		// 1987 (FD1089B, decrypted)
 shangon1		// 1987 (FD1089B, decrypted)
-shangonle		// 1991
+shangonle		// 1991 (Unprotected)
 				// 1989.02 Turbo Outrun (Japan)
 				// 1989.04 Turbo Outrun (US)
 				// 1989.?? Turbo Outrun (World)
@@ -4345,7 +4333,7 @@
 abcop			// 1990.?? A.B.Cop (World, FD1094, decrypted)
 				// 1991.01 A.B.Cop (Japan)
 				// 1990.10 GP Rider (Japan)
-gprider			// 1990.?? GP Rider (World, protected)
+gprider			// 1990.?? GP Rider (World, FD1094, decrypted)
 gprideru		// 1990.12 GP Rider (US, FD1094, decrypted)
 
 // Y-Board
@@ -4358,8 +4346,8 @@
 				// 1988.08 Power Drift (US)
 pdriftj			// 1988.09 Power Drift (Japan)
 pdrift			// 1988.?? Power Drift (World)
-pdrifta
-pdrifte
+pdrifta			// 1988.?? Power Drift (World)
+pdrifte			// 1988.?? Power Drift (World)
 gloc			// 1990.04 G-LOC Air Battle (US)
 				// 1990.05 G-LOC Air Battle (Japan)
 glocr360		// 1990.?? G-LOC (R360, World?)
@@ -4401,7 +4389,7 @@
 mahmajn			// 1992.12 Tokorosan no Mahmahjong (Japan)
 quizmeku		// 1993.05 Quiz Mekurumeku Story (Japan)
 mahmajn2		// 1994.05 Tokorosan no Mahmahjong 2 (Japan)
-qgh				// 1994.09 Quiz Ghost Hunter
+qgh			// 1994.09 Quiz Ghost Hunter
 
 // Sega System 32 games
 radm			// 1991.?? Rad Mobile (World)
@@ -4463,10 +4451,10 @@
 scrossu			// 1992.09 Stadium Cross (US)
 
 // Model 1 Games
-vr				// 1992.08 Virtua Racing
-vf				// 1993.12 Virtua Fighter
+vr			// 1992.08 Virtua Racing
+vf			// 1993.12 Virtua Fighter
 vformula		// 1993.?? Virtua Formula
-swa				// 1994.04 Star Wars Arcade
+swa			// 1994.04 Star Wars Arcade
 wingwar			// 1994.06 Wing War
 wingwarj		// 1994.06 Wing War (Japan)
 wingwaru		// 1994.09 Wing War (US)
@@ -4497,7 +4485,7 @@
 introdon		// 1996.04 Karaoke Quiz Intro Dondon (Sunsoft / Success)
 smleague		// 1996.04 Super Major League
 decathlt		// 1996.05 Decathlete
-decathlto
+decathlto		// 1996.05 Decathlete
 dnmtdeka		// 1996.07 Dynamite Deka
 mausuke			// 1996.07 Mausuke no Ojama the World (Data East)
 diehard			// 1996.08 Die Hard Arcade
@@ -4538,7 +4526,7 @@
 cottonbm		// 1998.09 Cotton Boomerang (Success)
 stress			// 1998.10 Stress Busters
 elandore		// 1998.11 Touryuu Densetsu Elandore (Sai-Mate)
-sss				// 1998.12 Steep Slope Sliders (Capcom / Cave / Victor)
+sss			// 1998.12 Steep Slope Sliders (Capcom / Cave / Victor)
 micrombc		// 1999.03 Microman Battle Charge
 pclub2v3		// 1999.03 Print Club 2 Vol. 3
 sanjeon			// 1999.04 Sanjun Sujun (Sega / Deniam)
@@ -4548,8 +4536,6 @@
 pclubor			// 1999.11 Print Club Goukakenran
 danchiq			// 2000.12 Danchi de Quiz Okusan Yontaku Desuyo! (Altron)
 
-
-
 // Sega Model 2 Games
 
 // Model 2 (TGPs, Model 1 sound board)
@@ -4644,7 +4630,7 @@
 vs29815			// 1998.05 Virtua Striker 2 ver.98
 
 // Step 2.0
-vs2				// 1997.06 Virtua Striker 2
+vs2			// 1997.06 Virtua Striker 2
 harley			// 199?.?? Harley Davidson & L.A.Riders (rev B)
 harleya			// 1997.12 Harley Davidson & L.A.Riders (rev A)
 skichamp		// 1998.01 Ski Champ
@@ -4673,7 +4659,7 @@
 				// 1998.12 Virtua Striker 2 ver.99
 spikeofe		// 1999.01 Spikeout Final Edition
 magtruck		// 1999.03 Magical Truck Adventure (US)
-eca				// 1999.10 Kyukyuusya Emergency Call Ambulance
+eca			// 1999.10 Kyukyuusya Emergency Call Ambulance
 ecax
 
 
@@ -4684,7 +4670,6 @@
 karianx			// (c) 1996 Deniam
 logicpr2		// (c) 1997 Deniam (Japan)
 
-
 /*
 Deniam is a Korean company (http://deniam.co.kr).
 
@@ -4901,8 +4886,8 @@
 deathcox		// 2000.10 Death Crimson OX
 cspike			// 2000.10 Gun Spike / Cannon Spike
 sstrkfgt		// 2000.10 Sega Strike Fighter (Rev A)
-confmiss		// 2000.11 Confidential Mission												// First GD-ROM game?
-ninjaslt        // 2000.11 Ninja Assault
+confmiss		// 2000.11 Confidential Mission			// First GD-ROM game?
+ninjaslt		// 2000.11 Ninja Assault
 				// 2000.11 Shakatto Tambourine
 wwfroyal		// 2000.11 WWF Royal Rumble
 pjustic			// 2000.12 Moero Justice Gakuen / Project Justice
@@ -5002,7 +4987,7 @@
 ggxxac			// 2006.11 Guilty Gear XX Accent Core
 meltyb			// 2006.12 Melty Blood Act Cadenza ver.B
 meltyba			// 2006.12 Melty Blood Act Cadenza ver.B (Rev A)
-takoron			// 2006.12.16 Noukone Puzzle Takoron										// Last GD-ROM game?
+takoron			// 2006.12.16 Noukone Puzzle Takoron						// Last GD-ROM game?
 				// 2007.03 Melty Blood Act Cadenza ver.B Syuuseiban(ver.B2)
 // Releases below use flash/mask ROMs like older NAOMI titles, not GD-ROM as GD-ROM Hardware (Drives and Discs) were no longer being produced.
 pokasuka		// 2007.07 Pokasuka Ghost!
@@ -5095,7 +5080,7 @@
 dirtypig		// 2004.09 Dirty Pig Skin Football
 ftspeed			// 2004.09 Faster than Speed
 kov7sprt		// 2004.?? Knights of Valour - The Seven Sprits
-anmlbskt        // 2005.01 Animal Basket (date is inside of ROM, probably earlier than release)
+anmlbskt		// 2005.01 Animal Basket (date is inside of ROM, probably earlier than release)
 vfurlong		// 2005.03 Net Select Keiba Victory Furlong
 rumblef2		// 2005.03 The Rumble Fish 2
 ngbc			// 2005.07 NeoGeo Battle Colloseum
@@ -5200,7 +5185,7 @@
 hshavoc			// (c) 1993 Data East
 
 // Data East "Burger Time hardware" games
-lnc				// (c) 1981
+lnc			// (c) 1981
 zoar			// (c) 1982
 btime			// (c) 1982
 btime2			// (c) 1982
@@ -5210,7 +5195,7 @@
 cookrace		// bootleg
 wtennis			// bootleg 1982
 brubber			// (c) 1982
-bnj				// (c) 1982 + Midway
+bnj			// (c) 1982 + Midway
 caractn			// bootleg
 disco			// (c) 1982
 discof			// (c) 1982
@@ -5248,7 +5233,7 @@
 cptennis		// 22 1982.06 Pro Tennis
 				// 23 1982.?? 18 Hole Pro Golf
 				// 24 1982.07 Tsumego Kaisyou
-				// 25 1982.10 Angler Dangler? (fishing)
+cfishing		// 25 1982.10 Fishing / Angler Dangler
 cbtime			// 26 1982.08 Hamburger/Burger Time
 chamburger  		// 26 1982.08 Hamburger (Japan)
 cburnrub		// 27 1982.11 Burnin' Rubber
@@ -5809,7 +5794,7 @@
 crimfght		// GX821 (c) 1989 (US)
 crimfght2		// GX821 (c) 1989 (World)
 crimfghtj		// GX821 (c) 1989 (Japan)
-spy				// GX857 (c) 1989 (World)
+spy			// GX857 (c) 1989 (World)
 spyu			// GX857 (c) 1989 (US)
 bottom9			// GX891 (c) 1989
 bottom9n		// GX891 (c) 1989
@@ -5903,7 +5888,7 @@
 
 // (some) Konami 68000 games
 cuebrick		// GX903 (c) 1989
-mia				// GX808 (c) 1989
+mia			// GX808 (c) 1989
 mia2			// GX808 (c) 1989
 tmnt			// GX963 (c) 1989 (World)
 tmntu			// GX963 (c) 1989 (US)
@@ -6005,7 +5990,7 @@
 rungunu			// GX247 (c) 1993 (US)
 rungunua		// GX247 (c) 1993 (US)
 slmdunkj		// GX247 (c) 1993 (Japan)
-dbz				// (c) 1993 Banpresto
+dbz			// (c) 1993 Banpresto
 dbz2			// (c) 1994 Banpresto
 bishi			// GX575 (c) 1996 (Japan)
 sbishi			// GX675 (c) 1998 (Japan)
@@ -6034,7 +6019,7 @@
 				// 1995.03 GX218 (US)
 
 // GX Type 2
-le2				// 1994.?? GX312 (Europe)
+le2			// 1994.?? GX312 (Europe)
 le2u			// 1994.04 GX312 (US)
 le2j			// 1994.06 GX312 (Japan)
 puzldama		// 1994.07 GX315 (Japan)
@@ -6128,10 +6113,10 @@
 //popnstex  	// GX970 (c) 1999 (Japan)
 
 // Firebeat games
-ppp				// GQ977 (c) 2000
-ppd				// GQ977 (c) 2000 (Korea)
+ppp			// GQ977 (c) 2000
+ppd			// GQ977 (c) 2000 (Korea)
 ppp11			// GQ977 (c) 2000
-kbm				// GQ974 (c) 2000
+kbm			// GQ974 (c) 2000
 kbm2nd			// GCA01 (c) 2000
 kbm3rd			// GCA12 (c) 2001
 popn5			// GCA04 (c) 2000
@@ -6205,7 +6190,7 @@
 pepper2			// (c) 1982
 pepper27		// (c) 1982
 hardhat			// (c) 1982
-fax				// (c) 1983
+fax			// (c) 1983
 fax2			// (c) 1983
 circus			// no copyright notice [1977?]
 springbd		// Sub-Electro bootleg of Circus
@@ -6307,9 +6292,10 @@
 missile1		// 035820-035825    (c) 1980
 suprmatk		//                  (c) 1980 + (c) 1981 Gencomp
 suprmatkd		//                  (c) 1980 + (c) 1981 Gencomp
-mcombat
-mcombata
-mcombats
+mcombat			// bootleg
+mcombata		// bootleg
+mcombats		// bootleg
+missilem		// hack
 
 // Atari vector games
 llander			// 0345xx           no copyright notice
@@ -6356,7 +6342,7 @@
 mhavocrv		// (hack)
 alphaone		// (proto)          (c) 1983
 alphaonea		// (proto)          (c) 1983
-esb				// 136031           (c) 1985
+esb			// 136031           (c) 1985
 tomcat			// (proto)          (c) 1985
 
 // Atari "Centipede hardware" games
@@ -6371,6 +6357,7 @@
 magworm			// (bootleg)
 mazeinv			// (proto)          (c) 1982
 milliped		// 136013           (c) 1982
+multiped		// hack
 millipdd		// hack by Two Bit Score
 qwak			// (proto)          (c) 1982
 runaway			// (proto)          (c) 1982
@@ -6572,9 +6559,9 @@
 gauntlet2p		// 136037           (c) 1985
 gauntlet2pj		// 136037           (c) 1985
 gauntlet2pg		// 136037           (c) 1985
-gauntlet2pr3	// 136037           (c) 1985
-gauntlet2pj2	// 136037           (c) 1985
-gauntlet2pg1	// 136037           (c) 1985
+gauntlet2pr3		// 136037           (c) 1985
+gauntlet2pj2		// 136037           (c) 1985
+gauntlet2pg1		// 136037           (c) 1985
 // Gauntlet 2
 gaunt2			// 136043           (c) 1986
 gaunt2g			// 136043           (c) 1986
@@ -6646,7 +6633,6 @@
 // Cyberball Tournament
 cyberbalt		// 136073           (c) 1989
 cyberbalt1		// 136073           (c) 1989
-
 badlands		// 136074           (c) 1989
 badlandsb		// bootleg
 badlandsb2		// bootleg set 2
@@ -6658,7 +6644,6 @@
 klaxp1			// prototype
 klaxp2			// prototype
 thunderj		// 136076           (c) 1990
-
 hydra			// 136079           (c) 1990
 hydrap			// (proto)          (c) 1990
 hydrap2			// (proto)          (c) 1990
@@ -6769,7 +6754,7 @@
 sgladiat		// A3006      (c) 1984
 hal21			// A4031      (c) 1985
 hal21j			//            (c) 1985 (Japan)
-aso				//            (c) 1985
+aso			//            (c) 1985
 alphamis		//            (c) 1985
 arian			//            (c) 1985
 tnk3			// A5001      (c) 1985
@@ -6810,7 +6795,7 @@
 ikari3			// A7007 'IK3'(c) 1989
 ikari3u			// A7007 'IK3'(c) 1989
 ikari3j			// A7007 'IK3'(c) 1989
-pow				// A7008 'DG' (c) 1988
+pow			// A7008 'DG' (c) 1988
 powj			// A7008 'DG' (c) 1988
 searchar		// A8007 'BH' (c) 1989
 searcharu		// A8007 'BH' (c) 1989
@@ -6905,14 +6890,14 @@
 ncommand		// 0050 (c) 1992 Alpha Denshi Co.
 viewpoin		// 0051 (c) 1992 Sammy
 ssideki			// 0052 (c) 1992 SNK
-wh1				// 0053 (c) 1992 Alpha Denshi Co.
+wh1			// 0053 (c) 1992 Alpha Denshi Co.
 wh1h			// 0053 (c) 1992 Alpha Denshi Co.
 wh1ha			// 0053 (c) 1992 Alpha Denshi Co.
 				// 0054 Crossed Swords 2  (CD only? not confirmed, MVS might exist)
 kof94			// 0055 (c) 1994 SNK
 aof2			// 0056 (c) 1994 SNK
 aof2a			// 0056 (c) 1994 SNK
-wh2				// 0057 (c) 1993 ADK
+wh2			// 0057 (c) 1993 ADK
 fatfursp		// 0058 (c) 1993 SNK
 fatfurspa		// 0058 (c) 1993 SNK
 savagere		// 0059 (c) 1995 SNK
@@ -6954,7 +6939,7 @@
 fswords			// 0187 Korean hack of samsho3
 stakwin			// 0088 (c) 1995 Saurus
 pulstar			// 0089 (c) 1995 Aicom
-whp				// 0090 (c) 1995 ADK / SNK
+whp			// 0090 (c) 1995 ADK / SNK
 				// 0091
 kabukikl		// 0092 (c) 1995 Hudson
 neobombe		// 0093 (c) 1997 Hudson
@@ -7086,7 +7071,7 @@
 ms5plus			// bootleg
 svcpcb			// 0269 (c) 2003 Playmore / Capcom - JAMMA PCB
 svcpcba			// 0269 (c) 2003 Playmore / Capcom - JAMMA PCB
-svc				// 0269 (c) 2003 Playmore / Capcom
+svc			// 0269 (c) 2003 Playmore / Capcom
 svcboot			// bootleg
 svcplus			// bootleg
 svcplusa		// bootleg
@@ -7110,12 +7095,9 @@
 jockeygpa
 vliner
 vlinero
-
 diggerma		// No Game ID (unlicensed), (c) 2000 Kyle Hodgetts, prototype
-
 sbp				// (c)2004 Vektorlogik
 
-
 // Hyper NeoGeo 64 uses a 3 digit rom code?
 
 hng64
@@ -7179,7 +7161,6 @@
 sbasebal		// Alpha-68K96V       (c) 1989 SNK of America licensed from Alpha
 tnextspc		// A8003 'NS' (c) 1989
 tnextspcj		// A8003 'NS' (c) 1989
-
 meijinsn		// (c) 1986 SNK
 
 // Technos games
@@ -7217,7 +7198,7 @@
 ddragonb		// bootleg
 ddragonba		// bootleg
 ddragon6809		// bootleg
-ddragon6809a	// bootleg
+ddragon6809a		// bootleg
 ddragonb2		// bootleg
 spdodgeb		// TA-0022 (c) 1987
 nkdodge			// TA-0022 (c) 1987 (Japan)
@@ -7232,7 +7213,8 @@
 wwfsstarj		// TA-0024 (c) 1989 (Japan)
 vball			// TA-0025 (c) 1988 (US)
 vball2pj		// TA-0025 (c) 1988 (Japan)
-vballb			// TA-0025 (c) 1988
+vballb			// bootleg (of US set)
+vball2pjb		// bootleg (of Japan set)
 ddragon2		// TA-0026 (c) 1988 (World)
 ddragon2u		// TA-0026 (c) 1988 (US)
 toffy			// (c) 1993 Midas
@@ -7400,6 +7382,10 @@
 gekiretu		// (c) 1992 Face
 cultures		// (c) 1994 Face
 
+// Midway Atlantis games
+mwskins         // (c) 2000 Midway
+mwskinsa        // (c) 2000 Midway
+
 // Williams/Midway TMS games
 narc			// (c) 1988 Williams
 narc3			// (c) 1988 Williams
@@ -7425,7 +7411,7 @@
 shimpactp5		// (c) 1991 Midway
 shimpactp4		// (c) 1991 Midway
 strkforc		// (c) 1991 Midway
-mk				// (c) 1992 Midway
+mk			// (c) 1992 Midway
 mkr4			// (c) 1992 Midway
 mktturbo		// hack
 mkyturbo		// hack
@@ -7447,7 +7433,7 @@
 term2la1		// (c) 1992 Midway
 totcarn			// (c) 1992 Midway
 totcarnp		// (c) 1992 Midway
-mk2				// (c) 1993 Midway
+mk2			// (c) 1993 Midway
 mk2r31e			// (c) 1993 Midway
 mk2r32			// (c) 1993 Midway
 mk2r30			// (c) 1993 Midway
@@ -7466,7 +7452,7 @@
 nbajamt3		// (c) 1994 Midway
 nbajamtn		// (c) 1995 Midway
 revx			// (c) 1994 Midway
-mk3				// (c) 1994 Midway
+mk3			// (c) 1994 Midway
 mk3r20			// (c) 1994 Midway
 mk3r10			// (c) 1994 Midway
 mk3p40			// (c) 1994 Midway
@@ -7496,10 +7482,12 @@
 offroadc4		// (c) 1997 Midway (v1.40)
 offroadc3		// (c) 1997 Midway (v1.30)
 offroadc1		// (c) 1997 Midway (v1.10)
-wargods			// (c) 1996 Midway
+wargods			// (c) 1996 Midway (HD 10/09/1996 - Dual Resolution)
+wargodsa		// (c) 1996 Midway (HD 08/15/1996)
+wargodsb		// (c) 1996 Midway (HD 12/11/1995)
 
 // Midway Zeus games
-mk4				// (c) 1997 Midway (v3.0) Latest offical release
+mk4			// (c) 1997 Midway (v3.0) Latest offical release
 mk4a			// (c) 1997 Midway (v2.1)
 mk4b			// (c) 1997 Midway (v1.0)
 invasnab		// (c) 1999 Midway (v5.0) Latest offical release
@@ -7552,7 +7540,7 @@
 arctthndult		// (c) 2001 Midway Games
 
 // Midway Touchmaster / Galaxy Games
-tm				// (c) 1996 Midway Games
+tm			// (c) 1996 Midway Games
 tmdo			// (c) 1996 Midway Games
 tm2k			// (c) 1996 Midway Games
 tm2ka			// (c) 1996 Midway Games
@@ -7561,6 +7549,7 @@
 tm3ka			// (c) 1997 Midway Games
 tm4k			// (c) 1998 Midway Games
 tm4ka			// (c) 1998 Midway Games
+tm4kca			// (c) 1998 Midway Games
 tm4kb			// (c) 1998 Midway Games
 tm5k			// (c) 1998 Midway Games
 tm5kca			// (c) 1998 Midway Games
@@ -7621,7 +7610,7 @@
 speedfrk		// (c) 1979 Vectorbeam
 sundance		// (c) 1979
 demon			// (c) 1982 Rock-ola
-qb3				// (c) 1982 Rock-ola - prototype
+qb3			// (c) 1982 Rock-ola - prototype
 // this one uses 68000+Z80 instead of the Cinematronics CPU
 cchasm
 cchasm1			// (c) 1983 Cinematronics / GCE
@@ -7642,7 +7631,7 @@
 machomou		// (c) 1982 Techstar
 intrepid		// (c) 1983 Nova Games Ltd.
 intrepid2		// (c) 1983 Nova Games Ltd.
-intrepidb       // bootleg
+intrepidb		// bootleg
 zaryavos		// (c) 1983 Nova Games of Canada (prototype)
 timelimt		// (c) 1983 Chuo Co. Ltd
 progress		// (c) 1984 Chuo Co. Ltd
@@ -7687,7 +7676,7 @@
 scionc			// (c) 1984 Seibu Denshi + Cinematronics license
 kungfut			// (c) 1984 Seibu Kaihatsu
 kungfuta		// (c) 1984 Seibu Kaihatsu
-wiz				// (c) 1985 Seibu Kaihatsu
+wiz			// (c) 1985 Seibu Kaihatsu
 wizt			// (c) 1985 Taito Corporation
 wizta			// (c) 1985 Taito Corporation
 kncljoe			// (c) 1985 Taito Corporation
@@ -7715,6 +7704,7 @@
 dbldynu			// (c) 1989 Seibu Kaihatsu + Fabtek license
 raiden			// (c) 1990 Seibu Kaihatsu
 raidena			// (c) 1990 Seibu Kaihatsu
+raidenb			// (c) 1990 Seibu Kaihatsu
 raidenk			// (c) 1990 Seibu Kaihatsu + IBL Corporation license
 raident			// (c) 1990 Seibu Kaihatsu + Liang HWA Electronics license
 raidenu			// (c) 1990 Seibu Kaihatsu + Fabtek license
@@ -7726,7 +7716,6 @@
 goodejan		// (c) 1991 Seibu/Tecmo
 goodejana		// (c) 1991 Seibu/Tecmo
 
-
 raiden2			// (c) 1993 Seibu Kaihatsu + Fabtek license
 raiden2a		// (c) 1993 Seibu Kaihatsu + Metrotainment license
 raiden2b		// (c) 1993 Seibu Kaihatsu
@@ -7898,7 +7887,7 @@
 // Jaleco Mega System 1 games
 lomakai			// (c) 1988 (World)
 makaiden		// (c) 1988 (Japan)
-p47				// (c) 1988
+p47			// (c) 1988
 p47j			// (c) 1988 (Japan)
 kickoff			// (c) 1988 (Japan)
 tshingen		// (c) 1988 (Japan)
@@ -7918,7 +7907,7 @@
 avspirit		// (c) 1991
 phantasm		// (c) 1991 (Japan)
 monkelf			// bootleg
-edf				// (c) 1991
+edf			// (c) 1991
 edfu			// (c) 1991
 edfbl			// (c) 1991
 64street		// (c) 1991
@@ -7927,7 +7916,7 @@
 soldamj			// (c) 1992 (Japan)
 bigstrik		// (c) 1992
 bigstrkb		// bootleg on different hardware
-bigstrkba       // alt set of 'bigstrkb' with Italian teams
+bigstrkba		// alt set of 'bigstrkb' with Italian teams
 bestleag		// bootleg, by Playmark?
 bestleaw		// bootleg
 chimerab		// (c) 1993
@@ -7952,9 +7941,7 @@
 tp2m32			// (c) 1997
 bnstars			// (c) 1997
 wpksocv2		// (c) 1997
-
 f1superb		// (c) 1994
-
 bnstars1		// (c) 1994
 
 // Video System Co. games
@@ -8068,8 +8055,6 @@
 loderndfa		// (c) 2000
 hotdebut		// (c) 2000
 
-
-
 // Orca games
 marineb			// (c) 1982 Orca
 changes			// (c) 1982 Orca
@@ -8293,7 +8278,7 @@
 jockeyc			// (c) 1990 [Seta] (Visco license)
 rezon			// (c) 1991 Allumer
 rezont			// (c) 1991 Allumer / Taito
-stg				// (c) 1991 Athena / Tecmo
+stg			// (c) 1991 Athena / Tecmo
 pairlove		// (c) 1991 Athena
 blandia			// (c) 1992 Allumer
 blandiap		// (c) 1992 Allumer
@@ -8375,7 +8360,7 @@
 drifto94		// (c) 1994 Visco
 janjans1		// (c) 1996 Visco
 stmblade		// (c) 1996 Visco
-jsk				// (c) 1997 Visco
+jsk			// (c) 1997 Visco
 koikois2		// (c) 1997 Visco
 mslider			// (c) 1997 Visco / Datt Japan
 ryorioh			// (c) 1998 Visco
@@ -8421,7 +8406,6 @@
 kurufev			// (c) 2003 Aruze (Arcade TV Game List - P.75, Right, 1st entry on top)
 mayjin3			// (c) 2000 Seta (Arcade TV Game List - P.101, Right, 9 from top)
 
-
 // Atlus games
 powerins		// (c) 1993 Atlus (USA)
 powerinsj		// (c) 1993 Atlus (Japan)
@@ -8631,7 +8615,7 @@
 gakusai2		// (c) 1998 MakeSoft
 blzntrnd		// (c) 1994 Human Amusement
 gstrik2			// (c) 1996 Human Amusement
-gstrik2j
+gstrik2j		// (c) 1996 Human Amusement
 hyprduel		// (c) 1993 Technosoft (Japan)
 hyprduel2		// (c) 1993 Technosoft (Japan)
 magerror		// (c) 1994 Technosoft (Japan) (Arcade TV Game List - P.100, Left, 13 from Bottom)
@@ -8698,7 +8682,7 @@
 zeropnta		// (c) 1998
 zeropnt2		// (c) 1999
 silkroad		// (c) 1999
-aoh				// (c) 2001
+aoh			// (c) 2001
 
 // Afega games
 twinactn		// (c) 1996 - bootleg of US AFF Mustang
@@ -8816,30 +8800,33 @@
 rongrong		// "80" (c) 1994 Nakanihon
 rongrongj		// "80" (c) 1994 Nakanihon
 rongrongg		// "80" (c) 1994 Nakanihon
-hparadis		//      (c) 1994 Nakanihon
-hgokou			//      (c) 1995 Dynax (Alba license)
-hgokbang		//      (c) 1995 Dynax
-mjdchuka		//      (c) 1995 Nakanihon
+hgokbang		// "116" (c) 1995 Dynax
 mjtensin		// "100" 1995 Dynax
+hparadis		// "101" (c) 1994 Nakanihon
 nettoqc			// "103" (c) 1995 Nakanihon
 majrjhdx		// "105" 1996 Dynax
-ddenlovj		// "113" (c) 1995 Dynax (Japan)
+hgokou			// "108" (c) 1995 Dynax (Alba license)
+mjdchuka		// "111" (c) 1995 Nakanihon
+ddenlovj		// "112" (c) 1995 Dynax (Japan)
 ddenlovrk		// "113" (c) 1995 Dynax (Korea)
 ddenlovr		// "113" (c) 1996 Dynax (Hong Kong)
+mjchuuka		// "121" (c) 1998 Dynax
 ddenlovrb		// bootleg
-hanakanz		// "507" 1996 Dynax
+mjflove			// "500" 1996 Dynax
 akamaru			// "501" 1996 Dynax
 sryudens		// "502" 1996 Dynax / Face
-mjflove			//       1996 Dynax
+hanakanz		// "507" 1996 Dynax
 hkagerou		// "510" Hana Kagerou 1996 Nakanihon
-realbrk			// "600" Billiard Academy Real Break 1998 (Europe)
-realbrkk		// "600" Billiard Academy Real Break 1998 (Korea)
 realbrkj		// "523" Billiard Academy Real Break 1998 (Japan)
 dai2kaku		// "522" DaiDaiKakumei (Japan)
-mjchuuka		// "???" (c) 1998 Dynax
 mjreach1		// "526" Mahjong Reach Ippatsu 1998 Nihon System/Dynax
 cafebrk			// "528" Mahjong Cafe Break (C) 1999 Nakanihon / Dynax
 jongtei			// "532" Mahjong Jong-Tei (C) 1999 Dynax
+seljan2			// "557" 1996 Dynax / Face
+realbrk			// "600" Billiard Academy Real Break 1998 (Europe)
+realbrkk		// "600" Billiard Academy Real Break 1998 (Korea)
+janshinp		// "700j" 1996 Dynax / Sigma
+dtoyoken		// "700d" 1996 Dynax / Sigma
 daimyojn		// 2002 Dynax / Techno-Top
 momotaro		// 2004 Techno-Top
 
@@ -8863,7 +8850,7 @@
 spiders2		// (c) 1981 Sigma Ent. Inc.
 spiders3		// (c) 1981 Sigma Ent. Inc.
 spinner			// bootleg
-sub				// (c) 1985 Sigma Ent. Inc.
+sub			// (c) 1985 Sigma Ent. Inc.
 
 // Sigma B52
 jwildb52		// (c) 199? Sigma
@@ -8923,10 +8910,10 @@
 gp98			// (c) 1998
 
 // IGS011 Games
-lhb				// (c) 1995
+lhb			// (c) 1995
 lhbv33c			// (c) 1995
 ryukobou		// (c) 1995
-dbc				// (c) 199?
+dbc			// (c) 199?
 lhb2			// (c) 1996
 xymg			// (c) 1996
 wlcc			// (c) 1996
@@ -8935,10 +8922,10 @@
 drgnwrld		// (c) 1997
 drgnwrldv30		// (c) 1995
 drgnwrldv21		// (c) 1995
-drgnwrldv21j	// (c) 1995
-drgnwrldv20j	// (c) 1995
-drgnwrldv10c	// (c) 1995
-drgnwrldv11h	// (c) 1995
+drgnwrldv21j		// (c) 1995
+drgnwrldv20j		// (c) 1995
+drgnwrldv10c		// (c) 1995
+drgnwrldv11h		// (c) 1995
 nkishusp		// (c) 1998
 
 // IGS017 / IGS031 Games
@@ -8986,7 +8973,7 @@
 dwex			// (c) 1998 Dragon World 3 EX
 killbld			// (c) 1998 The Killing Blade
 killbld104		//
-kov				// (c) 1999 Knights of Valor
+kov			// (c) 1999 Knights of Valor
 kov115			//
 kov100			//
 kovplus			// (c) 1999 Knights of Valor Plus (aka 10 Character version)
@@ -9018,7 +9005,7 @@
 puzzli2			// (c) 2001 Puzzli 2
 martmast		// (c) 2001 Martial Masters
 martmastc		//
-martmastc102	//
+martmastc102		//
 theglad			// (c) 2001 The Gladiator
 theglada		//
 thegladpcb		//
@@ -9037,9 +9024,9 @@
 oldsplus		// (c) 2004 Oriental Legend Super Plus
 killbldp		// (c) 2004 Killing Blade Plus
 happy6			// (c) 200? Happy 6
-svg				// (c) 2003 Spectral vs Generation
+svg			// (c) 2003 Spectral vs Generation
 svgpcb			//
-ket				// (c) 2002 Ketsui
+ket			// (c) 2002 Ketsui
 keta			//
 ketb			//
 ddpdoj			// (c) 2002 DoDonPachi Dai-Ou-Jou
@@ -9081,7 +9068,6 @@
 // TCH games
 speedspn		// (c) 1994
 mstworld		// (c) 1994
-
 kickgoal		// (c) 1995
 actionhw		// (c) 1995
 
@@ -9170,7 +9156,6 @@
 cheesech		// (c) 1994
 stonebal		// (c) 1994
 stonebal2		// (c) 1994
-
 shtstar			// (c) 1994 Nova
 
 // Dynamo games
@@ -9188,8 +9173,9 @@
 
 // Tatsumi Games
 kingdrby		// (c) 1981 Tatsumi
-tx1				// (c) 1983 Tatsumi
-tx1a			// (c) 1983 Tatsumi
+tx1				// (c) 1983 Tatsumi + Atari, Namco and Taito license
+tx1jb			// (c) 1983 Tatsumi
+tx1jc			// (c) 1983 Tatsumi
 // TX-1 V8		// (c) 1984 Tatsumi
 buggyboy		// (c) 1985 Tatsumi
 buggyboyjr		// (c) 1986 Tatsumi
@@ -9286,12 +9272,10 @@
 officeye
 donghaer
 
-ddz				// (c) 200?
+ddz			// (c) 200?
 
 psattack		// 2004 Uniana
 
-
-
 // ADP games
 backgamn		// (c) 1990
 quickjac		// (c) 1993
@@ -9307,7 +9291,6 @@
 // JPM
 
 // JPM older?
-
 j_ewnud		// Each Way Nudge
 j_ewnda		// Each Way Nudger
 j_luckac	// Lucky Aces
@@ -9316,7 +9299,6 @@
 
 
 // JPM System 80
-
 j80bac		// Bank A Coin (Jpm)
 j80bounc	// Bouncer (Jpm)
 j80frogh	// Frog Hop (Jpm)
@@ -9341,9 +9323,7 @@
 j80mster	// Masterspy (Pcp)
 j80plsnd	// Plus Nudge (Jpm)
 
-
 // JPM MPS1/2 Hardware
-
 j2adnote	// Add A Note (Jpm)
 j2adnotea
 j2adnoteb
@@ -9549,11 +9529,9 @@
 
 
 // JPM System 5
-
 j5tstal		// JPM System 5 Alpha Display Test Utility (Jpm)
 j5tst1		// JPM System 5 Test Set (Jpm)
 j5tst2		//
-
 j5fifth		// 5th Avenue (Jpm)
 j5ar80		// Around The World In Eighty Days (Jpm)
 j5ar80a		//
@@ -9707,9 +9685,7 @@
 j5ujb		//
 j5wsc		// Wall Street Club (Jpm)
 j5wsca		//
-
 j5movie		// Movie Magic Club (Crystal?)
-
 j5nudfic	// Nudge Fiction (Jpm)
 j5revo		// Revolver (Jpm)
 j5revoa		//
@@ -9717,16 +9693,13 @@
 j5hilos		// Hi Lo Silver (Jpm)
 
 // JPM System 5 + Video Expansion 2
-
 monopoly	// Monopoly (Jpm)
 monopolya	// Monopoly (Jpm)
 monoplcl	// Monopoly Classic (Jpm)
 monopldx	// Monopoly Deluxe (Jpm)
 cashcade	// Cashcade (Jpm)
 
-
 // JPM Impact
-
 j6fifth		// 5th Dimension (Ace)
 j6aceclb	// Ace Of Clubs (Crystal)
 j6aceclba	//
@@ -9966,7 +9939,6 @@
 snlad			// (c) 199?
 
 // Unknown JPM platform
-
 j7bmagic		// Black Magic (Jpm)
 j7cexprs		// Cash Xpress (Jpm)
 j7crztrl		// Crazy Trails (Jpm)
@@ -10024,7 +9996,7 @@
 spaceace		// (c) 1983 Cinematronics
 spaceacea2		// (c) 1983 Cinematronics
 spaceacea		// (c) 1983 Cinematronics
-spaceaceeuro	// (c) 1983 Atari
+spaceaceeuro		// (c) 1983 Atari
 aztarac			// (c) 1983 Centuri (vector game)
 mole			// (c) 1982 Yachiyo Electronics, Ltd.
 thehand			// (c) 1981 T.I.C.
@@ -10113,7 +10085,7 @@
 dribling		// (c) 1983 Model Racing
 driblingo		// (c) 1983 Olympia
 driblingbr		// bootleg
-ace				// [1976 Allied Leisure]
+ace			// [1976 Allied Leisure]
 clayshoo		// [1979 Allied Leisure]
 pirates			// (c) 1994 NIX
 genix			// (c) 199? NIX
@@ -10285,7 +10257,7 @@
 dynadice		// ?
 atamanot		// (c) 1983 Yachiyo Denki / Uni Enterprize
 ssingles		// Yachiyo?
-tcl				// (c) 1995 Uniwang
+tcl			// (c) 1995 Uniwang
 othello			// (c) 1984 Success
 sothello		// (c) 1986 Success / Fujiwara
 quake			// (c) 19?? Lazer-Tron / iD Software
@@ -10294,7 +10266,6 @@
 boonggab		// (c) 2001 Taff System
 
 // Nexus 3D
-
 acheart
 acheartf		// (c) 2006 Examu
 
@@ -10308,18 +10279,15 @@
 yujan			// (C) 1999 Yubis
 
 // Team Play, Inc.
-
 voyager         // (c) 2002 Team Play, Inc.
 
 // BMC
-
 bmcbowl			// (c) 1994 BMC
 koftball		// (c) 1995 BMC
 bmcpokr			// (c) 1999 BMC
 popobear		// (c) 2000 BMC
 
 // Merit
-
 mpoker			// (c) 1983 Merit
 pitboss			// (c) 1983 Merit
 pitbossa		// (c) 1983 Merit
@@ -10385,7 +10353,6 @@
 megat5tg		// (c) 1997 Merit
 megat6			// (c) 1998 Merit
 suprgolf		// (c) 1989 Nasco
-
 onetwo			// (c) 1997 Barko
 onetwoe			// (c) 1997 Barko
 1945kiii		// (c) 2000 Oriental
@@ -10427,7 +10394,6 @@
 cubeqsta		// (c) 1983 Simutrek Inc.
 pkscram			// (c) 1993 Cosmo Electronics Corporation
 
-
 // Funworld
 jollycrd		// (c) 1985 TAB-Austria
 jolyc3x3		// (c) 1985 TAB-Austria
@@ -10546,7 +10512,7 @@
 quarterh		// (c) 1983 Electro-Sports
 quarterha		// (c) 1983 Electro-Sports
 quarterhb		// (c) 1983 Electro-Sports
-qc				// (c) 1995 ArJay Exports/Prestige Games
+qc			// (c) 1995 ArJay Exports/Prestige Games
 trvquest		// (c) 1984 Sunn / Techstar
 rltennis		// (c) 1993 TCH
 wheelfir		// (c) 199? TCH
@@ -10756,13 +10722,13 @@
 comg5108		// (c) 1985 Cal Omega Inc.
 comg903d		// (c) 198? Cal Omega Inc.
 comg905d		// (c) 198? Cal Omega Inc.
+
 elgrande		// (c) 1982 Tuni Electro Service / E.T. Marketing
 jjpoker			// (c) 1983 Enter-Tech
 jjpokerb		// (c) 1983 Enter-Tech
 ssipkr24		// (c) 1988 SSI
 ssipkr30		// (c) 1988 SSI
 ssipkr40		// (c) 1990 SSI
-
 altair			// (c) 1981 Cidelsa
 destryer		// (c) 1981 Cidelsa
 destryera		// (c) 1981 Cidelsa
@@ -10951,13 +10917,13 @@
 speeddrp		// (c) 2003  Astro Corp.
 winbingo		// (c) 2005? Astro Corp.
 winbingoa		// (c) 2005? Astro Corp.
-zoo				// (c) 2005? Astro Corp.
+zoo			// (c) 2005? Astro Corp.
 westvent		// (c) 2007? Astro Corp.
 
 // Dyna
 ncb3			// (c) 199? Dyna Electronics
 cb3a			// (c) 199? Dyna Electronics
-cb3				// (c) 199? Dyna Electronics
+cb3			// (c) 199? Dyna Electronics
 cb3b			// (c) 199? Dyna Electronics
 cb3c			// (c) 199? Dyna Electronics
 cb3d			// (c) 199? Dyna Electronics
@@ -11072,6 +11038,25 @@
 bingownga		// (c) 1993 Wing Co. Ltd
 excitbj			// (c) 1992 Wing Co. Ltd
 
+carb2002		// bootleg
+carb2003		// bootleg
+nfm				// bootleg
+unkch1			// bootleg
+unkch2			// bootleg
+unkch3			// bootleg
+unkch4			// bootleg
+ns8lines		// unknown
+ns8linew		// unknown
+ladylinr		// (c) 198? TAB Austria
+kkotnoli		// 198? south korean hack
+wcat3
+magodds			// 198? (c) Micro Manufacturing Ltd.
+magoddsa		// 198? (c) Micro Manufacturing Ltd.
+magoddsb		// 198? (c) Micro Manufacturing Ltd.
+magoddsc		// 198? (c) Micro Manufacturing Ltd.
+magoddsd		// 198? (c) Micro Manufacturing Ltd.
+
+// Amcoe
 skill98			// (c) 1998 Amcoe
 match98			// (c) 1998 Amcoe
 schery97		// (c) 1998 Amcoe
@@ -11093,25 +11078,6 @@
 nfb96se			// bootleg
 nfb96sea		// bootleg
 nfb96seb		// bootleg
-carb2002		// bootleg
-carb2003		// bootleg
-nfm				// bootleg
-unkch1			// bootleg
-unkch2			// bootleg
-unkch3			// bootleg
-unkch4			// bootleg
-
-ns8lines		// unknown
-ns8linew		// unknown
-ladylinr		// (c) 198? TAB Austria
-kkotnoli		// 198? south korean hack
-wcat3
-magodds			// 198? (c) Micro Manufacturing Ltd.
-magoddsa		// 198? (c) Micro Manufacturing Ltd.
-magoddsb		// 198? (c) Micro Manufacturing Ltd.
-magoddsc		// 198? (c) Micro Manufacturing Ltd.
-magoddsd		// 198? (c) Micro Manufacturing Ltd.
-
 suprball		// (c) 2002 Amcoe - Skill based
 sfbonus			// (c) 2003 Amcoe - Skill Fruit Bonus
 sfbonusd1		// (c) 2003 Amcoe
@@ -11346,7 +11312,6 @@
 moneymacd2		// (c) 200? Amcoe
 moneymacv2		// (c) 200? Amcoe
 
-
 chsuper3		// unknown
 chsuper2		// unknown
 chmpnum			// unknown
@@ -11376,7 +11341,7 @@
 ndxron10		// 2005, unknown
 cgip30cs		// (c) 1999, CGI
 kimblz80		// (c) 198?, Kimble Ireland
-pma				// 1983, PMA
+pma			// 1983, PMA
 bjpoker			// (c) M. Kramer Inc.
 newhilop
 
@@ -11395,7 +11360,6 @@
 dphlunka		// SMS Manufacturing Corp?
 dphlunkb		// SMS Manufacturing Corp?
 
-
 // Sanki Denshi Kogyo
 pachifev		// (c) 1983?
 
@@ -11458,13 +11422,6 @@
 fcockt_10		// (c) 2003
 fcockt_11		// (c) 2003
 fcockt_12		// (c) 2003
-fcockt2_3
-fcockt2_4
-fcockt2_4a
-fcockt2_4b
-fcockt2_4d
-fcockt2_4f
-fcockt2_5
 
 // Lucky Haunter
 //lhaunt		// (c) 2003
@@ -11542,6 +11499,10 @@
 
 // Fruit Cocktail 2
 fcockt2			// (c) 2008
+//fcockt2_2		// (c) 2008
+fcockt2_3		// (c) 2008
+fcockt2_4		// (c) 2008
+fcockt2_5		// (c) 2008
 
 
 // Igrosoft bootleg sets
@@ -11646,12 +11607,15 @@
 sweetl2_2c		// bootleg
 sweetl2_2d		// bootleg
 fcockt2a		// bootleg - Fruit Cocktail 2
+fcockt2_4a		// bootleg
+fcockt2_4b		// bootleg
+fcockt2_4d		// bootleg
+fcockt2_4f		// bootleg
 
 igromult		// Multigame bootleg
 igromula		// Multigame bootleg
 
 // Novomatic
-
 g4u2		// Games 4 U
 g4u3		//
 g4u3a		//
@@ -11858,7 +11822,6 @@
 
 atronic		//
 atronica	//
-
 atlantca	// Atlantica
 atlantcaa	//
 baboshka	// Baboshka
@@ -11918,18 +11881,16 @@
 
 // Extrema (Russian)
 
-
- maski     // Maski Show (Russia)
- adults    // Adults Only (Russia)
- bloto     // Blits Loto (Russia)
- blpearl   // Black Pearl (Russia)
- grancan   // Grand Canyon (Russia)
- luckshel  // Lucky Shell (Russia)
- exsafar   // Safari (Russia)
- strlink   // Strong Link (Russia)
- extrmth   // Treasure Hunt (Russia)
- extrmti   // Treasure Island (Russia)
-
+maski     // Maski Show (Russia)
+adults    // Adults Only (Russia)
+bloto     // Blits Loto (Russia)
+blpearl   // Black Pearl (Russia)
+grancan   // Grand Canyon (Russia)
+luckshel  // Lucky Shell (Russia)
+exsafar   // Safari (Russia)
+strlink   // Strong Link (Russia)
+extrmth   // Treasure Hunt (Russia)
+extrmti   // Treasure Island (Russia)
 
 // Cupidon / Kupidon (Russian)
 
@@ -11941,7 +11902,6 @@
 funnyfmb	//
 cashtrn		//
 
-
 // TAB Austria
 // Quizard (Philips CD-I based HW)
 cdimono1		// Base unit
@@ -12265,7 +12225,6 @@
 sc2brkfsm	//
 sc2brkfsm1	//
 sc2brkfsm2	//
-
 sc2drwho	// Dr.Who The Timelord
 sc2drwho1	//
 sc2drwho2	//
@@ -12304,7 +12263,6 @@
 sc2catms2p
 sc2catms3
 sc2catms4
-
 sc2ctms2	// Cat & Mouse (Mark 2 - Bellfruit)
 sc2ctms21
 sc2ctms21p
@@ -12314,7 +12272,6 @@
 sc2ctms23p
 sc2ctms24p
 sc2ctms25
-
 sc2eggs		// Eggs On Legs Tour (Bellfruit)
 sc2eggsp
 sc2eggs1
@@ -15205,7 +15162,7 @@
 sc4gballa	//
 sc4gballb	//
 sc4gballc	//
-sc4ggtb	    // Golden Game (Mazooma) Top Box
+sc4ggtb		// Golden Game (Mazooma) Top Box
 sc4ggtba	//
 sc4ggtbb	//
 sc4ggame	// Golden Game
@@ -15778,7 +15735,7 @@
 sc4dndben	//
 sc4dndbc	// Deal Or No Deal Box Clever (Bellfruit)
 sc4dndbca	//
-sc4bwow     // Wheel of Wealth (Bellfruit)
+sc4bwow		// Wheel of Wealth (Bellfruit)
 sc4bwowa	//
 sc4mowow	// Monopoly Wheel Of Wealth (Mazooma)
 sc4mowowa	//
@@ -17312,7 +17269,6 @@
 sc5nunsmd	//
 sc5nunsme	//
 
-
 // Adder 5
 
 ad5crcpt	// Cops 'n' Robbers Community Party (Bellfruit)
@@ -17331,7 +17287,6 @@
 ad5copsr	// Cops 'n' Robbers (Bellfruit)
 sc5dndbe	// Deal Or No Deal Beat The Banker (Bellfruit)
 ad5mowow	// Monopoly Wheel Of Wealth (Mazooma)
-
 ad5bpfpm	// Bullseye Pounds For Points (Mazooma)
 ad5btc		// Bullseye Triple Club (Bellfruit)
 ad5cmons	// Crazy Money (Bellfruit)
@@ -17358,10 +17313,6 @@
 ad5vpa		// Video Poker Ace (Bellfruit)
 ad5vlv		// Viva Las Vegas (Bellfruit)
 
-
-
-
-
 /* Maygay Machines Ltd. */
 
 // Triple M (MMM) Hardware?
@@ -17370,7 +17321,6 @@
 
 // Maygay M1 A/B hardware
 
-
 m1albsq		// Albert Square (Maygay)
 m1albsqp
 m1albsq3
@@ -17712,10 +17662,8 @@
 m1wldzne	// Wild Zone (Maygay)
 m1winenc	// Winners Enclosure (Maygay)
 m1simps		// The Simpsons (Maygay - Bwb)
-
 m1bghou		// Big Ghoulies (Gemini)
 m1crzco		// Crazy Cobra (Gemini)
-
 m1hiloc		// Hi Lo Casino (Global)
 m1jtjob		// Just The Job (Global)
 m1kingsw	// King Of The Swingers (Global)
@@ -17727,7 +17675,6 @@
 m1trtr		// Trick Or Treat (Global)
 m1trtrcl	// Trick Or Treat Club (Global)
 m1vegcrw	// Vegetable Crew (Global)
-
 m1calyps	// Calypso (Maygay)
 m1cashln	// Cash Lines (Maygay)
 m1races		// A Day At The Races (Maygay)
@@ -17778,7 +17725,6 @@
 mg_scl		// Super Clue
 mg_kf		// Krypton Factor
 
-
 // Maygay EPOCH hardware
 ep_simp		// The Simpsons (Maygay)
 ep_dblim	// Double Impact (Maygay - Impulse)
@@ -18082,7 +18028,7 @@
 
 m4tst		// MPU4 Unit Test (Program 4)
 m4tst2		// MPU4 Unit Test (Program 2)
-m4clr       // MPU4 Meter Clear ROM
+m4clr		// MPU4 Meter Clear ROM
 
 
 m4tenten	// 10 X 10 (Barcrest)
@@ -18793,7 +18739,7 @@
 /* Unsorted */
 
 m4blsbys	// Blues Boys (Version 6)
-m4conn4     // Connect 4
+m4conn4		// Connect 4
 
 m4surf		// Super Surfin' (Gemini)
 m4wife		// Money Or Yer Wife (Gemini)
@@ -18837,13 +18783,11 @@
 m4milrou
 m4kingg
 
-
 // MPU4 + Video board
 
 /* Barcrest */
 
 v4bios		// MPU4 Video Firmware
-
 v4cmaze		// The Crystal Maze (v1.3)
 v4cmazedat	//
 v4cmazea	//
@@ -18920,9 +18864,6 @@
 v4megbuk	// Megabucks Poker
 v4rencas	// Reno Casino
 
-
-
-
 /* Nova (Bwb board) */
 
 v4cybcas	// Cyber Casino
@@ -18930,16 +18871,12 @@
 v4missis	// Mississippi Lady
 v4picdil	// Piccadilly Nights
 
-
-
 /* Zenitone (custom video board) */
 
 v4dealem	// Deal 'Em
 
-
 // MPU5
 
-
 /* Barcrest */
 
 m5clr		// MPU 5 Ram & Meter Clear (Barcrest)
@@ -19325,7 +19262,7 @@
 m5donnad	//
 m5donnaa	//
 m5dblqts	// Double Or Quits (Bwb)
-m5dblqtsa   //
+m5dblqtsa	//
 m5eggold	// Egyptian Gold (Bwb)
 m55050		// Fifty Fifty (Bwb)
 m5gpclub	// Get Plastered Club (Bwb)
@@ -19366,32 +19303,32 @@
 
 // ACE
 
-sidewndr		// (c) 1981? ACE
-spellbnd		// (c) 1981? ACE
-starspnr		// (c) 1982? ACE
-acefruit		// (c) 1982? ACE
+sidewndr	// (c) 1981? ACE
+spellbnd	// (c) 1981? ACE
+starspnr	// (c) 1982? ACE
+acefruit	// (c) 1982? ACE
 
 // Ace System 1
 
-ac1cshtw		// Cash Towers (Ace)
-ac1clbmn		// Club Money (Ace)
-ac1gogld		// Go For Gold (Ace)
-ac1hotpf		// Hot Profit (Ace)
-ac1pster		// Pound Sterling (Ace)
-ac1pstrt		// Pound Stretcher (Pcp)
-ac1primt		// Primetime (Ace)
-ac1taklv		// Take It Or Leave It (Ace)
-
-ac1bbclb		// Big Break Club (Ace)
-ac1clbsv		// Club Sovereign (Ace)
-ac1clbxt		// Club Xtra (Ace)
-ac1piaca		// Play It Again Casino (Ace)
-ac1piacl		// Play It Again Club (Ace)
-ac1prmcl		// Premier Club (Ace)
-ac1rundx		// Runner Deluxe Club (Ace)
-ac1totb			// Top Of The Bill (Ace)
-ac1sptb			// Simply The Best (Pcp)
-ac1shid			// Super Hi De Hi (Ace)
+ac1cshtw	// Cash Towers (Ace)
+ac1clbmn	// Club Money (Ace)
+ac1gogld	// Go For Gold (Ace)
+ac1hotpf	// Hot Profit (Ace)
+ac1pster	// Pound Sterling (Ace)
+ac1pstrt	// Pound Stretcher (Pcp)
+ac1primt	// Primetime (Ace)
+ac1taklv	// Take It Or Leave It (Ace)
+
+ac1bbclb	// Big Break Club (Ace)
+ac1clbsv	// Club Sovereign (Ace)
+ac1clbxt	// Club Xtra (Ace)
+ac1piaca	// Play It Again Casino (Ace)
+ac1piacl	// Play It Again Club (Ace)
+ac1prmcl	// Premier Club (Ace)
+ac1rundx	// Runner Deluxe Club (Ace)
+ac1totb		// Top Of The Bill (Ace)
+ac1sptb		// Simply The Best (Pcp)
+ac1shid		// Super Hi De Hi (Ace)
 
 
 // Ace 'sp.ACE system'
@@ -19467,7 +19404,6 @@
 up_xpres		// Xpress (Pcp)
 up_roll			// Roll Up (Pcp)
 
-
 // Project - PROCONN
 
 pr_lday			// 'L' Of A Day (Project)
@@ -19593,7 +19529,6 @@
 as_hog			// Hearts Of Gold (Astra)
 as_hxr			// Hot Cross Run (Astra)
 as_hr			// Hot Reel (Astra)
-
 as_djp			// Double Jackpot (Astra)
 as_djpa			//
 as_djpb			//
@@ -19730,12 +19665,12 @@
 ec_spbxd	// Super Bar X Deluxe (Electrocoin)
 ec_unk1		// Unknown 'Electrocoin' Fruit Machine '300615' (Electrocoin)
 ec_unk5		// Unknown 'Electrocoin' Fruit Machine(s) (Electrocoin)
-ec_barxmab  // Bar X (MAB PCB) (Electrocoin)
+ec_barxmab	// Bar X (MAB PCB) (Electrocoin)
 ec_spbg7mab	// Super Big 7 (MAB PCB) (Electrocoin)
-ec_supbxmab // Super Bar X (MAB PCB) (Electrocoin)
+ec_supbxmab	// Super Bar X (MAB PCB) (Electrocoin)
 
 // Concept PCB
-ec_casbxcon // Casino Bar X (Concept - Electrocoin)
+ec_casbxcon	// Casino Bar X (Concept - Electrocoin)
 ec_multb	// Multi Bar (Concept - Electrocoin)
 ec_casmb	// Casino Multi Bar (Concept - Electrocoin)
 ec_supmb	// Super Multi Bar (Concept - Electrocoin)
@@ -19743,7 +19678,7 @@
 ec_fltr		// Flutter (Concept)
 ec_gold7	// Golden 7 (Concept)
 ec_mgbel	// Megabell (Concept)
-ec_supbxcon // Super Bar X (MAB PCB) (Concept - Electrocoin)
+ec_supbxcon	// Super Bar X (MAB PCB) (Concept - Electrocoin)
 ec_jackb	// Jackpot Bars (MAB PCB) (Concept - Electrocoin)
 ec_ndgxs	// Nudge Excess (MAB PCB) (Concept - Electrocoin)
 ec_rdht7	// Red Hot 7 (MAB PCB) (Concept - Electrocoin)
@@ -19855,7 +19790,7 @@
 5acespkr		// (c) 198?
 
 // Play Mechanix
-specfrce        // (c) 2002 ICE/Play Mechanix
+specfrce		// (c) 2002 ICE/Play Mechanix
 jnero			// (c) 2004 ICE/Play Mechanix
 
 // Amatic Trading GMBH
@@ -19889,6 +19824,7 @@
 dualgame		// (c) 1995 Labtronix Technologies
 hermit			// (c) 1995 Dugamex
 deucesw2		// (c) 1997
+cj3play			// (c) 1998 Cadillac Jack
 cjffruit		// (c) 1998 Cadillac Jack
 ilpag			// (c) 199? unknown
 
@@ -19943,9 +19879,10 @@
 circa33
 starshot
 
-
 // alvg.c
+
 agsoccer
+
 wrldtour
 wrldtour2
 usafootb
@@ -21489,11 +21426,12 @@
 tonton			// 199?, Success.
 kas89			// 1989, SFC S.R.L.
 caspoker		// 1987, PM / Beck Elektronik.
+wildpkr			// 199?, TAB Austria.
 
 manohman		// 199?, Merkur.
 jankenmn		// 1985, Sunwise.
 
-flipjack
+flipjack		// 1983? Jackson Co., Ltd.
 
 
 // TTL logic games
diff -Nru src-old/mame/mame.mak src/mame/mame.mak
--- src-old/mame/mame.mak	2012-06-11 10:00:48.000000000 +0200
+++ src/mame/mame.mak	2012-06-29 03:27:06.000000000 +0200
@@ -977,6 +977,7 @@
 
 $(MAMEOBJ)/midway.a: \
 	$(DRIVERS)/astrocde.o $(VIDEO)/astrocde.o \
+	$(DRIVERS)/atlantis.o \
 	$(DRIVERS)/balsente.o $(MACHINE)/balsente.o $(VIDEO)/balsente.o \
 	$(DRIVERS)/gridlee.o $(AUDIO)/gridlee.o $(VIDEO)/gridlee.o \
 	$(DRIVERS)/mcr.o $(MACHINE)/mcr.o $(VIDEO)/mcr.o \
@@ -1899,6 +1900,7 @@
 	$(DRIVERS)/tmspoker.o \
 	$(DRIVERS)/manohman.o \
 	$(DRIVERS)/jankenmn.o \
+	$(DRIVERS)/wildpkr.o \
 
 
 #-------------------------------------------------
diff -Nru src-old/mame/video/centiped.c src/mame/video/centiped.c
--- src-old/mame/video/centiped.c	2012-05-03 11:00:08.000000000 +0200
+++ src/mame/video/centiped.c	2012-06-24 01:16:00.000000000 +0200
@@ -40,7 +40,7 @@
 	centiped_state *state = machine.driver_data<centiped_state>();
 	UINT8 *videoram = state->m_videoram;
 	int data = videoram[tile_index];
-	int bank = (data >> 6) & 1;
+	int bank = ((data >> 6) & 1) | (state->m_gfx_bank << 1);
 	int color = (data >> 6) & 3;
 	/* Flip both x and y if flipscreen is non-zero */
 	int flip_tiles = (state->m_flipscreen) ? 0x03 : 0;
@@ -63,7 +63,7 @@
 
 /*************************************
  *
- *  Palette init
+ *  Video system start
  *
  *************************************/
 
@@ -83,60 +83,56 @@
 }
 
 
-
-/*************************************
- *
- *  Video system start
- *
- *************************************/
-
-VIDEO_START( centiped )
+static void init_common(running_machine &machine)
 {
 	centiped_state *state = machine.driver_data<centiped_state>();
-	state->m_bg_tilemap = tilemap_create(machine, centiped_get_tile_info, tilemap_scan_rows,  8,8, 32,32);
-
-	init_penmask(machine);
-
-	state->m_flipscreen = 0;
 
 	state->save_item(NAME(state->m_flipscreen));
+	state->save_item(NAME(state->m_gfx_bank));
 	state->save_item(NAME(state->m_bullsdrt_sprites_bank));
+
+	state->m_flipscreen = 0;
+	state->m_gfx_bank = 0;
+	state->m_bullsdrt_sprites_bank = 0;
 }
 
 
-VIDEO_START( warlords )
+VIDEO_START( centiped )
 {
-	centiped_state *state = machine.driver_data<centiped_state>();
-
-	state->m_bg_tilemap = tilemap_create(machine, warlords_get_tile_info, tilemap_scan_rows,  8,8, 32,32);
+	init_common(machine);
+	init_penmask(machine);
 
-	state->m_flipscreen = 0;
+	centiped_state *state = machine.driver_data<centiped_state>();
+	state->m_bg_tilemap = tilemap_create(machine, centiped_get_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
 }
 
 
-VIDEO_START( milliped )
+VIDEO_START( warlords )
 {
+	init_common(machine);
+
 	centiped_state *state = machine.driver_data<centiped_state>();
+	state->m_bg_tilemap = tilemap_create(machine, warlords_get_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
+}
 
-	state->m_bg_tilemap = tilemap_create(machine, milliped_get_tile_info, tilemap_scan_rows,  8,8, 32,32);
 
+VIDEO_START( milliped )
+{
+	init_common(machine);
 	init_penmask(machine);
 
-	state->m_flipscreen = 0;
-
-	state->save_item(NAME(state->m_flipscreen));
+	centiped_state *state = machine.driver_data<centiped_state>();
+	state->m_bg_tilemap = tilemap_create(machine, milliped_get_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
 }
 
 
 VIDEO_START( bullsdrt )
 {
-	centiped_state *state = machine.driver_data<centiped_state>();
-
-	state->m_bg_tilemap = tilemap_create(machine, bullsdrt_get_tile_info, tilemap_scan_rows,  8,8, 32,32);
-
+	init_common(machine);
 	init_penmask(machine);
 
-	state->m_flipscreen = 0;
+	centiped_state *state = machine.driver_data<centiped_state>();
+	state->m_bg_tilemap = tilemap_create(machine, bullsdrt_get_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
 }
 
 
@@ -165,7 +161,6 @@
 
 WRITE8_MEMBER(centiped_state::centiped_flip_screen_w)
 {
-
 	m_flipscreen = data >> 7;
 }
 
@@ -173,28 +168,32 @@
 
 /*************************************
  *
- *  Tiles bank
+ *  Graphics bank
  *
  *************************************/
 
-WRITE8_MEMBER(centiped_state::bullsdrt_tilesbank_w)
+WRITE8_MEMBER(centiped_state::multiped_gfxbank_w)
 {
+	// d0-d6: N/C?
+	// d7: gfx rom bank
+	int bank = m_prg_bank | (data >> 6 & 2);
+	if (bank != m_gfx_bank)
+	{
+		m_gfx_bank = bank;
+		m_bg_tilemap->mark_all_dirty();
+	}
+}
 
+
+WRITE8_MEMBER(centiped_state::bullsdrt_tilesbank_w)
+{
 	m_bullsdrt_tiles_bankram[offset] = data;
 	m_bg_tilemap->mark_all_dirty();
 }
 
 
-
-/*************************************
- *
- *  Sprites bank
- *
- *************************************/
-
 WRITE8_MEMBER(centiped_state::bullsdrt_sprites_bank_w)
 {
-
 	m_bullsdrt_sprites_bank = data;
 }
 
@@ -348,7 +347,7 @@
 
 ***************************************************************************/
 
-static void melliped_mazeinv_set_color(running_machine &machine, offs_t offset, UINT8 data)
+static void milliped_set_color(running_machine &machine, offs_t offset, UINT8 data)
 {
 	rgb_t color;
 	int bit0, bit1, bit2;
@@ -406,7 +405,7 @@
 {
 	m_generic_paletteram_8[offset] = data;
 
-	melliped_mazeinv_set_color(machine(), offset, data);
+	milliped_set_color(machine(), offset, data);
 }
 
 
@@ -415,7 +414,7 @@
 	m_generic_paletteram_8[offset] = data;
 
 	/* the value passed in is a look-up index into the color PROM */
-	melliped_mazeinv_set_color(machine(), offset, ~machine().root_device().memregion("proms")->base()[~data & 0x0f]);
+	milliped_set_color(machine(), offset, ~machine().root_device().memregion("proms")->base()[~data & 0x0f]);
 }
 
 
@@ -558,7 +557,7 @@
 	/* draw the sprites */
 	for (offs = 0; offs < 0x10; offs++)
 	{
-		int code = ((spriteram[offs] & 0x3e) >> 1) | ((spriteram[offs] & 0x01) << 6);
+		int code = ((spriteram[offs] & 0x3e) >> 1) | ((spriteram[offs] & 0x01) << 6) | (state->m_gfx_bank << 7);
 		int color = spriteram[offs + 0x30];
 		int flipx = state->m_flipscreen;
 		int flipy = (spriteram[offs] & 0x80);
diff -Nru src-old/mame/video/dec0.c src/mame/video/dec0.c
--- src-old/mame/video/dec0.c	2012-06-11 10:00:48.000000000 +0200
+++ src/mame/video/dec0.c	2012-07-02 09:06:11.000000000 +0200
@@ -180,7 +180,6 @@
 	deco_bac06_pf_control_1_w(state->m_tilegen3,0,state->m_automat_scroll_regs[1] - 0x0108, 0xffff);
 	deco_bac06_pf_control_1_w(state->m_tilegen3,1,state->m_automat_scroll_regs[0], 0xffff);
 
-	// sprites seem very different, probably need new functions
 
 	state->flip_screen_set(state->m_tilegen1->get_flip_state());
 
@@ -208,15 +207,63 @@
 		state->m_tilegen2->deco_bac06_pf_draw(screen.machine(),bitmap,cliprect,0, 0x00, 0x00, 0x00, 0x00);
 	}
 
-//  if (state->m_pri & 0x02)
-//      state->m_spritegen->draw_sprites(screen.machine(), bitmap, cliprect, state->m_buffered_spriteram, 0x08, trans^0x08, 0x0f);
-//  else
-//      state->m_spritegen->draw_sprites(screen.machine(), bitmap, cliprect, state->m_buffered_spriteram, 0x00, 0x00, 0x0f);
+	if (state->m_pri & 0x02)
+		state->m_spritegen->draw_sprites_bootleg(screen.machine(), bitmap, cliprect, state->m_buffered_spriteram, 0x08, trans^0x08, 0x0f);
+	else
+		state->m_spritegen->draw_sprites_bootleg(screen.machine(), bitmap, cliprect, state->m_buffered_spriteram, 0x00, 0x00, 0x0f);
 
 	state->m_tilegen1->deco_bac06_pf_draw(screen.machine(),bitmap,cliprect,0, 0x00, 0x00, 0x00, 0x00);
 	return 0;
 }
 
+SCREEN_UPDATE_IND16( secretab )
+{
+	dec0_automat_state *state = screen.machine().driver_data<dec0_automat_state>();
+
+	// layer enables seem different... where are they?
+
+	// the bootleg doesn't write these registers, I think they're hardcoded?, so fake them for compatibility with our implementation..
+	deco_bac06_pf_control_0_w(state->m_tilegen1,0,0x0003, 0x00ff); // 8x8
+	deco_bac06_pf_control_0_w(state->m_tilegen1,1,0x0003, 0x00ff);
+	deco_bac06_pf_control_0_w(state->m_tilegen1,2,0x0000, 0x00ff);
+	deco_bac06_pf_control_0_w(state->m_tilegen1,3,0x0001, 0x00ff); // dimensions
+
+	deco_bac06_pf_control_0_w(state->m_tilegen2,0,0x0082, 0x00ff); // 16x16
+	deco_bac06_pf_control_0_w(state->m_tilegen2,1,0x0000, 0x00ff);
+	deco_bac06_pf_control_0_w(state->m_tilegen2,2,0x0000, 0x00ff);
+	deco_bac06_pf_control_0_w(state->m_tilegen2,3,0x0001, 0x00ff); // dimensions
+
+	deco_bac06_pf_control_0_w(state->m_tilegen3,0,0x0082, 0x00ff); // 16x16
+	deco_bac06_pf_control_0_w(state->m_tilegen3,1,0x0003, 0x00ff);
+	deco_bac06_pf_control_0_w(state->m_tilegen3,2,0x0000, 0x00ff);
+	deco_bac06_pf_control_0_w(state->m_tilegen3,3,0x0001, 0x00ff); // dimensions
+
+	// scroll registers got written elsewhere, copy them across
+	deco_bac06_pf_control_1_w(state->m_tilegen1,0,0x0000, 0xffff); // no scroll?
+	deco_bac06_pf_control_1_w(state->m_tilegen1,1,0x0000, 0xffff); // no scroll?
+
+	deco_bac06_pf_control_1_w(state->m_tilegen2,0,state->m_automat_scroll_regs[3] - 0x010a, 0xffff);
+	deco_bac06_pf_control_1_w(state->m_tilegen2,1,state->m_automat_scroll_regs[2], 0xffff);
+
+	deco_bac06_pf_control_1_w(state->m_tilegen3,0,state->m_automat_scroll_regs[1] - 0x0108, 0xffff);
+	deco_bac06_pf_control_1_w(state->m_tilegen3,1,state->m_automat_scroll_regs[0], 0xffff);
+
+	state->flip_screen_set(state->m_tilegen1->get_flip_state());
+
+	state->m_tilegen3->deco_bac06_pf_draw(screen.machine(),bitmap,cliprect,TILEMAP_DRAW_OPAQUE, 0x00, 0x00, 0x00, 0x00);
+	state->m_tilegen2->deco_bac06_pf_draw(screen.machine(),bitmap,cliprect,0, 0x00, 0x00, 0x00, 0x00);
+
+	state->m_spritegen->draw_sprites_bootleg(screen.machine(), bitmap, cliprect, state->m_buffered_spriteram, 0x00, 0x00, 0x0f);
+
+	/* Redraw top 8 pens of top 8 palettes over sprites */
+	if (state->m_pri&0x80)
+		state->m_tilegen2->deco_bac06_pf_draw(screen.machine(),bitmap,cliprect,0,0x08,0x08,0x08,0x08); // upper 8 pens of upper 8 priority marked tiles
+
+	state->m_tilegen1->deco_bac06_pf_draw(screen.machine(),bitmap,cliprect,0, 0x00, 0x00, 0x00, 0x00);
+	return 0;
+}
+
+
 /******************************************************************************/
 
 SCREEN_UPDATE_IND16( birdtry )
diff -Nru src-old/mame/video/decmxc06.c src/mame/video/decmxc06.c
--- src-old/mame/video/decmxc06.c	2012-04-09 19:30:29.000000000 +0200
+++ src/mame/video/decmxc06.c	2012-07-02 09:06:11.000000000 +0200
@@ -157,6 +157,39 @@
 	}
 }
 
+/* this is used by the automat bootleg, it seems to have greatly simplified sprites compared to the real chip */
+/* spriteram is twice the size tho! */
+void deco_mxc06_device::draw_sprites_bootleg( running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, UINT16* spriteram, int pri_mask, int pri_val, int col_mask )
+{
+	int offs;
+
+	offs = 0;
+	while (offs < 0x800 / 2)
+	{
+		int sx, sy, code, color, flipx, flipy;
+
+		code =  spriteram[offs];
+		sy = 240-spriteram[offs + 1]; // 241- will align robocop with the ground but causes other issues too
+		sx = spriteram[offs + 2];
+		code |= (spriteram[offs + 3] &0x0f)<<8;
+		flipx = !(spriteram[offs + 3] &0x20);
+		flipy = (spriteram[offs + 3] &0x40);
+		color = (spriteram[offs + 0x400]&0xf0)>>4;
+		sx |= (spriteram[offs + 0x400]&0x01)<<8;
+		sx -= 16;
+		sx &=0x1ff;
+
+		sx -= 0x100;
+
+		drawgfx_transpen(bitmap,cliprect,machine.gfx[m_gfxregion],
+			code,
+			color & col_mask,
+			flipx,flipy,
+			sx,sy,0);
+
+		offs += 4;
+	}
+}
 
 void deco_mxc06_device::device_start()
 {
diff -Nru src-old/mame/video/decmxc06.h src/mame/video/decmxc06.h
--- src-old/mame/video/decmxc06.h	2012-01-12 23:19:49.000000000 +0100
+++ src/mame/video/decmxc06.h	2012-06-12 14:24:58.000000000 +0200
@@ -8,6 +8,7 @@
 	static void set_gfx_region(device_t &device, int region);
 	void set_gfxregion(int region) { m_gfxregion = region; };
 	void draw_sprites( running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, UINT16* spriteram16, int pri_mask, int pri_val, int col_mask );
+	void draw_sprites_bootleg( running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, UINT16* spriteram, int pri_mask, int pri_val, int col_mask );
 	void set_pri_type( int type ) { m_priority_type = type; }
 protected:
 	virtual void device_start();
diff -Nru src-old/mame/video/pacman.c src/mame/video/pacman.c
--- src-old/mame/video/pacman.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/pacman.c	2012-06-19 18:12:49.000000000 +0200
@@ -344,7 +344,7 @@
 	if (m_palettebank != data)
 	{
 		m_palettebank = data;
-		m_bg_tilemap ->mark_all_dirty();
+		m_bg_tilemap->mark_all_dirty();
 	}
 }
 
@@ -353,7 +353,7 @@
 	if (m_colortablebank != data)
 	{
 		m_colortablebank = data;
-		m_bg_tilemap ->mark_all_dirty();
+		m_bg_tilemap->mark_all_dirty();
 	}
 }
 
@@ -363,7 +363,7 @@
 	{
 		m_spritebank = data & 1;
 		m_charbank = data & 1;
-		m_bg_tilemap ->mark_all_dirty();
+		m_bg_tilemap->mark_all_dirty();
 	}
 }
 
@@ -559,11 +559,6 @@
 	}
 }
 
-/***************************************************************************
-
-  Start the video hardware emulation.
-
-***************************************************************************/
 VIDEO_START( jrpacman )
 {
 	pacman_state *state = machine.driver_data<pacman_state>();
diff -Nru src-old/osd/sdl/sdl.mak src/osd/sdl/sdl.mak
--- src-old/osd/sdl/sdl.mak	2012-05-28 20:15:02.000000000 +0200
+++ src/osd/sdl/sdl.mak	2012-06-19 03:25:24.000000000 +0200
@@ -345,6 +345,16 @@
 SDLOS_TARGETOS = $(BASE_TARGETOS)
 
 #-------------------------------------------------
+# TEST_GCC for GCC version-specific stuff
+#-------------------------------------------------
+
+TEST_GCC = $(shell gcc --version)
+
+ifeq ($(findstring 4.7,$(TEST_GCC)),4.7)
+	CCOMFLAGS += -Wno-narrowing -Wno-attributes
+endif
+
+#-------------------------------------------------
 # Unix
 #-------------------------------------------------
 ifeq ($(BASE_TARGETOS),unix)
@@ -458,7 +468,6 @@
 # Static linking
 
 LDFLAGS += -static-libgcc
-TEST_GCC = $(shell gcc --version)
 ifeq ($(findstring 4.4,$(TEST_GCC)),)
 	#if we use new tools
 	LDFLAGS += -static-libstdc++
diff -Nru src-old/osd/windows/windows.mak src/osd/windows/windows.mak
--- src-old/osd/windows/windows.mak	2012-06-03 00:31:32.000000000 +0200
+++ src/osd/windows/windows.mak	2012-06-18 18:06:11.000000000 +0200
@@ -252,7 +252,9 @@
 	#if we use new tools
 	LDFLAGS += -static-libstdc++
 endif
-
+ifeq ($(findstring 4.7,$(TEST_GCC)),4.7)
+	CCOMFLAGS += -Wno-narrowing -Wno-attributes
+endif
 # add the windows libraries
 LIBS += -luser32 -lgdi32 -ldsound -ldxguid -lwinmm -ladvapi32 -lcomctl32 -lshlwapi -ldinput8 -lwsock32
 
diff -Nru src-old/tools/tools.mak src/tools/tools.mak
--- src-old/tools/tools.mak	2012-02-20 09:26:05.000000000 +0100
+++ src/tools/tools.mak	2012-06-11 20:11:48.000000000 +0200
@@ -84,10 +84,10 @@
 CHDMANOBJS = \
 	$(TOOLSOBJ)/chdman.o \
 
-chdman$(EXE): $(VERSIONOBJ) $(CHDMANOBJS) $(LIBUTIL) $(ZLIB) $(EXPAT) $(FLAC_LIB) $(7Z_LIB) $(LIBOCORE)
+chdman$(EXE): $(CHDMANOBJS) $(LIBUTIL) $(ZLIB) $(EXPAT) $(FLAC_LIB) $(7Z_LIB) $(LIBOCORE)
 	$(CC) $(CDEFS) $(CFLAGS) -c $(SRC)/version.c -o $(VERSIONOBJ)
 	@echo Linking $@...
-	$(LD) $(LDFLAGS) $^ $(LIBS) $(FLAC_LIB) -o $@
+	$(LD) $(LDFLAGS) $(VERSIONOBJ) $^ $(LIBS) $(FLAC_LIB) -o $@
 
 
 
diff -Nru src-old/version.c src/version.c
--- src-old/version.c	2012-06-11 10:00:48.000000000 +0200
+++ src/version.c	2012-07-02 09:06:11.000000000 +0200
@@ -38,4 +38,4 @@
 ***************************************************************************/
 
 extern const char build_version[];
-const char build_version[] = "0.146u1 ("__DATE__")";
+const char build_version[] = "0.146u2 ("__DATE__")";
